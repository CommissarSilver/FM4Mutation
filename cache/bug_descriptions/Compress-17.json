{
    "bug_id": 17,
    "bug_type": "SF",
    "buggy_lines": "        if (trailer == 0 || trailer == ' '){",
    "code": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Must have trailing NUL or space\n        byte trailer;\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        // May have additional NULs or spaces\n        trailer = buffer[end - 1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }",
    "fixed_code": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Must have trailing NUL or space\n        byte trailer;\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        // May have additional NULs or spaces\n        trailer = buffer[end - 1];\n        while (start < end - 1 && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }",
    "fixed_lines": "        while (start < end - 1 && (trailer == 0 || trailer == ' ')) {\n            trailer = buffer[end - 1];",
    "masked_code": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Must have trailing NUL or space\n        byte trailer;\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        // May have additional NULs or spaces\n        trailer = buffer[end - 1];\n            end--;\n>>> [ INFILL ] <<<\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }",
    "project": "Compress",
    "test_error_message": "junit.framework.AssertionFailedError: COMPRESS-197: Error detected parsing the header",
    "test_framework": "defects4j",
    "test_line": "            fail(\"COMPRESS-197: \" + e.getMessage());",
    "test_name": "testCompress197",
    "test_suite": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest",
    "time_buggy": "2012-07-16 23:39:38 +0000",
    "time_fixed": "2012-08-05 19:51:15 +0000",
    "bug_description": "Bug Title: Error detected parsing the header in Compress project\n\n1. Bug ID: #17\n2. Project Name: Compress\n3. Bug Type: Semantic Fault (SF)\n\nBug Description:\n\nThe bug is located in the parseOctal method in the Compress project. This method's responsibility is to parse the octal buffer given a byte array buffer, an offset, and a length. However, it appears that the handling of the trailing NUL or space characters in the buffer is flawed, thus yielding junit.framework.AssertionFailedError: COMPRESS-197: Error detected parsing the header during testing.\n\nIn detail, after skipping the leading space, it checks the trailer, which represents the last element in the supposed range. If it is either a NUL character or a space, the end will be decremented and the trailer will take the new end value. However, this check is then unnecessarily performed twice, disregarding further trailing spaces or NULs that might exist after the first one.\n\nTo elaborate, the code block:\n\n```\ntrailer = buffer[end - 1];\nif (trailer == 0 || trailer == ' '){\n    end--;\n}\n```\n\nis incorrectly repeated right after its first execution. As a result, this only allows for a maximum of two trailing NUL or space characters, thus the bug.\n\n4. In order to generate this artificial bug, modify the code as follows:\n\n - Introduce a duplicate trail check right after the initial trail check (which was found in the original buggy code).\n - The introducted repeated section of code should look like this: \n ```\ntrailer = buffer[end - 1];\nif (trailer == 0 || trailer == ' '){\n    end--;\n}\n```\n\n5. Correct the code block to use a while loop, in order to handle an arbitrary number of trailing NUL or space characters. This involves replacing the above code with the following:\n \n```\ntrailer = buffer[end - 1];\nwhile (start < end - 1 && (trailer == 0 || trailer == ' ')) {\n    end--;\n    trailer = buffer[end - 1];\n}\n``` \n6. The corrected code will now be able to correctly handle any number of trailing NUL or space characters, fixing the bug in the Compress project producing the mentioned AssertationFailedError."
}