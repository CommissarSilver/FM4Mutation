{
    "bug_id": 96,
    "bug_type": "SL SH SF",
    "buggy_lines": "                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); ",
    "code": "    public boolean equals(Object other) {\n        boolean ret;\n        \n        if (this == other) { \n            ret = true;\n        } else if (other == null) {\n            ret = false;\n        } else  {\n            try {\n                Complex rhs = (Complex)other;\n                if (rhs.isNaN()) {\n                    ret = this.isNaN();\n                } else {\n                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                }\n            } catch (ClassCastException ex) {\n                // ignore exception\n                ret = false;\n            }\n        }\n      \n        return ret;\n    }",
    "fixed_code": "    public boolean equals(Object other) {\n        boolean ret;\n        \n        if (this == other) { \n            ret = true;\n        } else if (other == null) {\n            ret = false;\n        } else  {\n            try {\n                Complex rhs = (Complex)other;\n                if (rhs.isNaN()) {\n                    ret = this.isNaN();\n                } else {\n                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); \n                }\n            } catch (ClassCastException ex) {\n                // ignore exception\n                ret = false;\n            }\n        }\n      \n        return ret;\n    }",
    "fixed_lines": "                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); ",
    "masked_code": "    public boolean equals(Object other) {\n        boolean ret;\n        \n        if (this == other) { \n            ret = true;\n        } else if (other == null) {\n            ret = false;\n        } else  {\n            try {\n                Complex rhs = (Complex)other;\n                if (rhs.isNaN()) {\n                    ret = this.isNaN();\n                } else {\n>>> [ INFILL ] <<<\n                }\n            } catch (ClassCastException ex) {\n                // ignore exception\n                ret = false;\n            }\n        }\n      \n        return ret;\n    }",
    "project": "Math",
    "test_error_message": "junit.framework.AssertionFailedError: expected:<org.apache.commons.math.complex.Complex@98b00000> but was:<org.apache.commons.math.complex.Complex@18b00000>",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(new Complex(0,-1), new Complex(0,1).multiply(new Complex(-1,0)));",
    "test_name": "testMath221",
    "test_suite": "org.apache.commons.math.complex.ComplexTest",
    "time_buggy": "2008-08-21 00:19:48 +0000",
    "time_fixed": "2008-08-29 15:46:22 +0000",
    "bug_description": "Bug Description:\n\nBug ID: 96 \nProject: Math \nBug Type: Structural (SL), Syntactical (SH), Semantic (SF)\n\nIn this case, we are dealing with a bug in the \"equals\" function of the Complex numbers class. The function is wrongly comparing the raw bits representation of double values, which might not be the correct comparison in certain edge cases (like pos and neg zero, NaNs and infinities).\n\nStep 1: The \"equals\" method is called for a Complex number object and passed another Complex number object as the argument.\n\nStep 2: If the current object and passed object are same (which means they're pointing to the same memory location), the method correctly returns true.\n\nStep 3: However, if the passed object is different (i.e., a different Complex number object), the function tries to cast the object into a Complex variable \"rhs\". \n\nStep 4: Inside the try block, if the Complex object \"rhs\" is a NaN (not a number), it compares it against the calling object's NaN status, which is correct. \n\nStep 5: The bug happens in the following situation. If the \"rhs\" object is a legitimate number, the code tries to compare the bit representation of the real and imaginary parts of the Complex objects. The issue lies in the usage of \"Double.doubleToRawLongBits()\". This method compares the raw double value in the bit representation, and this comparison will fail in certain cases. For instance, when comparing -0.0 and +0.0, where mathematical equality should be true, but in a bit-wise comparison, it will wrongly evaluate to false.\n\nStep 6: The fix is applied in the else block. Instead of comparing the raw long bit values of real and imaginary parts, we directly check the equality of real and imaginary parts from both Complex objects. So, the correct comparison is 'real == rhs.real' and 'imaginary == rhs.imaginary'. \n\nSummarizing, the failure is confirmed with the test error message, \"junit.framework.AssertionFailedError: expected:<org.apache.commons.math.complex.Complex@98b00000> but was: <org.apache.commons.math.complex.Complex@18b00000>\", which signifies that the expected and actual outputs of the function call are different."
}