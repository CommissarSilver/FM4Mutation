{
    "bug_id": 6,
    "bug_type": "SL SH SF",
    "buggy_lines": "                pos += Character.charCount(Character.codePointAt(input, pos));",
    "code": "    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = input.length();\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n                pos+= c.length;\n                continue;\n            }\n//          // contract with translators is that they have to understand codepoints \n//          // and they just took care of a surrogate pair\n            for (int pt = 0; pt < consumed; pt++) {\n                pos += Character.charCount(Character.codePointAt(input, pos));\n            }\n        }\n    }",
    "fixed_code": "    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = input.length();\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n                pos+= c.length;\n                continue;\n            }\n//          // contract with translators is that they have to understand codepoints \n//          // and they just took care of a surrogate pair\n            for (int pt = 0; pt < consumed; pt++) {\n                pos += Character.charCount(Character.codePointAt(input, pt));\n            }\n        }\n    }",
    "fixed_lines": "                pos += Character.charCount(Character.codePointAt(input, pt));",
    "masked_code": "    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = input.length();\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n                pos+= c.length;\n                continue;\n            }\n//          // contract with translators is that they have to understand codepoints \n//          // and they just took care of a surrogate pair\n            for (int pt = 0; pt < consumed; pt++) {\n>>> [ INFILL ] <<<\n            }\n        }\n    }",
    "project": "Lang",
    "test_error_message": "java.lang.StringIndexOutOfBoundsException: String index out of range: 2",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(\"\\uD83D\\uDE30\", StringEscapeUtils.escapeCsv(\"\\uD83D\\uDE30\"));",
    "test_name": "testEscapeSurrogatePairs",
    "test_suite": "org.apache.commons.lang3.StringUtilsTest",
    "time_buggy": "2012-11-13 13:21:37 +0000",
    "time_fixed": "2012-11-20 20:45:50 +0000",
    "bug_description": "Bug ID: 6\nProject: Lang\nBug Type: SL SH SF\nTest Error Message: java.lang.StringIndexOutOfBoundsException: String index out of range: 2\n\nDescription:\n\n1. The bug is located in the method `translate(CharSequence input, Writer out)` in the Lang project. This bug is of type SL SH SF, which involves semantic bugs and incorrect error handling.\n\n2. The error message triggered by this bug is `java.lang.StringIndexOutOfBoundsException: String index out of range: 2`. This exception is thrown by method `Character.charCount(Character.codePointAt(input, pos))` within for loop.\n\n3. Looking into the code, it seems that the `pos` variable, which is used as the index of `input` string, exceeds the length of `input`, causing the StringIndexOutOfBoundsException.\n\n4. In the buggy line, `pos += Character.charCount(Character.codePointAt(input, pos));` , `pos` variable is being incremented by the char count of code point at `pos` index in the input string. \n\n5. If the call to `Character.charCount(Character.codePointAt(input, pos))` results in a value that makes `pos` exceed the length of `input`, the StringIndexOutOfBoundsException is thrown in the subsequent iterations of the loop.\n\n6. A fix for this bug is to replace `pos` by `pt` in the method `Character.codePointAt(input, pt)`. Here, `pt` is the loop variable which will always be smaller than `consumed`. This ensures that there won't be an attempt to access a string index that is out of range.\n\n7. The fixed line of code, `pos += Character.charCount(Character.codePointAt(input, pt));`, ensures that `pos` does not exceed the length of the input string, and thus prevents the StringIndexOutOfBoundsException. This provides a better implementation of the functionality that the developer wanted to achieve, which is to understand the code points in the input and handle surrogate pairs.\n\nTo generate artificial java bugs similar to this:\n1. Developers can incorrectly use the length or a position variable that does not properly take into account the bounds of a string or array.\n2. Severe unchecked exceptions like ArrayIndexOutOfBoundsException or StringIndexOutOfBoundsException.\n3. Incorrect loop condition or variable update logic leading to accessing array or string index out of bounds."
}