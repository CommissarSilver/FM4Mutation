{
    "bug_id": 74,
    "bug_type": "SH SF",
    "buggy_lines": "",
    "code": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt,\n            TokenBuffer tb) throws IOException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                p = tb.asParser(p);\n                // must move to point to the first token:\n                p.nextToken();\n            }\n            return deser.deserialize(p, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(p, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\n        if (p.getCurrentToken() == JsonToken.START_ARRAY) {\n            return super.deserializeTypedFromAny(p, ctxt);\n        }\n        ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n        return null;\n    }",
    "fixed_code": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt,\n            TokenBuffer tb) throws IOException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                p = tb.asParser(p);\n                // must move to point to the first token:\n                p.nextToken();\n            }\n            return deser.deserialize(p, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(p, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\n        if (p.getCurrentToken() == JsonToken.START_ARRAY) {\n            return super.deserializeTypedFromAny(p, ctxt);\n        } else if (p.getCurrentToken() == JsonToken.VALUE_STRING) {\n            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n                String str = p.getText().trim();\n                if (str.isEmpty()) {\n                    return null;\n                }\n            }\n        }\n        ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n        return null;\n    }",
    "fixed_lines": "        } else if (p.getCurrentToken() == JsonToken.VALUE_STRING) {\n            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n                String str = p.getText().trim();\n                if (str.isEmpty()) {\n                    return null;\n                }\n            }",
    "masked_code": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt,\n            TokenBuffer tb) throws IOException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                p = tb.asParser(p);\n                // must move to point to the first token:\n                p.nextToken();\n            }\n            return deser.deserialize(p, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(p, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\n        if (p.getCurrentToken() == JsonToken.START_ARRAY) {\n            return super.deserializeTypedFromAny(p, ctxt);\n>>> [ INFILL ] <<<\n        }\n        ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n        return null;\n    }",
    "project": "JacksonDatabind",
    "test_error_message": "com.fasterxml.jackson.databind.JsonMappingException: Unexpected token (VALUE_STRING), expected FIELD_NAME: missing property 'type' that is to contain type id (for class com.fasterxml.jackson.databind.jsontype.TestPolymorphicWithDefaultImpl$AsProperty)",
    "test_framework": "defects4j",
    "test_line": "",
    "test_name": "testWithEmptyStringAsNullObject1533",
    "test_suite": "com.fasterxml.jackson.databind.jsontype.TestPolymorphicWithDefaultImpl",
    "time_buggy": "2017-02-20 17:06:13 -0800",
    "time_fixed": "2017-02-23 10:00:47 -0800",
    "bug_description": "Bug ID: 74\nProject: JacksonDatabind\nBug Type: SH SF\n\nBug Description: \n\nThere was a JsonMappingException due to an unexpected token. The exception indicates that the library expected a FIELD_NAME token, however, a VALUE_STRING token was received. The issue arises when the library tries to deserialize an object, and it can't find the necessary property 'type' to contain the type id for a specific class.\n\nWhere: \n\nIn the method _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt, TokenBuffer tb) of class `com.fasterxml.jackson.databind.jsontype`.\n\nSteps to Reproduce:\n\n    1. Call the `_deserializeTypedUsingDefaultImpl` function.\n    2. Pass a JsonParser object, a DeserializationContext and a TokenBuffer to this function.\n    3. The exception was encountered when the function was not able to handle the case where the current token is a VALUE_STRING.\n\nBuggy Code:\n\nBuggy code is found on the line that is calling the `ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME)`. If the current token is not a START_ARRAY token, it directly throws an exception without checking for other possible scenarios.\n\nFix:\n\nA conditional block was added to check if the current token is of type VALUE_STRING. If true, it checks whether the feature DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT is enabled. If it is, it will get the trimmed text from the parser and if that is empty, it will return null instead of throwing an exception.\n\nChanges were made on these lines to correct the code:\n\n    else if (p.getCurrentToken() == JsonToken.VALUE_STRING) {\n        if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n            String str = p.getText().trim();\n            if (str.isEmpty()) {\n                return null;\n            }\n        }\n    }\n\nOn encountering a VALUE_STRING token, the fixed code checks whether empty strings are considered as null objects, as per certain deserialization feature settings. If so, it fetches the string, trims it and returns null if the string is empty, instead of throwing a wrong token exception."
}