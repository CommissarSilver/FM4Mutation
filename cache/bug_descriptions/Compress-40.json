{
    "bug_id": 40,
    "bug_type": "SF",
    "buggy_lines": "",
    "code": "    public long readBits(final int count) throws IOException {\n        if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n            throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n        }\n        while (bitsCachedSize < count) {\n            final long nextByte = in.read();\n            if (nextByte < 0) {\n                return nextByte;\n            }\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                bitsCached |= (nextByte << bitsCachedSize);\n            } else {\n                bitsCached <<= 8;\n                bitsCached |= nextByte;\n            }\n            bitsCachedSize += 8;\n        }\n            // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n        \n        final long bitsOut;\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                bitsOut = (bitsCached & MASKS[count]);\n                bitsCached >>>= count;\n            } else {\n                bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n            }\n            bitsCachedSize -= count;\n        return bitsOut;\n    }",
    "fixed_code": "    public long readBits(final int count) throws IOException {\n        if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n            throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n        }\n        while (bitsCachedSize < count && bitsCachedSize < 57) {\n            final long nextByte = in.read();\n            if (nextByte < 0) {\n                return nextByte;\n            }\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                bitsCached |= (nextByte << bitsCachedSize);\n            } else {\n                bitsCached <<= 8;\n                bitsCached |= nextByte;\n            }\n            bitsCachedSize += 8;\n        }\n        int overflowBits = 0;\n        long overflow = 0l;\n        if (bitsCachedSize < count) {\n            // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n            int bitsToAddCount = count - bitsCachedSize;\n            overflowBits = 8 - bitsToAddCount;\n            final long nextByte = in.read();\n            if (nextByte < 0) {\n                return nextByte;\n            }\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                long bitsToAdd = nextByte & MASKS[bitsToAddCount];\n                bitsCached |= (bitsToAdd << bitsCachedSize);\n                overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits];\n            } else {\n                bitsCached <<= bitsToAddCount;\n                long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount];\n                bitsCached |= bitsToAdd;\n                overflow = nextByte & MASKS[overflowBits];\n            }\n            bitsCachedSize = count;\n        }\n        \n        final long bitsOut;\n        if (overflowBits == 0) {\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                bitsOut = (bitsCached & MASKS[count]);\n                bitsCached >>>= count;\n            } else {\n                bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n            }\n            bitsCachedSize -= count;\n        } else {\n            bitsOut = bitsCached & MASKS[count];\n            bitsCached = overflow;\n            bitsCachedSize = overflowBits;\n        }\n        return bitsOut;\n    }",
    "fixed_lines": "        } else {\n            bitsOut = bitsCached & MASKS[count];\n            bitsCached = overflow;\n            bitsCachedSize = overflowBits;\n        }",
    "masked_code": "    public long readBits(final int count) throws IOException {\n        if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n            throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n        }\n            final long nextByte = in.read();\n            if (nextByte < 0) {\n                return nextByte;\n            }\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                bitsCached |= (nextByte << bitsCachedSize);\n            } else {\n                bitsCached <<= 8;\n                bitsCached |= nextByte;\n            }\n            bitsCachedSize += 8;\n        }\n            // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n        \n        final long bitsOut;\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                bitsOut = (bitsCached & MASKS[count]);\n                bitsCached >>>= count;\n            } else {\n                bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n            }\n            bitsCachedSize -= count;\n>>> [ INFILL ] <<<\n        return bitsOut;\n    }",
    "project": "Compress",
    "test_error_message": "junit.framework.AssertionFailedError: expected:<1186> but was:<1184>",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(1186, // 01001010-0010",
    "test_name": "littleEndianWithOverflow",
    "test_suite": "org.apache.commons.compress.utils.BitInputStreamTest",
    "time_buggy": "2016-06-27 10:02:45 +0200",
    "time_fixed": "2016-07-01 21:37:24 +0200",
    "bug_description": "Bug Description:\n\n- Bug ID: 40\n- Project: Compress\n- Bug Type: SF (Software Fault)\n\nThe bug appears in the 'readBits' method in the 'Compress' project. It seems to deal with reading a certain number of bits from a data source and returns the readout. The bug is related to a Software Fault, so it likely pertains to an incorrect, missing or unexpected behavior of the method.\n\nStep 1: The bug is found in the 'readBits' method, which reads a specified number of bits from a data source and returns the result. The function takes an integer parameter 'count', representing the number of bits to read. \n\nStep 2: The method starts by checking if 'count' is less than 0 or greater than a constant 'MAXIMUM_CACHE_SIZE'. If 'count' doesn't meet these conditions, an IllegalArgumentException is thrown. This part seems to work fine.\n\nStep 3: The function continues in a while-loop that continues to read bits until 'count' bits have been read or until the end of the data source. If an end of file indicator (-1) is encountered before 'count' bits have been read, it returns -1. \n\nStep 4: The problem appears to come when 'bitsCachedSize' exceeds the value of 57. The comment inside the fixed code implies that if 'bitsCachedSize' is greater or equal to 57, a left-shift operation would cause an overflow, causing incorrect behavior. The original code doesn't account for this situation.\n\nStep 5: The bug causes the bits read out (bitsOut) to be incorrect, resulting in the junit test failure 'expected:<1186> but was:<1184>', since the expected and actual returns of the method differ.\n\nSolution: The bug was fixed by adding a check to the while-loop that stops bits from being read if 'bitsCachedSize' is equal or greater than 57, preventing an overflow. Moreover, to ensure all bits are read, an additional segment was added that reads just enough bits to reach count while avoiding overflow. The function adjusts for endianness and masks the gotten bits to count. If 'bitsCachedSize' is still less than 'count' after this, the remaining bits to read are added to 'bitsCached'. The function now properly handles cases that would cause an overflow in the original implementation.\n\nThe fixed 'readBits' method now returns the correct result and passes the junit test."
}