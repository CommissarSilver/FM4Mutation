{
    "bug_id": 6,
    "bug_type": "SF",
    "buggy_lines": "            return base64.readResults(b, offset, len);",
    "code": "    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    // A little optimization to avoid System.arraycopy()\n                    // when possible.\n                    if (c > 0 && b.length == len) {\n                        base64.setInitialBuffer(b, offset, len);\n                    }\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n            return base64.readResults(b, offset, len);\n        }\n    }",
    "fixed_code": "    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n            while (readLen == 0) {\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    // A little optimization to avoid System.arraycopy()\n                    // when possible.\n                    if (c > 0 && b.length == len) {\n                        base64.setInitialBuffer(b, offset, len);\n                    }\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n                readLen = base64.readResults(b, offset, len);\n            }\n            return readLen;\n        }\n    }",
    "fixed_lines": "                readLen = base64.readResults(b, offset, len);\n            }\n            return readLen;",
    "masked_code": "    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    // A little optimization to avoid System.arraycopy()\n                    // when possible.\n                    if (c > 0 && b.length == len) {\n                        base64.setInitialBuffer(b, offset, len);\n                    }\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n>>> [ INFILL ] <<<\n        }\n    }",
    "project": "Codec",
    "test_error_message": "junit.framework.AssertionFailedError: Codec101: First read successful [c=0]",
    "test_framework": "defects4j",
    "test_line": "        assertTrue(\"Codec101: First read successful [c=\" + c + \"]\", c > 0);",
    "test_name": "testCodec101",
    "test_suite": "org.apache.commons.codec.binary.Base64InputStreamTest",
    "time_buggy": "2011-01-20 16:33:34 +0000",
    "time_fixed": "2011-01-21 19:19:51 +0000",
    "bug_description": "Bug Description:\n\n1. Bug ID: Bug 6\n\n2. Project: The project involved is 'Codec'. \n\n3. Bug Type: The bug type is an SF (Segmentation Fault), referring to a specific kind of error caused by accessing memory that \"does not belong to you.\" It's a common bug found in languages like C/C++, and it can lead to serious vulnerabilities in a program.\n\n4. Error Message: The test error message provided is junit.framework.AssertionFailedError: Codec101: First read successful [c=0]. This suffers a failure indicated by the AssertionFailedError from the Junit testing framework for the Codec project. \n\n5. Description: The code shown above is a read method aiming to read bytes from an input stream into a given byte array. If the byte array passed into this method is null, it throws a NullPointerException. If the offset or len (length) values are less than zero, or the offset is greater than the byte array length, it throws an IndexOutOfBoundsException. \n\n   The problematic line in the script is 'return base64.readResults(b, offset, len);'. This line of code is attempting to read base64 encoded data, however, it fails to handle cases where an 'InputStream.read(byte[])' returns a zero, which InputStreamReader doesn't handle properly.\n\n6. Fix: The fix includes replacement of the problematic line with a while-loop, that will continue to invoke the 'base64.readResults(b, offset, len)' call until it returns a non-zero value, handling the case that InputStreamReader demands. The returned result is returned from the read method as the read length ('readLen'). \n\nThis bug offers a clear explanation of understanding a specific case when handling InputStreams and adjusting the code to meet the requirements of other classes using these streams (e.g., InputStreamReader). It shows handling the exception created by a returned zero from 'InputStream.read(byte[])' and tests until a non-zero is achieved to comply with the InputStreamReader's preferences."
}