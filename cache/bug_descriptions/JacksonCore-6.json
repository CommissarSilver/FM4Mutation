{
    "bug_id": 6,
    "bug_type": "SH SF",
    "buggy_lines": "        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i);",
    "code": "    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [core#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        // [core#176]: no leading zeroes allowed\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i);\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }",
    "fixed_code": "    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [core#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        // [core#176]: no leading zeroes allowed\n        char c = str.charAt(0);\n        if (c <= '0') {\n            return (len == 1 && c == '0') ? 0 : -1;\n        }\n        if (c > '9') {\n            return -1;\n        }\n        for (int i = 1; i < len; ++i) {\n            c = str.charAt(i);\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }",
    "fixed_lines": "        char c = str.charAt(0);\n        if (c <= '0') {\n            return (len == 1 && c == '0') ? 0 : -1;\n        }\n        if (c > '9') {\n            return -1;\n        }\n        for (int i = 1; i < len; ++i) {\n            c = str.charAt(i);",
    "masked_code": "    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [core#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        // [core#176]: no leading zeroes allowed\n>>> [ INFILL ] <<<\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }",
    "project": "JacksonCore",
    "test_error_message": "junit.framework.AssertionFailedError: expected:<-1> but was:<0>",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(-1, ptr.getMatchingIndex());",
    "test_name": "testIZeroIndex",
    "test_suite": "com.fasterxml.jackson.core.TestJsonPointer",
    "time_buggy": "2014-12-07 10:16:55 -0800",
    "time_fixed": "2014-12-30 17:09:51 -0800",
    "bug_description": "Bug Title: Improper handling of leading zero in the method _parseIndex\n\nBug ID: 6\nProject: JacksonCore\nBug Type: SH SF\nPriority: Medium \n\nDescription:\nThe bug in the JacksonCore project is of the type SH SF, which stands for Simple Heterogeneous Change and Statement Fixed/Edited.\n\nThis bug is occurring specifically in the method _parseIndex and is related to how the method handles a string input and converts it to an integer. When the string contains leading zeros, the function is supposed to return -1.\n\nIn the buggy code:\nThe function starts by checking if the length of the input string is zero or more than 10. If it is, the function immediately returns -1. Then, it starts a loop, iterating through each character of the string and checking if the character is less than '0' or more than '9'. If the loop completes without any character failing the test, it returns the value obtained by parsing the integer value of the input string.\n\nThe Bug:\nUpon testing, an AssertionFailedError was raised with the expected value being -1 but found value being 0. This suggests that the bug lies in the handling of strings with leading zeros as it is expected to return -1 but it returns 0 instead. This occurs since the function seems to ignore the leading zeroes and return the value obtained by parsing the integer value of the string.\n\nSteps to Reproduce:\n1. Create a string with a leading zero and use it as input to the _parseIndex function.\n2. The expected output according to initial implementation would be -1.\n3. But the returned output would be 0 which triggers the test's AssertionFailedError.\n\nIn the provided fixed code, it specifically checks the first character of the string separately. If it's '0', it handles the situation differently based on whether the string is of length 1 or not. For further characters, the same checks as before are carried out and the integer value of the string is returned at the end.\n\nHence, robust handling of a leading zero is the fix for this bug in JacksonCore's _parseIndex function. Such detailed artificial Java bugs help developer gain knowledge on handling edge cases and various other possibilities to make a function more comprehensive."
}