{
    "bug_id": 1,
    "bug_type": "SH SF",
    "buggy_lines": "            throw new UnsupportedOperationException();",
    "code": "    public void captureArgumentsFrom(Invocation invocation) {\n        if (invocation.getMethod().isVarArgs()) {\n            int indexOfVararg = invocation.getRawArguments().length - 1;\n            throw new UnsupportedOperationException();\n\n        } else {\n            for (int position = 0; position < matchers.size(); position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n        }\n\n//        for (int position = 0; position < matchers.size(); position++) {\n//            Matcher m = matchers.get(position);\n//            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n//                //TODO SF - this whole lot can be moved captureFrom implementation\n//                if(isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n//                    Object array = invocation.getRawArguments()[position];\n//                    for (int i = 0; i < Array.getLength(array); i++) {\n//                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n//                    }\n//                    //since we've captured all varargs already, it does not make sense to process other matchers.\n//                    return;\n//                } else {\n//                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n//                }\n//            }\n//        }\n    }",
    "fixed_code": "    public void captureArgumentsFrom(Invocation invocation) {\n        if (invocation.getMethod().isVarArgs()) {\n            int indexOfVararg = invocation.getRawArguments().length - 1;\n            for (int position = 0; position < indexOfVararg; position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n            for (int position = indexOfVararg; position < matchers.size(); position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);\n                }\n            }\n\n        } else {\n            for (int position = 0; position < matchers.size(); position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n        }\n\n//        for (int position = 0; position < matchers.size(); position++) {\n//            Matcher m = matchers.get(position);\n//            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n//                //TODO SF - this whole lot can be moved captureFrom implementation\n//                if(isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n//                    Object array = invocation.getRawArguments()[position];\n//                    for (int i = 0; i < Array.getLength(array); i++) {\n//                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n//                    }\n//                    //since we've captured all varargs already, it does not make sense to process other matchers.\n//                    return;\n//                } else {\n//                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n//                }\n//            }\n//        }\n    }",
    "fixed_lines": "            for (int position = 0; position < indexOfVararg; position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n            for (int position = indexOfVararg; position < matchers.size(); position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);\n                }\n            }",
    "masked_code": "    public void captureArgumentsFrom(Invocation invocation) {\n        if (invocation.getMethod().isVarArgs()) {\n            int indexOfVararg = invocation.getRawArguments().length - 1;\n>>> [ INFILL ] <<<\n\n        } else {\n            for (int position = 0; position < matchers.size(); position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n        }\n\n//        for (int position = 0; position < matchers.size(); position++) {\n//            Matcher m = matchers.get(position);\n//            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n//                //TODO SF - this whole lot can be moved captureFrom implementation\n//                if(isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n//                    Object array = invocation.getRawArguments()[position];\n//                    for (int i = 0; i < Array.getLength(array); i++) {\n//                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n//                    }\n//                    //since we've captured all varargs already, it does not make sense to process other matchers.\n//                    return;\n//                } else {\n//                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n//                }\n//            }\n//        }\n    }",
    "project": "Mockito",
    "test_error_message": "java.lang.UnsupportedOperationException",
    "test_framework": "defects4j",
    "test_line": "        invocationMatcher.captureArgumentsFrom(invocation);",
    "test_name": "should_capture_arguments_when_args_count_does_NOT_match",
    "test_suite": "org.mockito.internal.invocation.InvocationMatcherTest",
    "time_buggy": "2015-06-04 10:13:46 +0200",
    "time_fixed": "2015-06-04 10:13:46 +0200",
    "bug_description": "Bug ID: 1\nProject Name: Mockito\nBug Type: SH SF (Statement/Expression harmful simplicity)\n\nDetailed Report:\n\n1. Problem Description:\nThe function `captureArgumentsFrom(Invocation invocation)` in the Mockito project, is throwing an`UnsupportedOperationException` when the method in the invocation has variable arguments (`isVarArgs()`). This results in a Java exception.\n\n2. Steps to Reproduce:\nThis bug can be reproduced by \n- Create an invocation with a method that has variable arguments\n- Call the `captureArgumentsFrom(Invocation invocation)` with the created invocation as an argument\n\n3. Root Cause:\nThe root cause of the bug is that the software is not currently designed to handle methods with variable arguments\u2014the exception is thrown as a placeholder indicating that functionality hasn't been implemented yet. \n\n4. Buggy Lines:\n```java\nthrow new UnsupportedOperationException();\n```\n\nThe above line is inside a condition that checks if the method has variable arguments. If it does, an exception is thrown.\n\n5. Bug Fix:\nThe bug was fixed by adding an algorithm that handles variable arguments before they are invoked. A loop was added to iterate over the arguments and apply the needed functionality before any potential invocation. \n\n6. Fixed lines in the code: \n```java\nfor (int position = 0; position < indexOfVararg; position++) {\n    Matcher m = matchers.get(position);\n    if (m instanceof CapturesArguments) {\n        ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n    }\n}\nfor (int position = indexOfVararg; position < matchers.size(); position++) {\n    Matcher m = matchers.get(position);\n    if (m instanceof CapturesArguments) {\n        ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);\n    }\n}\n```\n\n7. How to generate artificially:\n\nTo create an artificial Java bug similar to bug ID: 1, developers can deliberately leave specific code scenarios unhandled or mismanaged. They can throw exceptions for cases they have not yet implemented, just like the `UnsupportedOperationException` thrown in the bug discussed here. After that, they can simulate unit tests or deliver features that trigger these unhandled scenarios."
}