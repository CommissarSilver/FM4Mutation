{
    "bug_id": 160,
    "bug_type": "SF",
    "buggy_lines": "        (warningsGuard == null || !warningsGuard.disables(\n            DiagnosticGroups.CHECK_VARIABLES))) {\n      guards.add(new DiagnosticGroupWarningsGuard(\n    this.warningsGuard = new ComposeWarningsGuard(guards);",
    "code": "  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        (warningsGuard == null || !warningsGuard.disables(\n            DiagnosticGroups.CHECK_VARIABLES))) {\n      guards.add(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = new ComposeWarningsGuard(guards);\n  }",
    "fixed_code": "  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = composedGuards;\n  }",
    "fixed_lines": "        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n    this.warningsGuard = composedGuards;",
    "masked_code": "  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n>>> [ INFILL ] <<<\n  }",
    "project": "Closure",
    "test_error_message": "junit.framework.AssertionFailedError: Expected exactly one warning or error Errors:",
    "test_framework": "defects4j",
    "test_line": "    assertEquals(\"Expected exactly one warning or error \" +",
    "test_name": "testCheckSymbolsOverrideForQuiet",
    "test_suite": "com.google.javascript.jscomp.CommandLineRunnerTest",
    "time_buggy": "2011-05-27 17:19:00 +0000",
    "time_fixed": "2011-05-27 17:34:04 +0000",
    "bug_description": "Bug Description:\n\n**Bug ID:** 160\n\n**Project:** Closure\n\n**Bug Type:** Semantic Functional (SF) Bug \n\n**Error Message:** junit.framework.AssertionFailedError: Expected exactly one warning or error Errors\n\n**Issue:**\nThe problem resides in the `initOptions` method of our class. The method is meant to initialize `CompilerOptions` but is failing to do so correctly leading to an unexpected number of warning or error messages. The main cause is linked to the operation related to setting up the Warnings Guards - a mechanism that determines what kind of warning messages should be restricted from appearing. \n\nIn this case, the class is trying to add a `DiagnosticGroupWarningsGuard` to the `warningsGuard` but only if certain conditions are met - where `checkSymbols` is false and `warningsGuard` is either null or does not disable `CHECK_VARIABLES`. However, it is failing to handle the situation appropriately.\n\n**Defective Code:**\n```\nif (!options.checkSymbols &&\n    (warningsGuard == null || !warningsGuard.disables(\n        DiagnosticGroups.CHECK_VARIABLES))) {\n  guards.add(new DiagnosticGroupWarningsGuard(\n      DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n}\n\nthis.warningsGuard = new ComposeWarningsGuard(guards);\n```\n\n**Fix:** \nThe fix involves replacing `warningsGuard.disables` call with a test to see if a composed instance of `ComposeWarningsGuard` enables `CHECK_VARIABLES`. This modification corrects the guard addition process and helps to avoid a failure in case of null `warningsGuard`.\n\n**Corrected Code:**\n```\nComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\nif (!options.checkSymbols &&\n    !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n  composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n      DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n}\n\nthis.warningsGuard = composedGuards;\n```\n\nIn the fixed code, instead of iterating and adding guards directly to `warningsGuard`, a `ComposeWarningsGuard` instance is created with all the guards. Then, to check for missing variable declarations, `composedGuards.enables` method is used instead of `warningsGuard.disables`.\n\n**Conclusion:**\nThe implemented fix ensures that the `warningsGuard` is correctly and completely initialized under all circumstances and that the disabling and enabling of DiagnosticGroups are appropriately handled. This prevents the assertion error triggered from an unexpected number of warning messages being produced by the program."
}