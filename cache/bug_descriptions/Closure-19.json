{
    "bug_id": 19,
    "bug_type": "SF",
    "buggy_lines": "",
    "code": "  protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n    switch (node.getType()) {\n      case Token.NAME:\n        scope.inferSlotType(node.getString(), type);\n        break;\n\n      case Token.GETPROP:\n        String qualifiedName = node.getQualifiedName();\n        Preconditions.checkNotNull(qualifiedName);\n\n        JSType origType = node.getJSType();\n        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n        break;\n\n        // \"this\" references aren't currently modeled in the CFG.\n\n      default:\n        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n            node.toStringTree());\n    }\n  }",
    "fixed_code": "  protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n    switch (node.getType()) {\n      case Token.NAME:\n        scope.inferSlotType(node.getString(), type);\n        break;\n\n      case Token.GETPROP:\n        String qualifiedName = node.getQualifiedName();\n        Preconditions.checkNotNull(qualifiedName);\n\n        JSType origType = node.getJSType();\n        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n        break;\n\n      case Token.THIS:\n        // \"this\" references aren't currently modeled in the CFG.\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n            node.toStringTree());\n    }\n  }",
    "fixed_lines": "      case Token.THIS:\n        break;",
    "masked_code": "  protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n    switch (node.getType()) {\n      case Token.NAME:\n        scope.inferSlotType(node.getString(), type);\n        break;\n\n      case Token.GETPROP:\n        String qualifiedName = node.getQualifiedName();\n        Preconditions.checkNotNull(qualifiedName);\n\n        JSType origType = node.getJSType();\n        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n        break;\n\n        // \"this\" references aren't currently modeled in the CFG.\n>>> [ INFILL ] <<<\n\n      default:\n        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n            node.toStringTree());\n    }\n  }",
    "project": "Closure",
    "test_error_message": "java.lang.IllegalArgumentException: Node cannot be refined.",
    "test_framework": "defects4j",
    "test_line": "    dfa.analyze();",
    "test_name": "testNoThisInference",
    "test_suite": "com.google.javascript.jscomp.TypeInferenceTest",
    "time_buggy": "2012-06-27 22:57:05 +0000",
    "time_fixed": "2012-07-03 04:13:14 +0000",
    "bug_description": "Bug ID: 19\nProject: Closure\nBug Type: Semantic Fault (SF)\nSeverity: High\nPriority: Medium\n\nBug Description:\nThe bug is present within the function `declareNameInScope`. Here, the switch-case construct doesn't cover every potential case that could occur, specifically for the case of `Token.THIS`. As a result, if the `node.getType()` returns `Token.THIS`, it falls into the default case and throws an `IllegalArgumentException` with the error message: \"Node cannot be refined.\" \n\nReproduction Steps:\nThe issue arises when the `declareNameInScope` method is called with a node object whose `getType()` method returns a value that isn't covered in the switch-case construct in the original code. Steps to reproduce could be as such:\n1. Instantiate a `Node` object such that calling `getType()` on the object will return a value not covered by the cases in the original switch-case construct, like `Token.THIS`.\n2. Call `declareNameInScope` method with the created `Node` object as one of the arguments.\n3. Observe the `IllegalArgumentException` being thrown with the error message: \"Node cannot be refined.\"\n\nResolution:\nBy adding case `Token.THIS` into the switch-case method and deciding what should occur when `node.getType()` returns `Token.THIS`, the `IllegalArgumentException` no longer occurs. In this particular case, the developers have decided that nothing should occur for `Token.THIS`, hence they've added a break; statement in this case.\n\nModified Code:\nIn the fixed code, case `Token.THIS` has been added to handle this case as follows:\n\n```java\n  case Token.THIS:\n    // \"this\" references aren't currently modeled in the CFG.\n    break;\n```\n\nNow, when `node.getType()` returns `Token.THIS`, it no longer goes to the default case and so the `IllegalArgumentException` is no longer thrown."
}