{
    "bug_id": 33,
    "bug_type": "SL SH SF",
    "buggy_lines": "",
    "code": "    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }\n\n    Element insert(Token.StartTag startTag) {\n        // handle empty unknown tags\n        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\n        insert(el);\n        return el;\n    }",
    "fixed_code": "    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }\n\n    Element insert(Token.StartTag startTag) {\n        // handle empty unknown tags\n        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n            tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\n        insert(el);\n        return el;\n    }",
    "fixed_lines": "            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data",
    "masked_code": "    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }\n\n    Element insert(Token.StartTag startTag) {\n        // handle empty unknown tags\n        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n>>> [ INFILL ] <<<\n            tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\n        insert(el);\n        return el;\n    }",
    "project": "Jsoup",
    "test_error_message": "junit.framework.AssertionFailedError: expected:<...src=\"/foo\"></script>[<div id=\"2\"><img /><img /></div><a id=\"3\"></a><i></i><foo /><foo>One</foo> <hr /> hr text <hr />] hr text two> but was:<...src=\"/foo\"></script>[&lt;div id=2&gt;&lt;img /&gt;&lt;img&gt;&lt;/div&gt;&lt;a id=3 /&gt;&lt;i /&gt;&lt;foo /&gt;&lt;foo&gt;One&lt;/foo&gt; &lt;hr /&gt; hr text &lt;hr&gt;] hr text two>",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(\"<div id=\\\"1\\\"></div><script src=\\\"/foo\\\"></script><div id=\\\"2\\\"><img /><img /></div><a id=\\\"3\\\"></a><i></i><foo /><foo>One</foo> <hr /> hr text <hr /> hr text two\", TextUtil.stripNewlines(doc.body().html()));",
    "test_name": "handlesKnownEmptyBlocks",
    "test_suite": "org.jsoup.parser.HtmlParserTest",
    "time_buggy": "2013-02-16 11:01:36 -0800",
    "time_fixed": "2013-10-06 13:46:11 -0700",
    "bug_description": "Bug ID: 33\nProject: Jsoup\nBug Type: SL SH SF (Scope Language, Scope Hierarchy, Scope Function)\n\n1. The bug is observed in the Jsoup Project, which is a Java library for working with real-world HTML. It provides a very convenient API for extracting and manipulating data, using the best of DOM, CSS, and jquery-like methods.\n\n2. The bug is characterized by a test error message. The expected output is some HTML code containing tags such as script, div, img, a, i, foo and hr. However, the actual output differs as it contains HTML entities in place of the logical symbols < and >. These are special characters often used to incorporate HTML code into the text without the browser interpreting it as actual HTML code. The actual HTML code is not being read as it should be.\n\n3. Upon noting the issue, the buggy lines are identified, they are present in the 'insert' method associated with 'Token.StartTag startTag' in the given code. This code is trying to insert a token that represents an HTML start tag in the HTML document being parsed. If the provided start tag is self-closing, it is attempted to insert an empty tag and a new end tag is emitted. Here lies the error, as this implementation misinterprets the HTML entities, causing the difference between the expected and received output.\n\n4. Notably, the function works correctly for inserting non-self-closing tags into the HTML document as another method is called to achieve this, which is working correctly according to the received output.\n\n5. Referring to the fixed code, it can be seen the solution involves adding the line \"tokeniser.transition(TokeniserState.Data);\" under the condition of if \"startTag.isSelfClosing()\". This modification indicates that the tokeniser should transition to the state where it is treating the input as data, not as HTML code.\n\n6. With this change in state, the code correctly identifies \"<\" and \">\" symbols as HTML tags and not HTML entities. Thus, they are not translated into the corresponding HTML entities in the output, which resolves the issue and the tests should now pass as expected.\n\nIn summary, this bug arises from not correctly identifying self-closing tags in the HTML input and handling them as actual HTML code. This was resolved by adding a state transition for the tokeniser to correctly handle these situations. The corrected function now delivers the expected output, resolving the bug."
}