{
    "bug_id": 40,
    "bug_type": "SH SF",
    "buggy_lines": "        return contains(str.toUpperCase(), searchStr.toUpperCase());",
    "code": "    public static boolean containsIgnoreCase(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return false;\n        }\n        return contains(str.toUpperCase(), searchStr.toUpperCase());\n    }",
    "fixed_code": "    public static boolean containsIgnoreCase(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return false;\n        }\n        int len = searchStr.length();\n        int max = str.length() - len;\n        for (int i = 0; i <= max; i++) {\n            if (str.regionMatches(true, i, searchStr, 0, len)) {\n                return true;\n            }\n        }\n        return false;\n    }",
    "fixed_lines": "        int len = searchStr.length();\n        int max = str.length() - len;\n        for (int i = 0; i <= max; i++) {\n            if (str.regionMatches(true, i, searchStr, 0, len)) {\n                return true;\n            }\n        }\n        return false;",
    "masked_code": "    public static boolean containsIgnoreCase(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return false;\n        }\n>>> [ INFILL ] <<<\n    }",
    "project": "Lang",
    "test_error_message": "junit.framework.AssertionFailedError: en: 0 \u00df SS",
    "test_framework": "defects4j",
    "test_line": "                    assertFalse(Locale.getDefault() + \": \" + j + \" \" + fdata[j][0] + \" \" + fdata[j][1], StringUtils",
    "test_name": "testContainsIgnoreCase_LocaleIndependence",
    "test_suite": "org.apache.commons.lang.StringUtilsEqualsIndexOfTest",
    "time_buggy": "2009-10-22 05:33:21 +0000",
    "time_fixed": "2009-10-22 05:46:33 +0000",
    "bug_description": "Bug ID: 40\nProject: Lang\nBug Type: Syntax highlighting and Formatting issue (SH SF)\nSeverity: Medium\nPriority: Medium\nAssignee: TBD\nReported by: TBD\nState: Open\nEnvironment: TBD\nDescription:\n\nThe function 'containsIgnoreCase' is meant to check if 'searchStr' exists in 'str' in a case-insensitive manner. If either of the strings are null, it returns 'false'. Otherwise, it converts both strings to uppercase using 'toUpperCase()' method and then checks if 'str' contains 'searchStr'.\n\nWhile converting the strings to upper case, special accented characters like '\u00df' are mishandled. For eg., In German, '\u00df' when converted to upper case should become 'SS'. Hence, 'en: 0 \u00df SS' should return true when checked as 'containsIgnoreCase(\"en: 0 \u00df\", \"SS\")'. However, in the buggy version, it returns 'false'. This is confirmed by the test error message - junit.framework.AssertionFailedError: en: 0 \u00df SS.\n\nSteps to reproduce:\n\n1. Call the function 'containsIgnoreCase' with 'str' and 'searchStr', where 'str' contains special characters like '\u00df' and 'searchStr' is the uppercase version of that special character.\n2. Example - 'containsIgnoreCase(\"en: 0 \u00df\", \"SS\")'. Expected result is 'true' as '\u00df' should be converted to 'SS' in upper case. But the actual result is 'false'.\n\nRoot Cause:\n\nThe root cause of this error is that the 'toUpperCase()' method does not correctly handle some specific special characters. While 'toLowerCase()' correctly computes 'SS' to '\u00df' in German, 'toUpperCase()' does not compute '\u00df' to 'SS'.\n\nResolution:\n\nThe problem was solved by avoiding the 'toUpperCase()' method. The fixed code uses 'regionMatches()' method instead, which compares a specific region of the string (i.e. 'searchStr') with another region in 'str'. The first argument of this method, 'true', enables case-insensitive comparison. Therefore, this method works correctly for special characters like '\u00df'.\n\nThe fixed code also optimizes the search by only checking the substrings of 'str' that have the same length as 'searchStr'. This is done by iterating i over the range [0, max], where max is the difference in lengths between 'str' and 'searchStr'. This way, the function is more efficient, avoiding unnecessary checking of substrings that cannot possibly match 'searchStr'."
}