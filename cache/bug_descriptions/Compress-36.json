{
    "bug_id": 36,
    "bug_type": "SH SF",
    "buggy_lines": "",
    "code": "    private InputStream getCurrentStream() throws IOException {\n        if (deferredBlockStreams.isEmpty()) {\n            throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n        }\n        \n        while (deferredBlockStreams.size() > 1) {\n            // In solid compression mode we need to decompress all leading folder'\n            // streams to get access to an entry. We defer this until really needed\n            // so that entire blocks can be skipped without wasting time for decompression.\n            final InputStream stream = deferredBlockStreams.remove(0);\n            IOUtils.skip(stream, Long.MAX_VALUE);\n            stream.close();\n        }\n\n        return deferredBlockStreams.get(0);\n    }",
    "fixed_code": "    private InputStream getCurrentStream() throws IOException {\n        if (archive.files[currentEntryIndex].getSize() == 0) {\n            return new ByteArrayInputStream(new byte[0]);\n        }\n        if (deferredBlockStreams.isEmpty()) {\n            throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n        }\n        \n        while (deferredBlockStreams.size() > 1) {\n            // In solid compression mode we need to decompress all leading folder'\n            // streams to get access to an entry. We defer this until really needed\n            // so that entire blocks can be skipped without wasting time for decompression.\n            final InputStream stream = deferredBlockStreams.remove(0);\n            IOUtils.skip(stream, Long.MAX_VALUE);\n            stream.close();\n        }\n\n        return deferredBlockStreams.get(0);\n    }",
    "fixed_lines": "        if (archive.files[currentEntryIndex].getSize() == 0) {\n            return new ByteArrayInputStream(new byte[0]);\n        }",
    "masked_code": "    private InputStream getCurrentStream() throws IOException {\n>>> [ INFILL ] <<<\n        if (deferredBlockStreams.isEmpty()) {\n            throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n        }\n        \n        while (deferredBlockStreams.size() > 1) {\n            // In solid compression mode we need to decompress all leading folder'\n            // streams to get access to an entry. We defer this until really needed\n            // so that entire blocks can be skipped without wasting time for decompression.\n            final InputStream stream = deferredBlockStreams.remove(0);\n            IOUtils.skip(stream, Long.MAX_VALUE);\n            stream.close();\n        }\n\n        return deferredBlockStreams.get(0);\n    }",
    "project": "Compress",
    "test_error_message": "java.lang.IllegalStateException: No current 7z entry (call getNextEntry() first).",
    "test_framework": "defects4j",
    "test_line": "                int b = sevenZFile.read();",
    "test_name": "readEntriesOfSize0",
    "test_suite": "org.apache.commons.compress.archivers.sevenz.SevenZFileTest",
    "time_buggy": "2016-04-19 00:10:43 +0100",
    "time_fixed": "2016-04-24 13:22:34 +0200",
    "bug_description": "Bug ID: 36\nProject Name: Compress\nBug Type: SH SF \n\nBug Description: \nThe bug is related to the handling of 7z entries in the code. An IllegalStateException is thrown if the 'getCurrentStream()' method is called and there are no items in the 'deferredBlockStreams' list.\n\nSteps to Reproduce:\n1. Execute a code that uses the 'getCurrentStream()' method from an instance where 'deferredBlockStreams.isEmpty()' returns true.\n2. An IllegalStateException is thrown with a message \"No current 7z entry (call getNextEntry() first)\" meaning that there are no current 7z entries. \n3. The code breaks at this point where it's expecting an entry and none is available.\n\nProblematic Part of Original Code:\n\nThe issue is in the 'getCurrentStream' method when it checks if the 'deferredBlockStreams' is empty before continuing to the following code. If 'deferredBlockStreams' is empty, a new IllegalStateException is thrown, without actually checking if the requested entry is empty or not, resulting in an incorrect state. \n\n````\nprivate InputStream getCurrentStream() throws IOException {\n        if (deferredBlockStreams.isEmpty()) {\n            throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n        }\n\n        // Remaining part of the method\n    }\n```\n\nSolution Implemented:\n\nA check has been added before throwing an IllegalStateException in the 'getCurrentStream' method to see if the requested entry is empty. If the size of the requested file is 0, it returns a new empty InputStream. This solution better handles zero-sized files.\n\n````\nprivate InputStream getCurrentStream() throws IOException {\n        if (archive.files[currentEntryIndex].getSize() == 0) {\n            return new ByteArrayInputStream(new byte[0]);\n        }\n        if (deferredBlockStreams.isEmpty()) {\n            throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n        }\n\n        // Remaining part of the method\n    }\n````\n\nThis bug report should provide a clear understanding of the issue for developers who want to generate artificial java bugs. They can simply omit the added check that handles zero-sized files, in order to recreate the original issue."
}