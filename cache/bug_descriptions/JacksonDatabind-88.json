{
    "bug_id": 88,
    "bug_type": "SF",
    "buggy_lines": "",
    "code": "    protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n    {\n        /* 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n         *    check if any generics info is added; and only then ask factory\n         *    to do translation when necessary\n         */\n        TypeFactory tf = ctxt.getTypeFactory();\n        if (id.indexOf('<') > 0) {\n            // note: may want to try combining with specialization (esp for EnumMap)?\n            // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n            //    compatibility -- needed later anyway, and not doing so may open\n            //    security issues.\n            JavaType t = tf.constructFromCanonical(id);\n                // Probably cleaner to have a method in `TypeFactory` but can't add in patch\n            return t;\n        }\n        Class<?> cls;\n        try {\n            cls =  tf.findClass(id);\n        } catch (ClassNotFoundException e) {\n            // 24-May-2016, tatu: Ok, this is pretty ugly, but we should always get\n            //   DeserializationContext, just playing it safe\n            if (ctxt instanceof DeserializationContext) {\n                DeserializationContext dctxt = (DeserializationContext) ctxt;\n                // First: we may have problem handlers that can deal with it?\n                return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n            }\n            // ... meaning that we really should never get here.\n            return null;\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n        }\n        return tf.constructSpecializedType(_baseType, cls);\n    }",
    "fixed_code": "    protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n    {\n        /* 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n         *    check if any generics info is added; and only then ask factory\n         *    to do translation when necessary\n         */\n        TypeFactory tf = ctxt.getTypeFactory();\n        if (id.indexOf('<') > 0) {\n            // note: may want to try combining with specialization (esp for EnumMap)?\n            // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n            //    compatibility -- needed later anyway, and not doing so may open\n            //    security issues.\n            JavaType t = tf.constructFromCanonical(id);\n            if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n                // Probably cleaner to have a method in `TypeFactory` but can't add in patch\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", t.getRawClass().getName(), _baseType));\n            }\n            return t;\n        }\n        Class<?> cls;\n        try {\n            cls =  tf.findClass(id);\n        } catch (ClassNotFoundException e) {\n            // 24-May-2016, tatu: Ok, this is pretty ugly, but we should always get\n            //   DeserializationContext, just playing it safe\n            if (ctxt instanceof DeserializationContext) {\n                DeserializationContext dctxt = (DeserializationContext) ctxt;\n                // First: we may have problem handlers that can deal with it?\n                return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n            }\n            // ... meaning that we really should never get here.\n            return null;\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n        }\n        return tf.constructSpecializedType(_baseType, cls);\n    }",
    "fixed_lines": "            if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", t.getRawClass().getName(), _baseType));\n            }",
    "masked_code": "    protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n    {\n        /* 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n         *    check if any generics info is added; and only then ask factory\n         *    to do translation when necessary\n         */\n        TypeFactory tf = ctxt.getTypeFactory();\n        if (id.indexOf('<') > 0) {\n            // note: may want to try combining with specialization (esp for EnumMap)?\n            // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n            //    compatibility -- needed later anyway, and not doing so may open\n            //    security issues.\n            JavaType t = tf.constructFromCanonical(id);\n                // Probably cleaner to have a method in `TypeFactory` but can't add in patch\n>>> [ INFILL ] <<<\n            return t;\n        }\n        Class<?> cls;\n        try {\n            cls =  tf.findClass(id);\n        } catch (ClassNotFoundException e) {\n            // 24-May-2016, tatu: Ok, this is pretty ugly, but we should always get\n            //   DeserializationContext, just playing it safe\n            if (ctxt instanceof DeserializationContext) {\n                DeserializationContext dctxt = (DeserializationContext) ctxt;\n                // First: we may have problem handlers that can deal with it?\n                return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n            }\n            // ... meaning that we really should never get here.\n            return null;\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n        }\n        return tf.constructSpecializedType(_baseType, cls);\n    }",
    "project": "JacksonDatabind",
    "test_error_message": "junit.framework.AssertionFailedError: Expected an exception with one of substrings ([not subtype of]): got one (of type com.fasterxml.jackson.databind.JsonMappingException) with message \"Problem deserializing property 'w' (expected type: [simple type, class com.fasterxml.jackson.databind.jsontype.GenericTypeId1735Test$Payload1735]; actual type: java.util.HashMap), problem: Can not set com.fasterxml.jackson.databind.jsontype.GenericTypeId1735Test$Payload1735 field com.fasterxml.jackson.databind.jsontype.GenericTypeId1735Test$Wrapper1735.w to java.util.HashMap",
    "test_framework": "defects4j",
    "test_line": "",
    "test_name": "testNestedTypeCheck1735",
    "test_suite": "com.fasterxml.jackson.databind.jsontype.GenericTypeId1735Test",
    "time_buggy": "2017-07-26 16:10:35 -0700",
    "time_fixed": "2017-08-17 13:43:37 -0700",
    "bug_description": "Bug ID: 88\nProject: JacksonDatabind\nError type: Security/ Functionality (SF)\nTest error message: junit.framework.AssertionFailedError\n\n\n    Step-by-step bug detail:\n\n    1. The bug is located in the \"_typeFromId\" method in the JacksonDatabind project.\n\n    2. This method is responsible for creating a JavaType from an input string ID, which is used for data binding purposes. It uses a TypeFactory instance for creating these JavaTypes.\n\n    3. If the ID provided contains '<', then a JavaType is constructed from the canonical form of this ID.\n\n    4. However, the bug arises when the constructed type is not a subtype of the base type (_baseType). The current implementation does not handle this discrepancy.\n\n    5. Instead the code continues processing, leading to unexpected behavior. This is particularly manifested when deserializing properties, as detailed in the error message.\n\n    6. As such, the test fails with a junit.framework.AssertionFailedError specifically noting that an expected exception was not thrown and providing the detail about the incompatibility between the expected class (`com.fasterxml.jackson.databind.jsontype.GenericTypeId1735Test$Payload1735`) and the actual class obtained (`java.util.HashMap`).\n\n    In order to fix this bug, a check needs to be added to ensure the compatibility between the constructed type and the base type. If the constructed type is not a subtype of the base type, an \"IllegalArgumentException\" should be thrown with appropriate message information. This prevents the wrong class type assignment that led to the failed test case and shields against potential security issues.\n\n    This fix is applied in the fixed code provided, by introducing a conditional check with \n    `t.isTypeOrSubTypeOf(_baseType.getRawClass())` and throwing a new IllegalArgumentException if the check fails."
}