{
    "bug_id": 31,
    "bug_type": "SF",
    "buggy_lines": "            dPrev = q1;\n            cPrev = cN / q2;\n            p0 = hPrev;\n            hPrev = cN;\n            q1 = q2;",
    "code": "    public double evaluate(double x, double epsilon, int maxIterations) {\n        final double small = 1e-50;\n        double hPrev = getA(0, x);\n\n        // use the value of small as epsilon criteria for zero checks\n        if (Precision.equals(hPrev, 0.0, small)) {\n            hPrev = small;\n        }\n\n        int n = 1;\n        double dPrev = 0.0;\n        double p0 = 1.0;\n        double q1 = 1.0;\n        double cPrev = hPrev;\n        double hN = hPrev;\n\n        while (n < maxIterations) {\n            final double a = getA(n, x);\n            final double b = getB(n, x);\n\n            double cN = a * hPrev + b * p0;\n            double q2 = a * q1 + b * dPrev;\n            if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n                double scaleFactor = 1d;\n                double lastScaleFactor = 1d;\n                final int maxPower = 5;\n                final double scale = FastMath.max(a,b);\n                if (scale <= 0) {  // Can't scale\n                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n                }\n                for (int i = 0; i < maxPower; i++) {\n                    lastScaleFactor = scaleFactor;\n                    scaleFactor *= scale;\n                    if (a != 0.0 && a > b) {\n                        cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                        q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                    } else if (b != 0) {\n                        cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                        q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                    }\n                    if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                        break;\n                    }\n                }\n            }\n\n            final double deltaN = cN / q2 / cPrev;\n            hN = cPrev * deltaN;\n\n            if (Double.isInfinite(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                                               x);\n            }\n            if (Double.isNaN(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                                               x);\n            }\n\n            if (FastMath.abs(deltaN - 1.0) < epsilon) {\n                break;\n            }\n\n            dPrev = q1;\n            cPrev = cN / q2;\n            p0 = hPrev;\n            hPrev = cN;\n            q1 = q2;\n            n++;\n        }\n\n        if (n >= maxIterations) {\n            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                                maxIterations, x);\n        }\n\n        return hN;\n    }",
    "fixed_code": "    public double evaluate(double x, double epsilon, int maxIterations) {\n        final double small = 1e-50;\n        double hPrev = getA(0, x);\n\n        // use the value of small as epsilon criteria for zero checks\n        if (Precision.equals(hPrev, 0.0, small)) {\n            hPrev = small;\n        }\n\n        int n = 1;\n        double dPrev = 0.0;\n        double cPrev = hPrev;\n        double hN = hPrev;\n\n        while (n < maxIterations) {\n            final double a = getA(n, x);\n            final double b = getB(n, x);\n\n            double dN = a + b * dPrev;\n            if (Precision.equals(dN, 0.0, small)) {\n                dN = small;\n            }\n            double cN = a + b / cPrev;\n            if (Precision.equals(cN, 0.0, small)) {\n                cN = small;\n            }\n\n            dN = 1 / dN;\n            final double deltaN = cN * dN;\n            hN = hPrev * deltaN;\n\n            if (Double.isInfinite(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                                               x);\n            }\n            if (Double.isNaN(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                                               x);\n            }\n\n            if (FastMath.abs(deltaN - 1.0) < epsilon) {\n                break;\n            }\n\n            dPrev = dN;\n            cPrev = cN;\n            hPrev = hN;\n            n++;\n        }\n\n        if (n >= maxIterations) {\n            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                                maxIterations, x);\n        }\n\n        return hN;\n    }",
    "fixed_lines": "            dPrev = dN;\n            cPrev = cN;\n            hPrev = hN;",
    "masked_code": "    public double evaluate(double x, double epsilon, int maxIterations) {\n        final double small = 1e-50;\n        double hPrev = getA(0, x);\n\n        // use the value of small as epsilon criteria for zero checks\n        if (Precision.equals(hPrev, 0.0, small)) {\n            hPrev = small;\n        }\n\n        int n = 1;\n        double dPrev = 0.0;\n        double cPrev = hPrev;\n        double hN = hPrev;\n\n        while (n < maxIterations) {\n            final double a = getA(n, x);\n            final double b = getB(n, x);\n\n            }\n\n\n            if (Double.isInfinite(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                                               x);\n            }\n            if (Double.isNaN(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                                               x);\n            }\n\n            if (FastMath.abs(deltaN - 1.0) < epsilon) {\n                break;\n            }\n\n>>> [ INFILL ] <<<\n            n++;\n        }\n\n        if (n >= maxIterations) {\n            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                                maxIterations, x);\n        }\n\n        return hN;\n    }",
    "project": "Math",
    "test_error_message": "org.apache.commons.math3.exception.ConvergenceException: illegal state: Continued fraction diverged to NaN for value 0.5",
    "test_framework": "defects4j",
    "test_line": "            int p = dist.inverseCumulativeProbability(0.5);",
    "test_name": "testMath718",
    "test_suite": "org.apache.commons.math3.distribution.BinomialDistributionTest",
    "time_buggy": "2012-05-16 05:36:40 +0000",
    "time_fixed": "2012-05-21 19:55:30 +0000",
    "bug_description": "Bug ID: 31\nProject: Math Library\nBug Type: Calculation Error (SF)\n\nDescription:\n\nThe project encountered a ConvergenceException error when evaluating a continued fraction for the value 0.5. The problematic function was found in the 'evaluate' method, specifically during the 'while' loop that calculates the fraction value to a certain level of precision or maximum iterations.\n\nThe issue was found to be tied to the way variables 'cN', 'q2', 'hN', and 'dN' were calculated in the middle of the 'while' loop. The error message suggests that there was a divergence to NaN at some iteration, which led to the exception. \n\nThe specific buggy lines are: \n```java\n    dPrev = q1;\n    cPrev = cN / q2;\n    p0 = hPrev;\n    hPrev = cN;\n    q1 = q2;\n```\n\nDetails:\n1. At first glance, the function seems alright, with initialization values set properly. \n2. However, within the 'while' loop, when a Non-Arithmetic number (NaN) value is encountered, the program throws a ConvergenceException.\n3. This happens due to the lines of code where the variables 'cN' and 'q2' are calculated with the potentially infinite results.\n4. Also, the variables 'dPrev', 'cPrev', 'p0', 'hPrev' and 'q1' are then loaded with these incorrect values, which then propagates the same issue to the next iterations and causing the fraction to diverge to NaN.\n\nSolution:\n\nThe solution involves changing the way 'dN', 'cN', 'dPrev', 'cPrev', and 'hN' are calculated inside the loop. The 'dN' and 'cN' calculations were changed to avoid potential Infinity or NaN values. Proper checks were also introduced before performing division operations. The modifications resolved the issue, as follows:\n\n```java\n    double dN = a + b * dPrev;\n    if (Precision.equals(dN, 0.0, small)) {\n        dN = small;\n    }\n    double cN = a + b / cPrev;\n    if (Precision.equals(cN, 0.0, small)) {\n        cN = small;\n    }\n\n    dN = 1 / dN;\n    final double deltaN = cN * dN;\n    hN = hPrev * deltaN;\n    dPrev = dN;\n    cPrev = cN;\n    hPrev = hN;\n```"
}