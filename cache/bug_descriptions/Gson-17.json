{
    "bug_id": 17,
    "bug_type": "SH SF",
    "buggy_lines": "    if (in.peek() != JsonToken.STRING) {\n      throw new JsonParseException(\"The date should be a string value\");",
    "code": "  public Date read(JsonReader in) throws IOException {\n    if (in.peek() != JsonToken.STRING) {\n      throw new JsonParseException(\"The date should be a string value\");\n    }\n    Date date = deserializeToDate(in.nextString());\n    if (dateType == Date.class) {\n      return date;\n    } else if (dateType == Timestamp.class) {\n      return new Timestamp(date.getTime());\n    } else if (dateType == java.sql.Date.class) {\n      return new java.sql.Date(date.getTime());\n    } else {\n      // This must never happen: dateType is guarded in the primary constructor\n      throw new AssertionError();\n    }\n  }",
    "fixed_code": "  public Date read(JsonReader in) throws IOException {\n    if (in.peek() == JsonToken.NULL) {\n      in.nextNull();\n      return null;\n    }\n    Date date = deserializeToDate(in.nextString());\n    if (dateType == Date.class) {\n      return date;\n    } else if (dateType == Timestamp.class) {\n      return new Timestamp(date.getTime());\n    } else if (dateType == java.sql.Date.class) {\n      return new java.sql.Date(date.getTime());\n    } else {\n      // This must never happen: dateType is guarded in the primary constructor\n      throw new AssertionError();\n    }\n  }",
    "fixed_lines": "    if (in.peek() == JsonToken.NULL) {\n      in.nextNull();\n      return null;",
    "masked_code": "  public Date read(JsonReader in) throws IOException {\n>>> [ INFILL ] <<<\n    }\n    Date date = deserializeToDate(in.nextString());\n    if (dateType == Date.class) {\n      return date;\n    } else if (dateType == Timestamp.class) {\n      return new Timestamp(date.getTime());\n    } else if (dateType == java.sql.Date.class) {\n      return new java.sql.Date(date.getTime());\n    } else {\n      // This must never happen: dateType is guarded in the primary constructor\n      throw new AssertionError();\n    }\n  }",
    "project": "Gson",
    "test_error_message": "com.google.gson.JsonParseException: The date should be a string value",
    "test_framework": "defects4j",
    "test_line": "      adapter.fromJson(\"{}\");",
    "test_name": "testUnexpectedToken",
    "test_suite": "com.google.gson.DefaultDateTypeAdapterTest",
    "time_buggy": "2017-09-17 23:46:52 -0700",
    "time_fixed": "2017-09-17 23:49:13 -0700",
    "bug_description": "Bug Description:\n\nTitle: JSON Date Parsing Error when Non-string Value Provided \n\nOverview:\n\nBug ID 17, detected in the Gson project, is of the \"SH SF\" type and was causing a JsonParseException. The bug is associated with reading the date from a Json object, specifically when the data is not a string value. \n\nSteps to Reproduce:\n\n1. When trying to read a Json object using the public method \"read(JsonReader in)\".\n2. If the JSON input doesn't contain a string value for the date field, the issue occurs.\n3. Such non-string value in the date field triggers the conditional clause \"if (in.peek() != JsonToken.STRING)\", causing the method to throw a JsonParseException with the following message: \"The date should be a string value\".\n\nRoot Cause Analysis: \n\nThe root cause of the problem is the parser's expectation of string values for dates within the JSON input. If it encounters a non-string value (like null), it throws a JsonParseException rather than handling this case gracefully. \n\nCorrective and Preventative Measures:\n\nThe fixed code replaces the condition that only accepted string values for the date, making it more robust and able to handle null values. This is done by checking if the value of the date is null and then executing the \"in.nextNull()\" statement. If it is not null, the date is read and converted via the \"deserializeToDate(in.nextString())\" method. The rest of the code continues as normal, since it is already designed to support multiple date formats, such as Date, Timestamp, and java.sql.Date. This not only corrects the issue but also prevents JsonParseException from arising due to null dates or non-string date values in the future."
}