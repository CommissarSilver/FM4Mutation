{
    "bug_id": 96,
    "bug_type": "SL SH SF",
    "buggy_lines": "            paramName = candidate.findImplicitParamName(0);",
    "code": "    protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        // Looks like there's bit of magic regarding 1-parameter creators; others simpler:\n        if (1 != candidate.paramCount()) {\n            // Ok: for delegates, we want one and exactly one parameter without\n            // injection AND without name\n            int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n            if (oneNotInjected >= 0) {\n                // getting close; but most not have name\n                if (candidate.paramName(oneNotInjected) == null) {\n                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                    return;\n                }\n            }\n            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n            return;\n        }\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n        // If there's injection or explicit name, should be properties-based\n        boolean useProps = (paramName != null) || (injectId != null);\n        if (!useProps && (paramDef != null)) {\n            // One more thing: if implicit name matches property with a getter\n            // or field, we'll consider it property-based as well\n\n            // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n            //    not implicit name, but name with possible strategy-based-rename\n//            paramName = candidate.findImplicitParamName(0);\n            paramName = candidate.findImplicitParamName(0);\n            useProps = (paramName != null) && paramDef.couldSerialize();\n        }\n        if (useProps) {\n            SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n            };\n            creators.addPropertyCreator(candidate.creator(), true, properties);\n            return;\n        }\n        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n        // one more thing: sever link to creator property, to avoid possible later\n        // problems with \"unresolved\" constructor property\n        if (paramDef != null) {\n            ((POJOPropertyBuilder) paramDef).removeConstructors();\n        }\n    }",
    "fixed_code": "    protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        // Looks like there's bit of magic regarding 1-parameter creators; others simpler:\n        if (1 != candidate.paramCount()) {\n            // Ok: for delegates, we want one and exactly one parameter without\n            // injection AND without name\n            int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n            if (oneNotInjected >= 0) {\n                // getting close; but most not have name\n                if (candidate.paramName(oneNotInjected) == null) {\n                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                    return;\n                }\n            }\n            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n            return;\n        }\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n        // If there's injection or explicit name, should be properties-based\n        boolean useProps = (paramName != null) || (injectId != null);\n        if (!useProps && (paramDef != null)) {\n            // One more thing: if implicit name matches property with a getter\n            // or field, we'll consider it property-based as well\n\n            // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n            //    not implicit name, but name with possible strategy-based-rename\n//            paramName = candidate.findImplicitParamName(0);\n            paramName = candidate.paramName(0);\n            useProps = (paramName != null) && paramDef.couldSerialize();\n        }\n        if (useProps) {\n            SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n            };\n            creators.addPropertyCreator(candidate.creator(), true, properties);\n            return;\n        }\n        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n        // one more thing: sever link to creator property, to avoid possible later\n        // problems with \"unresolved\" constructor property\n        if (paramDef != null) {\n            ((POJOPropertyBuilder) paramDef).removeConstructors();\n        }\n    }",
    "fixed_lines": "            paramName = candidate.paramName(0);",
    "masked_code": "    protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        // Looks like there's bit of magic regarding 1-parameter creators; others simpler:\n        if (1 != candidate.paramCount()) {\n            // Ok: for delegates, we want one and exactly one parameter without\n            // injection AND without name\n            int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n            if (oneNotInjected >= 0) {\n                // getting close; but most not have name\n                if (candidate.paramName(oneNotInjected) == null) {\n                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                    return;\n                }\n            }\n            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n            return;\n        }\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n        // If there's injection or explicit name, should be properties-based\n        boolean useProps = (paramName != null) || (injectId != null);\n        if (!useProps && (paramDef != null)) {\n            // One more thing: if implicit name matches property with a getter\n            // or field, we'll consider it property-based as well\n\n            // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n            //    not implicit name, but name with possible strategy-based-rename\n//            paramName = candidate.findImplicitParamName(0);\n>>> [ INFILL ] <<<\n            useProps = (paramName != null) && paramDef.couldSerialize();\n        }\n        if (useProps) {\n            SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n            };\n            creators.addPropertyCreator(candidate.creator(), true, properties);\n            return;\n        }\n        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n        // one more thing: sever link to creator property, to avoid possible later\n        // problems with \"unresolved\" constructor property\n        if (paramDef != null) {\n            ((POJOPropertyBuilder) paramDef).removeConstructors();\n        }\n    }",
    "project": "JacksonDatabind",
    "test_error_message": "junit.framework.AssertionFailedError: expected not same",
    "test_framework": "defects4j",
    "test_line": "        assertNotSame(w, newW);",
    "test_name": "testViewSettings",
    "test_suite": "com.fasterxml.jackson.databind.ObjectWriterTest",
    "time_buggy": "2018-05-24 12:59:44 -0700",
    "time_fixed": "2018-05-25 15:46:15 -0700",
    "bug_description": "Bug Description:\n\nProject: JacksonDatabind\nBug ID: 96\nBug Type: SL SH SF \nTest Error: junit.framework.AssertionFailedError: expected not same\n\nBug Description:\nThe bug was originated in the '_addExplicitAnyCreator' method within this class. This method handles the extraction of parameters from a 'CreatorCandidate' object, and it is responsible for handling specific cases concerning argument naming and injection, amongst other things. The bug specifically arose in a block of code where it was determining whether a parameter should be considered property-based.\n\nStep-by-step Bug Replication:\n\n1. This method first checks if there's only one parameter; if the 'paramCount' from the 'CandidateCreator' object isn't one, then it goes into the handling of cases where there might be delegate parameters or property creators.\n\n2. If there is only one parameter in the 'CandidateCreator', the parameter object and several variables are extracted from the 'CandidateCreator' - namely 'paramName', 'injectId' and 'paramDef'.\n\n3. Then the method checks if it should be using properties for the parameter - i.e. if 'paramName' or the 'injectId' is not null. If these are null and 'paramDef' not, then there is a bug in the code. In this section of the code, in addition to checking the above, we need also to confirm if the implicit parameter name matches any property with a getter or a field, then it should be considered property-based.\n\n4. The bug lies in this block of code and is related to how a new value for 'paramName' was being defined. The previous version of the method was using the 'findImplicitParamName()' method from the 'CandidateCreator' class to find the parameter name, and this was incorrect, resulting in a likeliness where the getter or the field property having no match since the implicit parameter name does not generally conform to the original name.\n\nBug Fix:\n\nThe fix was straightforward in this case - instead of seeking the implicit name, the corrected version simply retrieves the explicit name of the parameter by calling the 'paramName()' method from the 'CreatorCandidate'.\n\nOnce the accurate 'paramName' has been retrieved, it is used to set 'useProps' to true if 'paramName' is not null and 'paramDef' could with capability serialize. Consequently, the rest of the function can execute correctly using the accurate parameter name."
}