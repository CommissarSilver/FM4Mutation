{
    "bug_id": 96,
    "bug_type": "SF",
    "buggy_lines": "           parameters.hasNext()) {",
    "code": "  private void visitParameterList(NodeTraversal t, Node call,\n      FunctionType functionType) {\n    Iterator<Node> arguments = call.children().iterator();\n    arguments.next(); // skip the function name\n\n    Iterator<Node> parameters = functionType.getParameters().iterator();\n    int ordinal = 0;\n    Node parameter = null;\n    Node argument = null;\n    while (arguments.hasNext() &&\n           parameters.hasNext()) {\n      // If there are no parameters left in the list, then the while loop\n      // above implies that this must be a var_args function.\n        parameter = parameters.next();\n      argument = arguments.next();\n      ordinal++;\n\n      validator.expectArgumentMatchesParameter(t, argument,\n          getJSType(argument), getJSType(parameter), call, ordinal);\n    }\n\n    int numArgs = call.getChildCount() - 1;\n    int minArgs = functionType.getMinArguments();\n    int maxArgs = functionType.getMaxArguments();\n    if (minArgs > numArgs || maxArgs < numArgs) {\n      report(t, call, WRONG_ARGUMENT_COUNT,\n              validator.getReadableJSTypeName(call.getFirstChild(), false),\n              String.valueOf(numArgs), String.valueOf(minArgs),\n              maxArgs != Integer.MAX_VALUE ?\n              \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n    }\n  }",
    "fixed_code": "  private void visitParameterList(NodeTraversal t, Node call,\n      FunctionType functionType) {\n    Iterator<Node> arguments = call.children().iterator();\n    arguments.next(); // skip the function name\n\n    Iterator<Node> parameters = functionType.getParameters().iterator();\n    int ordinal = 0;\n    Node parameter = null;\n    Node argument = null;\n    while (arguments.hasNext() &&\n           (parameters.hasNext() ||\n            parameter != null && parameter.isVarArgs())) {\n      // If there are no parameters left in the list, then the while loop\n      // above implies that this must be a var_args function.\n      if (parameters.hasNext()) {\n        parameter = parameters.next();\n      }\n      argument = arguments.next();\n      ordinal++;\n\n      validator.expectArgumentMatchesParameter(t, argument,\n          getJSType(argument), getJSType(parameter), call, ordinal);\n    }\n\n    int numArgs = call.getChildCount() - 1;\n    int minArgs = functionType.getMinArguments();\n    int maxArgs = functionType.getMaxArguments();\n    if (minArgs > numArgs || maxArgs < numArgs) {\n      report(t, call, WRONG_ARGUMENT_COUNT,\n              validator.getReadableJSTypeName(call.getFirstChild(), false),\n              String.valueOf(numArgs), String.valueOf(minArgs),\n              maxArgs != Integer.MAX_VALUE ?\n              \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n    }\n  }",
    "fixed_lines": "           (parameters.hasNext() ||\n            parameter != null && parameter.isVarArgs())) {\n      if (parameters.hasNext()) {\n      }",
    "masked_code": "  private void visitParameterList(NodeTraversal t, Node call,\n      FunctionType functionType) {\n    Iterator<Node> arguments = call.children().iterator();\n    arguments.next(); // skip the function name\n\n    Iterator<Node> parameters = functionType.getParameters().iterator();\n    int ordinal = 0;\n    Node parameter = null;\n    Node argument = null;\n    while (arguments.hasNext() &&\n      // If there are no parameters left in the list, then the while loop\n      // above implies that this must be a var_args function.\n        parameter = parameters.next();\n>>> [ INFILL ] <<<\n      argument = arguments.next();\n      ordinal++;\n\n      validator.expectArgumentMatchesParameter(t, argument,\n          getJSType(argument), getJSType(parameter), call, ordinal);\n    }\n\n    int numArgs = call.getChildCount() - 1;\n    int minArgs = functionType.getMinArguments();\n    int maxArgs = functionType.getMaxArguments();\n    if (minArgs > numArgs || maxArgs < numArgs) {\n      report(t, call, WRONG_ARGUMENT_COUNT,\n              validator.getReadableJSTypeName(call.getFirstChild(), false),\n              String.valueOf(numArgs), String.valueOf(minArgs),\n              maxArgs != Integer.MAX_VALUE ?\n              \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n    }\n  }",
    "project": "Closure",
    "test_error_message": "junit.framework.AssertionFailedError: expected a warning",
    "test_framework": "defects4j",
    "test_line": "      assertTrue(\"expected a warning\", warnings.length > 0);",
    "test_name": "testFunctionArguments16",
    "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
    "time_buggy": "2010-09-01 14:18:54 +0000",
    "time_fixed": "2010-09-02 16:49:07 +0000",
    "bug_description": "Bug ID: 96\nProject: Closure\nBug Type: Semantic Fault (SF)\nTest Error Message: junit.framework.AssertionFailedError: expected a warning\n\nDescription:\n\nThe bug is found in the project 'Closure'. It is a semantic fault, meaning there is an issue with the program logic. The test error message indicates that during unit testing, an AssertionFailedError was thrown by Junit, more specifically the test was expecting a warning.\n\nThe issue is located in the visitParameterList function of an unidentified class. The method visitParameterList is defined to visit the parameter list of a FunctionType and perform various operations, but it fails in certain conditions.\n\nBug Location\nThe bug resides in the logic of the \"while\" loop, which handles the iteration over arguments and parameters. The original buggy line is:\n```java\nwhile (arguments.hasNext() && parameters.hasNext()) \n```\nIn the context of the code, this condition stops iteration over the arguments and parameters if either has no more items. This means that if the number of arguments is greater than parameters or vice versa, it results in failing to check or process the remaining items of the bigger list.\n\nSteps to Reproduce:\n1. Call the visitParameterList function, with a FunctionType parameter that has a different numbers of arguments and parameters.\n2. The function call.children().iterator() and functionType.getParameters().iterator() will respectively return the iterators for arguments and parameters lists.\n3. If one of these lists is longer than the other one, following the loop's condition, iteration stops when the shorter list is exhausted, failing to process remaining items of the longer list. This must raise an 'AssertionFailedError'.\n\nThe bug was fixed by enhancing the loop's condition. The bug fix ensures that iteration continues if parameters list has more items or the last parameter is a var_args.\n ```java\nwhile (arguments.hasNext() && (parameters.hasNext() || parameter != null && parameter.isVarArgs()))\n```\nAfter this change, the loop will continue iterating as long as there are arguments and either there are parameters or the last parameter is var_args. The parameter is also checked before extraction from the iterator.\n```java\nif (parameters.hasNext()) {\n    parameter = parameters.next();\n}\n```\nThis bug fix handles the situation where the number of parameters and arguments is not equal and the last parameter is var_args, ensuring all arguments and parameters are processed correctly without causing an assertion failure. \n\nFor bug reproduction, developers may manipulate the number of arguments and parameters or change the last parameter to not be a var_args to reintroduce the error."
}