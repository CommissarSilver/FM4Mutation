{
    "bug_id": 10,
    "bug_type": "SF",
    "buggy_lines": "",
    "code": "    private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                            entriesWithoutUTF8Flag)\n        throws IOException {\n        // changing the name of a ZipArchiveEntry is going to change\n        // the hashcode - see COMPRESS-164\n        // Map needs to be reconstructed in order to keep central\n        // directory order\n        for (ZipArchiveEntry ze : entries.keySet()) {\n            OffsetEntry offsetEntry = entries.get(ze);\n            long offset = offsetEntry.headerOffset;\n            archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n            byte[] b = new byte[SHORT];\n            archive.readFully(b);\n            int fileNameLen = ZipShort.getValue(b);\n            archive.readFully(b);\n            int extraFieldLen = ZipShort.getValue(b);\n            int lenToSkip = fileNameLen;\n            while (lenToSkip > 0) {\n                int skipped = archive.skipBytes(lenToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip file name in\"\n                                               + \" local file header\");\n                }\n                lenToSkip -= skipped;\n            }\n            byte[] localExtraData = new byte[extraFieldLen];\n            archive.readFully(localExtraData);\n            ze.setExtra(localExtraData);\n            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n                + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n            if (entriesWithoutUTF8Flag.containsKey(ze)) {\n                String orig = ze.getName();\n                NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                         nc.comment);\n                if (!orig.equals(ze.getName())) {\n                    nameMap.remove(orig);\n                    nameMap.put(ze.getName(), ze);\n                }\n            }\n        }\n    }",
    "fixed_code": "    private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                            entriesWithoutUTF8Flag)\n        throws IOException {\n        // changing the name of a ZipArchiveEntry is going to change\n        // the hashcode - see COMPRESS-164\n        // Map needs to be reconstructed in order to keep central\n        // directory order\n        Map<ZipArchiveEntry, OffsetEntry> origMap =\n            new LinkedHashMap<ZipArchiveEntry, OffsetEntry>(entries);\n        entries.clear();\n        for (ZipArchiveEntry ze : origMap.keySet()) {\n            OffsetEntry offsetEntry = origMap.get(ze);\n            long offset = offsetEntry.headerOffset;\n            archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n            byte[] b = new byte[SHORT];\n            archive.readFully(b);\n            int fileNameLen = ZipShort.getValue(b);\n            archive.readFully(b);\n            int extraFieldLen = ZipShort.getValue(b);\n            int lenToSkip = fileNameLen;\n            while (lenToSkip > 0) {\n                int skipped = archive.skipBytes(lenToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip file name in\"\n                                               + \" local file header\");\n                }\n                lenToSkip -= skipped;\n            }\n            byte[] localExtraData = new byte[extraFieldLen];\n            archive.readFully(localExtraData);\n            ze.setExtra(localExtraData);\n            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n                + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n            if (entriesWithoutUTF8Flag.containsKey(ze)) {\n                String orig = ze.getName();\n                NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                         nc.comment);\n                if (!orig.equals(ze.getName())) {\n                    nameMap.remove(orig);\n                    nameMap.put(ze.getName(), ze);\n                }\n            }\n            entries.put(ze, offsetEntry);\n        }\n    }",
    "fixed_lines": "            entries.put(ze, offsetEntry);",
    "masked_code": "    private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                            entriesWithoutUTF8Flag)\n        throws IOException {\n        // changing the name of a ZipArchiveEntry is going to change\n        // the hashcode - see COMPRESS-164\n        // Map needs to be reconstructed in order to keep central\n        // directory order\n            long offset = offsetEntry.headerOffset;\n            archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n            byte[] b = new byte[SHORT];\n            archive.readFully(b);\n            int fileNameLen = ZipShort.getValue(b);\n            archive.readFully(b);\n            int extraFieldLen = ZipShort.getValue(b);\n            int lenToSkip = fileNameLen;\n            while (lenToSkip > 0) {\n                int skipped = archive.skipBytes(lenToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip file name in\"\n                                               + \" local file header\");\n                }\n                lenToSkip -= skipped;\n            }\n            byte[] localExtraData = new byte[extraFieldLen];\n            archive.readFully(localExtraData);\n            ze.setExtra(localExtraData);\n            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n                + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n            if (entriesWithoutUTF8Flag.containsKey(ze)) {\n                String orig = ze.getName();\n                NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                         nc.comment);\n                if (!orig.equals(ze.getName())) {\n                    nameMap.remove(orig);\n                    nameMap.put(ze.getName(), ze);\n                }\n            }\n>>> [ INFILL ] <<<\n        }\n    }",
    "project": "Compress",
    "test_error_message": "junit.framework.AssertionFailedError: InputStream is null",
    "test_framework": "defects4j",
    "test_line": "        assertNotNull(\"InputStream is null\", is);",
    "test_name": "testReadWinZipArchive",
    "test_suite": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest",
    "time_buggy": "2011-12-05 11:49:03 +0000",
    "time_fixed": "2011-12-05 15:39:52 +0000",
    "bug_description": "Bug ID: 10\nProject: Compress\nBug Type: SF (Software Fault)\n\nTest Error Message: junit.framework.AssertionFailedError: InputStream is null\n\nBuggy lines: In the original code, the bug is located within the entire 'resolveLocalFileHeaderData' method.\n\nProblem description: \n\nThe specific error message says that 'InputStream is null' indicates that an InputStream has no reference point and is trying to process or handle a null value that it has received during the testing process. This possibly comes from an object initialization that is incorrectly set, or not set at all. The code does not properly handle the Archive's InputStream where data is sought, read and processed, which eventually throws AssertionFailedError exception as the InputStream is null.\n\nMore specfically, the bug could be on these aspects:\n\n1. Missing checking of InputStream status: The status of the InputStream (archive) is not checked before the operation, leading to a situation where operations may be performed on a null InputStream object.\n\n2. Improper management of ZipArchiveEntry and related Map \"entries\": The map named \"entries\" is traversed without being properly updated in each iteration which may cause conflicts, but concurrently, changing the map can also have indirect effects, such as changing the hashcode of a ZipArchiveEntry.\n\nProposed fix: \n\nThe repaired code constructs a new LinkedHashMap \"origMap\" at the beginning of the method that copies the initial map, \"entries\" and then clears \"entries\". The code then iterates through 'origMap', rather than 'entries', and after each iteration, the relevant 'ze' entry and 'offsetEntry' are added back into 'entries'. This fix appears to prevent unexpected changes of the 'entries' map during iteration and could solve potential issues relating to InputStream management by handling entries sequentially and correctly. It makes sure that operations are only performed on a suitably initialized InputStream.\n\nIn summary, the fix code improves the stability by creating a copy of the original entries and safely updating the original map \"entries\" while iterating through the original entries without causing conflicts or unexpected outcomes. This potentially addresses InputStream management issues which were reflected indirectly through the inputs and outputs of reading methods in previous 'archive' stream throughout the 'for' loop.\n"
}