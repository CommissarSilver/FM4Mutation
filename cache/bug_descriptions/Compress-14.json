{
    "bug_id": 14,
    "bug_type": "SH SF",
    "buggy_lines": "        boolean allNUL = true;\n        for (int i = start; i < end; i++){\n            if (buffer[i] != 0){\n                allNUL = false;\n                break;\n            }\n        }\n        if (allNUL) {",
    "code": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        boolean allNUL = true;\n        for (int i = start; i < end; i++){\n            if (buffer[i] != 0){\n                allNUL = false;\n                break;\n            }\n        }\n        if (allNUL) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Must have trailing NUL or space\n        byte trailer;\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        // May have additional NUL or space\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }",
    "fixed_code": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Must have trailing NUL or space\n        byte trailer;\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        // May have additional NUL or space\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }",
    "fixed_lines": "        if (buffer[start] == 0) {",
    "masked_code": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n>>> [ INFILL ] <<<\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Must have trailing NUL or space\n        byte trailer;\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        // May have additional NUL or space\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }",
    "project": "Compress",
    "test_error_message": "java.io.IOException: Error detected parsing the header",
    "test_framework": "defects4j",
    "test_line": "            tae = in.getNextTarEntry();",
    "test_name": "workaroundForBrokenTimeHeader",
    "test_suite": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest",
    "time_buggy": "2012-02-28 11:17:23 +0000",
    "time_fixed": "2012-03-02 19:59:50 +0000",
    "bug_description": "Bug ID: 14\nProject: Compress\nBug Type: Semantic(SH SF)\nTest Error Message: java.io.IOException: Error detected parsing the header\n\nDescription:\n\nThe bug was found in a piece of code used for parsing octal in the 'Compress' project. As per the provided test error message, an IOException occurs pointing to an error while parsing the header.\n\nIn the buggy version of the code, we can see a loop running from the start to the end of the length of the buffer that is intended to check if all elements till the end are set to NULL or not. \n\nBug Steps:\n\n1. The issue lies in the loop:\n    \n    ```\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i] != 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n    ```\n    The above piece of code checks every byte of the buffer from start to end to see if they are all null bytes. It sets a flag \"allNUL\", which is used later to return a value of 0 if all bytes are null.\n\n2. This sequence appears to be inefficient as it iterates over each byte checking for null before actually performing the essential operation. This, in all probabilities, is causing the IOException by exhausting system resources or perhaps causing an undesirable delay in the processing time, depending on the size of the buffer.\n\n3. Furthermore, the condition is checked only at the start. If the buffer size is large and the first byte is not 0, the entire loop will run unnecessarily without exiting early.\n\nResolution Steps in Fixed Code:\n\n1. To address the issue, a major change was performed to the block of code which checks for NULL bytes. \n\n```\nif (buffer[start] == 0) {\n    return 0L;\n}\n```\nIn this modification, the function checks only the start of the buffer for a null byte. If it is null, then the function returns 0 immediately, this saves a lot of processing power/time if the buffer is large.\n\n2. This change does not affect the other parts of the code as the iterating sequence is set to handle the rest of operations. \n\nBy performing these steps, the code is fixed and efficient, and the error message detected is thus resolved.\n"
}