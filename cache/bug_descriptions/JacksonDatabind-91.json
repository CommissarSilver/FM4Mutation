{
    "bug_id": 91,
    "bug_type": "SF",
    "buggy_lines": "                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);",
    "code": "    private boolean _hasCustomHandlers(JavaType t) {\n        if (t.isContainerType()) {\n            // First: value types may have both value and type handlers\n            JavaType ct = t.getContentType();\n            if (ct != null) {\n                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n            // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n            }\n        }\n        return false;\n    }",
    "fixed_code": "    private boolean _hasCustomHandlers(JavaType t) {\n        if (t.isContainerType()) {\n            // First: value types may have both value and type handlers\n            JavaType ct = t.getContentType();\n            if (ct != null) {\n                if ((ct.getValueHandler() != null) || (ct.getTypeHandler() != null)) {\n                    return true;\n                }\n            }\n            // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n            if (t.isMapLikeType()) {\n                JavaType kt = t.getKeyType();\n                if (kt.getValueHandler() != null) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }",
    "fixed_lines": "                if ((ct.getValueHandler() != null) || (ct.getTypeHandler() != null)) {\n                    return true;\n                }\n            }\n            if (t.isMapLikeType()) {\n                JavaType kt = t.getKeyType();\n                if (kt.getValueHandler() != null) {\n                    return true;\n                }",
    "masked_code": "    private boolean _hasCustomHandlers(JavaType t) {\n        if (t.isContainerType()) {\n            // First: value types may have both value and type handlers\n            JavaType ct = t.getContentType();\n            if (ct != null) {\n            // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n>>> [ INFILL ] <<<\n            }\n        }\n        return false;\n    }",
    "project": "JacksonDatabind",
    "test_error_message": "junit.framework.AssertionFailedError: Not using custom key deserializer for input: {\"data\":{\"1st\":\"onedata\",\"2nd\":\"twodata\"}}; resulted in: {1st=onedata, 2nd=twodata}",
    "test_framework": "defects4j",
    "test_line": "            fail(\"Not using custom key deserializer for input: \"+json+\"; resulted in: \"+model2.data);",
    "test_name": "testCachedSerialize",
    "test_suite": "com.fasterxml.jackson.databind.deser.jdk.MapDeserializerCachingTest",
    "time_buggy": "2017-10-23 20:02:43 -0700",
    "time_fixed": "2017-11-01 15:36:43 -0700",
    "bug_description": "Bug ID: 91\nProject: JacksonDatabind\nBug Type: SF (Serious Fault)\n\nDescription:\n\nThe bug resides in the JacksonDatabind project, specifically within a method named `_hasCustomHandlers()`. This method checks if a JavaType object, which represents types in Java, has any custom handlers attached.\n\nThe issue arises due to the lack of a condition check for 'map-like' types which can have value handlers for their keys. This omission results in the erroneous belief that the object does not contain custom handlers when it is indeed a map-like type with a key-value handler. \n\nDetail:\n\n1. The `_hasCustomHandlers()` method is being called from within the project for an object of the JavaType class. The JavaType object could potentially be a 'ContainerType', possessing 'value' and 'type' handlers or a 'MapLikeType' with value handlers for its keys. \n\n2. The provided test message shows the input: {\"data\":{\"1st\":\"onedata\",\"2nd\":\"twodata\"}}, which indicates a map-like structure with key-value pairs.\n\n3. The test error message asserts that the custom key deserializer is not being used for the input. The map-like input interpreted by the method ends up without its custom handlers because of the missing condition check.\n\n4. In the buggy code, no checks occur if the JavaType instance (`t`) is a MapLikeType and if some value handler for the keys exists. \n\n5. This results in the method returning false, instigating the framework to falsely assume that no custom key deserializer exists for the input.\n\nFix:\n\nThe bug is corrected by adding the missing conditions in the code. After checking if the JavaType (`t`) is a 'ContainerType' and inspecting its content, a second check confirms if `t` is a 'MapLikeType'. If it is, the code obtains the map's key type (`kt`) and checks if there's a value handler associated with it. If such a handler exists, the method thereafter correctly returns 'true', noting the existence of custom handler. \n\nImplication:\n\nThis bug could cause potential deserialization issues when dealing with map-like data structures within the JacksonDatabind project. The successful fix allows proper deserialization of key handlers in map-like type objects. \n\nNote:\n\nThe 'SF' (Serious Fault) bug type implies that this bug is likely to cause system crashes or produce incorrect, unexpected output, hence necessitating its quick fix."
}