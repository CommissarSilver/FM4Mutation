{
    "bug_id": 130,
    "bug_type": "SL SH SF",
    "buggy_lines": "      if (name.globalSets == 1 && name.localSets == 0 &&",
    "code": "  private void inlineAliases(GlobalNamespace namespace) {\n    // Invariant: All the names in the worklist meet condition (a).\n    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n      Name name = workList.pop();\n\n      // Don't attempt to inline a getter or setter property as a variable.\n      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n        continue;\n      }\n\n      if (name.globalSets == 1 && name.localSets == 0 &&\n          name.aliasingGets > 0) {\n        // {@code name} meets condition (b). Find all of its local aliases\n        // and try to inline them.\n        List<Ref> refs = Lists.newArrayList(name.getRefs());\n        for (Ref ref : refs) {\n          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n            // {@code name} meets condition (c). Try to inline it.\n            if (inlineAliasIfPossible(ref, namespace)) {\n              name.removeRef(ref);\n            }\n          }\n        }\n      }\n\n      // Check if {@code name} has any aliases left after the\n      // local-alias-inlining above.\n      if ((name.type == Name.Type.OBJECTLIT ||\n           name.type == Name.Type.FUNCTION) &&\n          name.aliasingGets == 0 && name.props != null) {\n        // All of {@code name}'s children meet condition (a), so they can be\n        // added to the worklist.\n        workList.addAll(name.props);\n      }\n    }\n  }",
    "fixed_code": "  private void inlineAliases(GlobalNamespace namespace) {\n    // Invariant: All the names in the worklist meet condition (a).\n    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n      Name name = workList.pop();\n\n      // Don't attempt to inline a getter or setter property as a variable.\n      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n        continue;\n      }\n\n      if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&\n          name.aliasingGets > 0) {\n        // {@code name} meets condition (b). Find all of its local aliases\n        // and try to inline them.\n        List<Ref> refs = Lists.newArrayList(name.getRefs());\n        for (Ref ref : refs) {\n          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n            // {@code name} meets condition (c). Try to inline it.\n            if (inlineAliasIfPossible(ref, namespace)) {\n              name.removeRef(ref);\n            }\n          }\n        }\n      }\n\n      // Check if {@code name} has any aliases left after the\n      // local-alias-inlining above.\n      if ((name.type == Name.Type.OBJECTLIT ||\n           name.type == Name.Type.FUNCTION) &&\n          name.aliasingGets == 0 && name.props != null) {\n        // All of {@code name}'s children meet condition (a), so they can be\n        // added to the worklist.\n        workList.addAll(name.props);\n      }\n    }\n  }",
    "fixed_lines": "      if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&",
    "masked_code": "  private void inlineAliases(GlobalNamespace namespace) {\n    // Invariant: All the names in the worklist meet condition (a).\n    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n      Name name = workList.pop();\n\n      // Don't attempt to inline a getter or setter property as a variable.\n      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n        continue;\n      }\n\n>>> [ INFILL ] <<<\n          name.aliasingGets > 0) {\n        // {@code name} meets condition (b). Find all of its local aliases\n        // and try to inline them.\n        List<Ref> refs = Lists.newArrayList(name.getRefs());\n        for (Ref ref : refs) {\n          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n            // {@code name} meets condition (c). Try to inline it.\n            if (inlineAliasIfPossible(ref, namespace)) {\n              name.removeRef(ref);\n            }\n          }\n        }\n      }\n\n      // Check if {@code name} has any aliases left after the\n      // local-alias-inlining above.\n      if ((name.type == Name.Type.OBJECTLIT ||\n           name.type == Name.Type.FUNCTION) &&\n          name.aliasingGets == 0 && name.props != null) {\n        // All of {@code name}'s children meet condition (a), so they can be\n        // added to the worklist.\n        workList.addAll(name.props);\n      }\n    }\n  }",
    "project": "Closure",
    "test_error_message": "junit.framework.AssertionFailedError:",
    "test_framework": "defects4j",
    "test_line": "    testSame(",
    "test_name": "testIssue931",
    "test_suite": "com.google.javascript.jscomp.CollapsePropertiesTest",
    "time_buggy": "2013-02-27 09:52:20 -0800",
    "time_fixed": "2013-02-27 15:08:53 -0800",
    "bug_description": "Bug ID: 130\nProject: Closure\nBug Type: SL SH SF\nTest Error Message: junit.framework.AssertionFailedError:\n\nDescription:\n\nThe Closure project uses a method called `inlineAliases` in order to manage variable names within the code. In particular, several conditions are implemented within the method to determine certain behaviours related to the status of the variable names.\n\nThe bug occurs in the following conditional statement:\n\n`if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0)`\n\nIn the original problematic code, the conditional statement was checking if the variable `name`'s global sets count was 1, its local sets count was 0, and its aliasingGets count was more than 0.\n\nHowever, an important condition was not included in this check which was causing the AssertionFailedError during tests. The condition that wasn't considered is whether the `name` is defined outside the currently executing script (`name.inExterns`).\n\nThus, the bug arose because the conditional statement was omitting a necessary condition (whether or not the name was defined in an external script), subsequently causing the `AssertionFailedError`.\n\nThe fixed code includes the missing condition in the check:\n\n`if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0)`\n\nNow, the conditional statement with the updated condition properly checks if the name\u2019s globals sets count is 1, its local sets count is zero, its aliasingGets count is more than zero and if it\u2019s not defined outside the current script (not in externs). As a result of this fix, the AssertionFailedError no longer occurs during tests."
}