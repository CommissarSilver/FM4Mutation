{
    "bug_id": 24,
    "bug_type": "SF",
    "buggy_lines": "        if (trailer == 0 || trailer == ' '){\n        } else {\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        trailer = buffer[end - 1];\n        while (start < end - 1 && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];",
    "code": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Trim all trailing NULs and spaces.\n        // The ustar and POSIX tar specs require a trailing NUL or\n        // space but some implementations use the extra digit for big\n        // sizes/uids/gids ...\n        byte trailer = buffer[end - 1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        trailer = buffer[end - 1];\n        while (start < end - 1 && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }",
    "fixed_code": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Trim all trailing NULs and spaces.\n        // The ustar and POSIX tar specs require a trailing NUL or\n        // space but some implementations use the extra digit for big\n        // sizes/uids/gids ...\n        byte trailer = buffer[end - 1];\n        while (start < end && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n        if (start == end) {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, trailer));\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }",
    "fixed_lines": "        while (start < end && (trailer == 0 || trailer == ' ')) {\n            trailer = buffer[end - 1];\n        }\n        if (start == end) {\n                    exceptionMessage(buffer, offset, length, start, trailer));",
    "masked_code": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Trim all trailing NULs and spaces.\n        // The ustar and POSIX tar specs require a trailing NUL or\n        // space but some implementations use the extra digit for big\n        // sizes/uids/gids ...\n        byte trailer = buffer[end - 1];\n            end--;\n            throw new IllegalArgumentException(\n>>> [ INFILL ] <<<\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }",
    "project": "Compress",
    "test_error_message": "java.lang.IllegalArgumentException: Invalid byte 55 at offset 11 in '777777777777' len=12",
    "test_framework": "defects4j",
    "test_line": "        value = TarUtils.parseOctal(buffer,0, buffer.length);",
    "test_name": "testParseOctal",
    "test_suite": "org.apache.commons.compress.archivers.tar.TarUtilsTest",
    "time_buggy": "2014-02-20 16:12:37 +0000",
    "time_fixed": "2014-02-21 05:20:08 +0000",
    "bug_description": "Bug Description:\n\nBug ID: 24\nProject: Compress\nBug Type: Semantic Failures (SF)\n\nError Message: IllegalArgumentException: Invalid byte 55 at offset 11 in '777777777777' len=12\nThe error message indicates that an IllegalArgumentException thrown because of an invalid byte ('55' in ASCII form is '7') at the 11th index of the string '777777777777' that has a length of 12.\n\nSteps to Reproduce:\n1. A byte array (buffer) is passed to the method parseOctal with an offset and length. Buffer consists of ASCII characters which are intended to be converted into Octal format.\n2. 'start' is initialized with the value of 'offset' and 'end' with (offset + length).\n3. As part of input validation, the method checks if length is less than 2, consequently throwing an IllegalArgumentException if true.\n4. The method then checks whether the byte at the start index is a zero - if it is, it returns 0L.\n5. The first loop skips all leading spaces (' ' ASCII characters).\n6. The second loop trims all trailing NULLs and spaces (0 and ' ' ASCII characters). The byte at the end of the buffer ('trailer') is fetched before the loop. If the byte is not a NULL or space, an IllegalArgumentException is thrown.\n7. The bug is found here where 'trailer' is updated again with the byte at the end of the buffer, and the loop continues to eliminate all trailing NULLs and spaces. This leads to the throwing of an IllegalArgumentException because of 'trailer' byte's value being '7' (ASCII 55h), a valid byte that has been considered as invalid.\n\nProblematic Code:\nThe problem in the code lies in line numbers 26 to 30 where 'trailer' is updated and the loop continues to eliminate all trailing NULLs and spaces.\n\nFixed Code:\nThe fixing of the bug involves modifying the loop that was doing an unnecessary check and throwing an exception. This eliminates the possibility of valid characters being misinterpreted as invalid ones. A conditional statement is added after the loop to check if start equals end - if it is true, it means that the byte array consists of only NULLs or spaces, and so an exception is thrown."
}