{
    "bug_id": 87,
    "bug_type": "SF",
    "buggy_lines": "          return NodeUtil.isExpressionNode(maybeExpr);",
    "code": "  private boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n      if (n.hasOneChild()) {\n        Node maybeExpr = n.getFirstChild();\n          // IE has a bug where event handlers behave differently when\n          // their return value is used vs. when their return value is in\n          // an EXPR_RESULT. It's pretty freaking weird. See:\n          // http://code.google.com/p/closure-compiler/issues/detail?id=291\n          // We try to detect this case, and not fold EXPR_RESULTs\n          // into other expressions.\n\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n\n          return NodeUtil.isExpressionNode(maybeExpr);\n      }\n    }\n\n    return false;\n  }",
    "fixed_code": "  private boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n      if (n.hasOneChild()) {\n        Node maybeExpr = n.getFirstChild();\n        if (maybeExpr.getType() == Token.EXPR_RESULT) {\n          // IE has a bug where event handlers behave differently when\n          // their return value is used vs. when their return value is in\n          // an EXPR_RESULT. It's pretty freaking weird. See:\n          // http://code.google.com/p/closure-compiler/issues/detail?id=291\n          // We try to detect this case, and not fold EXPR_RESULTs\n          // into other expressions.\n          if (maybeExpr.getFirstChild().getType() == Token.CALL) {\n            Node calledFn = maybeExpr.getFirstChild().getFirstChild();\n\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n            if (calledFn.getType() == Token.GETELEM) {\n              return false;\n            } else if (calledFn.getType() == Token.GETPROP &&\n                       calledFn.getLastChild().getString().startsWith(\"on\")) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n        return false;\n      }\n    }\n\n    return false;\n  }",
    "fixed_lines": "        if (maybeExpr.getType() == Token.EXPR_RESULT) {\n          if (maybeExpr.getFirstChild().getType() == Token.CALL) {\n            Node calledFn = maybeExpr.getFirstChild().getFirstChild();\n            if (calledFn.getType() == Token.GETELEM) {\n              return false;\n            } else if (calledFn.getType() == Token.GETPROP &&\n                       calledFn.getLastChild().getString().startsWith(\"on\")) {\n              return false;\n            }\n          }\n          return true;\n        }\n        return false;",
    "masked_code": "  private boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n      if (n.hasOneChild()) {\n        Node maybeExpr = n.getFirstChild();\n          // IE has a bug where event handlers behave differently when\n          // their return value is used vs. when their return value is in\n          // an EXPR_RESULT. It's pretty freaking weird. See:\n          // http://code.google.com/p/closure-compiler/issues/detail?id=291\n          // We try to detect this case, and not fold EXPR_RESULTs\n          // into other expressions.\n\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n\n>>> [ INFILL ] <<<\n      }\n    }\n\n    return false;\n  }",
    "project": "Closure",
    "test_error_message": "junit.framework.AssertionFailedError:",
    "test_framework": "defects4j",
    "test_line": "    testSame(js);",
    "test_name": "testIssue291",
    "test_suite": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest",
    "time_buggy": "2010-12-14 21:49:06 +0000",
    "time_fixed": "2010-12-14 23:17:54 +0000",
    "bug_description": "Bug ID: 87\nBug Type: Semantic Fault (SF)\nProject: Closure\n\nBug Description:\n\nThe bug occurs in the method 'isFoldableExpressBlock()' in the 'Closure' project. A Semantic Fault (SF) results in a failure that the testing stage detects. Due to this semantic bug, the program shows junit.framework.AssertionFailedError during test execution. \n\nBug Details:\n\nThe problematic line in the buggy code segment is:\n\nreturn NodeUtil.isExpressionNode(maybeExpr);\n\nThis line is inside a method primarily used to determine whether an expression block is foldable or not. While trying to identify a specific class of faults by invoking a function 'isExpressionNode()', it leads to a failure.\n\nSteps to Reproduce:\n\n1. The error arises in the execution of the 'isFoldableExpressBlock()' method in the 'Block' class of the Closure project. \n\n2. In the 'if' condition, an essential check about the type of Node 'maybeExpr' is missing: \n\n   Node maybeExpr = n.getFirstChild();\n\n3. In the following line, the function 'isExpressionNode()' from 'NodeUtil' class is being called:\n\n   return NodeUtil.isExpressionNode(maybeExpr);\n\n4. Upon calling this function, if 'maybeExpr' is not of the expected type, a junit.framework.AssertionFailedError occurs.\n\nFixed Code Explanation:\n\nThe fixed code introduces additional checks to determine the type of 'maybeExpr', correctly mapping the given conditions prescribed in the comment lines. A check for the type of 'maybeExpr' is added using the condition:\n\nif (maybeExpr.getType() == Token.EXPR_RESULT)\n\nThen, using the nested conditions, the specific problematic cases related to methods with an implicit 'this' parameter and event handlers' behaviors are handled effectively, thereby avoiding the assertion failure.\n\nFollowing fixing the bug, all the method return statements are now placed logically ensuring they are not violating any conditions, thus significantly reducing the chance of runtime errors or assertion failures.\n\nRecommendations for Creating Artificial Java Bugs:\n\nDevelopers can introduce bugs in Java projects by violating coding conventions, ignoring proper exception handling, removing necessary conditions and checks, using incorrect data types, placing return statements incorrectly, etc. By studying historical bugs from projects like this, they can better understand the common patterns for typical bug types."
}