{
    "bug_id": 9,
    "bug_type": "SL SH SF",
    "buggy_lines": "        if (endIndex < 0) {",
    "code": "    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  // start is after last data item\n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             // end period is not in original series\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\n            endIndex = endIndex - 1;    // so this is last item BEFORE end\n        }\n        if (endIndex < 0) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }",
    "fixed_code": "    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  // start is after last data item\n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             // end period is not in original series\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\n            endIndex = endIndex - 1;    // so this is last item BEFORE end\n        }\n        if ((endIndex < 0)  || (endIndex < startIndex)) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }",
    "fixed_lines": "        if ((endIndex < 0)  || (endIndex < startIndex)) {",
    "masked_code": "    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  // start is after last data item\n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             // end period is not in original series\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\n            endIndex = endIndex - 1;    // so this is last item BEFORE end\n        }\n>>> [ INFILL ] <<<\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }",
    "project": "Chart",
    "test_error_message": "java.lang.IllegalArgumentException: Requires start <= end.",
    "test_framework": "defects4j",
    "test_line": "            s.createCopy(new Day(1, 12, 2005), new Day(18, 1, 2006));",
    "test_name": "testBug1864222",
    "test_suite": "org.jfree.data.time.junit.TimeSeriesTests",
    "time_buggy": "2008-06-10 02:03:09 -0700 ",
    "time_fixed": "2008-06-10 02:08:12 -0700 ",
    "bug_description": "Bug ID: 9\nProject: Chart\nBug Type: SL SH SF\nTest Error Message: java.lang.IllegalArgumentException: Requires start <= end.\n\nDescription:\n\n1. The bug resides in the 'TimeSeries' class, in the 'createCopy()' method. The problematic portion of the code is within the conditional checking of 'endIndex'. This method aims to create a copy of a time-series data between two given instances 'start' and 'end'.\n\n2. The error message for the bug indicates that it expects the 'start' period to be lesser than or equal to the 'end' period. However, it seems that the problem lies in handling scenarios when 'end' period is not present in the original series. In such cases, the 'endIndex' becomes less than 0, which results in an empty range and ultimately leads to a 'IllegalArgumentException'.\n\n3. The faulty lines are in the following segment of the code:\n\n```\nif (endIndex < 0) {\n    emptyRange = true;\n}\n```\n\nThis condition is triggered when 'endIndex' is less than 0, causing the 'emptyRange' to be true. The issue is, it sets 'emptyRange' to be true regardless of whether 'endIndex' is less than 'startIndex', which shouldn't be the case.\n\n4. The fixed code resolves this bug by updating the condition:\n\n```\nif ((endIndex < 0)  || (endIndex < startIndex)) {\n    emptyRange = true;\n}\n```\n\nIn this correction, 'emptyRange' is set to true only when 'endIndex' is less than 0, OR when 'endIndex' is less than 'startIndex'. This ensures the range won't be flagged as empty just because 'endIndex' is less than 0, it should also be less than 'startIndex' to be marked as empty.\n\n5. To artificially generate a similar bug, you may reverse the logic of any conditional statement involving range boundaries, or potentially remove a boundary check condition altogether. This might lead to erroneous handling of ranges outside their valid domains."
}