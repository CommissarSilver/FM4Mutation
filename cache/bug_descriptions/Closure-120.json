{
    "bug_id": 120,
    "bug_type": "SH SF",
    "buggy_lines": "",
    "code": "    private boolean isInitializingAssignmentAt(int index) {\n      if (index < references.size() && index > 0) {\n        Reference maybeDecl = references.get(index - 1);\n        if (maybeDecl.isVarDeclaration()) {\n          Preconditions.checkState(!maybeDecl.isInitializingDeclaration());\n          Reference maybeInit = references.get(index);\n          if (maybeInit.isSimpleAssignmentToName()) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    /**\n     * @return The reference that provides the value for the variable at the\n     * time of the first read, if known, otherwise null.\n     *\n     * This is either the variable declaration (\"var a = ...\") or first\n     * reference following the declaration if it is an assignment.\n     */\n    Reference getInitializingReference() {\n      if (isInitializingDeclarationAt(0)) {\n        return references.get(0);\n      } else if (isInitializingAssignmentAt(1)) {\n        return references.get(1);\n      }\n      return null;\n    }\n\n    /**\n     * Constants are allowed to be defined after their first use.\n     */\n    Reference getInitializingReferenceForConstants() {\n      int size = references.size();\n      for (int i = 0; i < size; i++) {\n        if (isInitializingDeclarationAt(i) || isInitializingAssignmentAt(i)) {\n          return references.get(i);\n        }\n      }\n      return null;\n    }\n\n    /**\n     * @return Whether the variable is only assigned a value once for its\n     *     lifetime.\n     */\n    boolean isAssignedOnceInLifetime() {\n      Reference ref = getOneAndOnlyAssignment();\n      if (ref == null) {\n        return false;\n      }\n\n      // Make sure this assignment is not in a loop.\n      for (BasicBlock block = ref.getBasicBlock();\n           block != null; block = block.getParent()) {\n        if (block.isFunction) {\n          break;\n        } else if (block.isLoop) {\n          return false;\n        }\n      }\n\n      return true;\n    }",
    "fixed_code": "    private boolean isInitializingAssignmentAt(int index) {\n      if (index < references.size() && index > 0) {\n        Reference maybeDecl = references.get(index - 1);\n        if (maybeDecl.isVarDeclaration()) {\n          Preconditions.checkState(!maybeDecl.isInitializingDeclaration());\n          Reference maybeInit = references.get(index);\n          if (maybeInit.isSimpleAssignmentToName()) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    /**\n     * @return The reference that provides the value for the variable at the\n     * time of the first read, if known, otherwise null.\n     *\n     * This is either the variable declaration (\"var a = ...\") or first\n     * reference following the declaration if it is an assignment.\n     */\n    Reference getInitializingReference() {\n      if (isInitializingDeclarationAt(0)) {\n        return references.get(0);\n      } else if (isInitializingAssignmentAt(1)) {\n        return references.get(1);\n      }\n      return null;\n    }\n\n    /**\n     * Constants are allowed to be defined after their first use.\n     */\n    Reference getInitializingReferenceForConstants() {\n      int size = references.size();\n      for (int i = 0; i < size; i++) {\n        if (isInitializingDeclarationAt(i) || isInitializingAssignmentAt(i)) {\n          return references.get(i);\n        }\n      }\n      return null;\n    }\n\n    /**\n     * @return Whether the variable is only assigned a value once for its\n     *     lifetime.\n     */\n    boolean isAssignedOnceInLifetime() {\n      Reference ref = getOneAndOnlyAssignment();\n      if (ref == null) {\n        return false;\n      }\n\n      // Make sure this assignment is not in a loop.\n      for (BasicBlock block = ref.getBasicBlock();\n           block != null; block = block.getParent()) {\n        if (block.isFunction) {\n          if (ref.getSymbol().getScope() != ref.scope) {\n            return false;\n          }\n          break;\n        } else if (block.isLoop) {\n          return false;\n        }\n      }\n\n      return true;\n    }",
    "fixed_lines": "          if (ref.getSymbol().getScope() != ref.scope) {\n            return false;\n          }",
    "masked_code": "    private boolean isInitializingAssignmentAt(int index) {\n      if (index < references.size() && index > 0) {\n        Reference maybeDecl = references.get(index - 1);\n        if (maybeDecl.isVarDeclaration()) {\n          Preconditions.checkState(!maybeDecl.isInitializingDeclaration());\n          Reference maybeInit = references.get(index);\n          if (maybeInit.isSimpleAssignmentToName()) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    /**\n     * @return The reference that provides the value for the variable at the\n     * time of the first read, if known, otherwise null.\n     *\n     * This is either the variable declaration (\"var a = ...\") or first\n     * reference following the declaration if it is an assignment.\n     */\n    Reference getInitializingReference() {\n      if (isInitializingDeclarationAt(0)) {\n        return references.get(0);\n      } else if (isInitializingAssignmentAt(1)) {\n        return references.get(1);\n      }\n      return null;\n    }\n\n    /**\n     * Constants are allowed to be defined after their first use.\n     */\n    Reference getInitializingReferenceForConstants() {\n      int size = references.size();\n      for (int i = 0; i < size; i++) {\n        if (isInitializingDeclarationAt(i) || isInitializingAssignmentAt(i)) {\n          return references.get(i);\n        }\n      }\n      return null;\n    }\n\n    /**\n     * @return Whether the variable is only assigned a value once for its\n     *     lifetime.\n     */\n    boolean isAssignedOnceInLifetime() {\n      Reference ref = getOneAndOnlyAssignment();\n      if (ref == null) {\n        return false;\n      }\n\n      // Make sure this assignment is not in a loop.\n      for (BasicBlock block = ref.getBasicBlock();\n           block != null; block = block.getParent()) {\n        if (block.isFunction) {\n>>> [ INFILL ] <<<\n          break;\n        } else if (block.isLoop) {\n          return false;\n        }\n      }\n\n      return true;\n    }",
    "project": "Closure",
    "test_error_message": "junit.framework.AssertionFailedError:",
    "test_framework": "defects4j",
    "test_line": "    testSame(",
    "test_name": "testExternalIssue1053",
    "test_suite": "com.google.javascript.jscomp.InlineVariablesTest",
    "time_buggy": "2013-08-13 18:28:18 -0700",
    "time_fixed": "2013-08-13 18:28:20 -0700",
    "bug_description": "Bug ID: 120\nProject: Closure\nBug Type: Semantic/Functionality Issue\nError Message: \"junit.framework.AssertionFailedError:\"\n\nBug Description:\n\nThis bug is related to the Closure project and seems to be a semantic or functionality issue. The method \"isAssignedOnceInLifetime()\" present in this code is where the issue is found. This is a method that is supposed to return whether a variable is only assigned a value once for its entire lifetime. \n\nThe faulty section of this method intents to verify if the assignment is not in a loop. If it's not, then the method should return true, indicating that the variable is only assigned once. However, in cases where the assignment is within a function, the function does not validate whether the scope of the symbol being referenced is the same as the scope of the reference. This means the function may incorrectly return that a variable is only assigned once when in fact it is being assigned multiple times within the same function scope.\n\nStep 1: The method \"isAssignedOnceInLifetime()\" is invoking the function \"getOneAndOnlyAssignment()\". If getOneAndOnlyAssignment() returns null, the method isAssignedOnceInLifetime() will also return false.\n\nStep 2: The function then enters a for-loop where it checks if the current block is a function or a loop using \"block.isFunction\" and \"block.isLoop\".\n\nStep 3: Within its current implementation, when it identifies the block as a function (\"block.isFunction\" returns true), it breaks the loop and implicitly returns true, i.e., deeming the variable to be assigned only once in its lifetime. \n\nThe problem is revealed if the symbol's scope differs from the reference's scope, even though it's correctly identified as a function. The code omits a crucial validation check here, which should confirm whether the symbol's scope and reference's scope are the same.\n\nFixed Code Explanation:\n\nThe fixed code adds this necessary validation check to the \"isAssignedOnceInLifetime()\" function. It specifically includes the condition:\n```\nif (ref.getSymbol().getScope() != ref.scope) {\n  return false;\n}\n```\nBefore breaking the loop, it now validates if the reference's scope and the symbol's scope are the same; if not, the method returns false, correctly indicating that the variable is not assigned only once in its lifetime."
}