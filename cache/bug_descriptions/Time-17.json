{
    "bug_id": 17,
    "bug_type": "SF",
    "buggy_lines": "        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        if (instantBefore == instantAfter) {\n        long local = convertUTCToLocal(instant);\n        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);",
    "code": "    public long adjustOffset(long instant, boolean earlierOrLater) {\n        // a bit messy, but will work in all non-pathological cases\n        \n        // evaluate 3 hours before and after to work out if anything is happening\n        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        if (instantBefore == instantAfter) {\n            return instant;  // not an overlap (less than is a gap, equal is normal case)\n        }\n        \n        // work out range of instants that have duplicate local times\n        long local = convertUTCToLocal(instant);\n        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n        \n        // calculate result\n          // currently in later offset\n          // currently in earlier offset\n    }",
    "fixed_code": "    public long adjustOffset(long instant, boolean earlierOrLater) {\n        // a bit messy, but will work in all non-pathological cases\n        \n        // evaluate 3 hours before and after to work out if anything is happening\n        long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;\n        long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;\n        long offsetBefore = getOffset(instantBefore);\n        long offsetAfter = getOffset(instantAfter);\n        if (offsetBefore <= offsetAfter) {\n            return instant;  // not an overlap (less than is a gap, equal is normal case)\n        }\n        \n        // work out range of instants that have duplicate local times\n        long diff = offsetBefore - offsetAfter;\n        long transition = nextTransition(instantBefore);\n        long overlapStart = transition - diff;\n        long overlapEnd = transition + diff;\n        if (instant < overlapStart || instant >= overlapEnd) {\n          return instant;  // not an overlap\n        }\n        \n        // calculate result\n        long afterStart = instant - overlapStart;\n        if (afterStart >= diff) {\n          // currently in later offset\n          return earlierOrLater ? instant : instant - diff;\n        } else {\n          // currently in earlier offset\n          return earlierOrLater ? instant + diff : instant;\n        }\n    }",
    "fixed_lines": "        long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;\n        long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;\n        long offsetBefore = getOffset(instantBefore);\n        long offsetAfter = getOffset(instantAfter);\n        if (offsetBefore <= offsetAfter) {\n        long diff = offsetBefore - offsetAfter;\n        long transition = nextTransition(instantBefore);\n        long overlapStart = transition - diff;\n        long overlapEnd = transition + diff;\n        if (instant < overlapStart || instant >= overlapEnd) {\n          return instant;  // not an overlap\n        }\n        long afterStart = instant - overlapStart;\n        if (afterStart >= diff) {\n          return earlierOrLater ? instant : instant - diff;\n        } else {\n          return earlierOrLater ? instant + diff : instant;\n        }",
    "masked_code": "    public long adjustOffset(long instant, boolean earlierOrLater) {\n        // a bit messy, but will work in all non-pathological cases\n        \n        // evaluate 3 hours before and after to work out if anything is happening\n            return instant;  // not an overlap (less than is a gap, equal is normal case)\n        }\n        \n        // work out range of instants that have duplicate local times\n        \n        // calculate result\n          // currently in later offset\n          // currently in earlier offset\n>>> [ INFILL ] <<<\n    }",
    "project": "Time",
    "test_error_message": "junit.framework.AssertionFailedError: expected:<2012-02-25T23:15:00.000-03:00> but was:<2012-02-25T23:15:00.000-02:00>",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(baseAfter, baseBefore.withLaterOffsetAtOverlap());",
    "test_name": "testBug3476684_adjustOffset",
    "test_suite": "org.joda.time.TestDateTimeZoneCutover",
    "time_buggy": "2012-02-02 11:42:38 +0000",
    "time_fixed": "2012-02-02 13:09:36 +0000",
    "bug_description": "Bug Description:\n\nBug ID: 17\n\nBug Project: Time \n\nBug Type: Semantic Fault (SF)\n\nBrief Overview: \nThe bug in the 'Time' project pertains to an error in the date-time conversion process. The original code is supposed to adjust the 'instant' date-time object based on time zone offsets. However, it fails to account accurately for the difference between local and UTC time, resulting in incorrect outputs.\n\nReproduction Steps:\n\n1. A temporary variable, 'instant', is created holding a UTC timestamp.\n2. To handle differences in time zones, the 'instant' variable is subtracted and added by, three hours each, to generate two new variables 'instantBefore' and 'instantAfter'.\n3. 'instantBefore' and 'instantAfter' are converted to local using 'convertUTCToLocal' method and checked for equality.\n4. As they are equal in this case, the code directly returns the 'instant' timestamp without any adjustments reasoning there is no overlap.\n5. This causes the date-time error encountered in the test, as the original 'instant' was not correctly adjusted to account for time zone offsets.\n\nObserved Result:\nThe obtained result is one hour ahead of the expected result. The result is '2012-02-25T23:15:00.000-02:00' instead of the expected '2012-02-25T23:15:00.000-03:00'.\n\nFixed Code Reasoning:\n\nThe fixed code properly handles the time zone differences. Instead of converting 'instantBefore' and 'instantAfter' to local time, it first calculates the offset for 'instantBefore' and 'instantAfter' using the 'getOffset' function. Depending upon the offset, the code then calculates the range of instants that have duplicate local times. It correctly adjusts the instant based on if it is in earlier or later offset. This ensures that the result obtained is in line with the time zone offset, and the test will pass as expected.\n\nSuggested Test Case:\nThe test case that originally failed due to this bug should now pass. It should correctly adjust the original timestamp to account for the three-hour time zone difference resulting in '2012-02-25T23:15:00.000-03:00' instead of '2012-02-25T23:15:00.000-02:00'. The 'adjustOffset()' function should now return the expected result when tested."
}