{
    "bug_id": 7,
    "bug_type": "SF",
    "buggy_lines": "            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()",
    "code": "    private void updateBounds(TimePeriod period, int index) {\n        \n        long start = period.getStart().getTime();\n        long end = period.getEnd().getTime();\n        long middle = start + ((end - start) / 2);\n\n        if (this.minStartIndex >= 0) {\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start < minStart) {\n                this.minStartIndex = index;           \n            }\n        }\n        else {\n            this.minStartIndex = index;\n        }\n        \n        if (this.maxStartIndex >= 0) {\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start > maxStart) {\n                this.maxStartIndex = index;           \n            }\n        }\n        else {\n            this.maxStartIndex = index;\n        }\n        \n        if (this.minMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long minMiddle = s + (e - s) / 2;\n            if (middle < minMiddle) {\n                this.minMiddleIndex = index;           \n            }\n        }\n        else {\n            this.minMiddleIndex = index;\n        }\n        \n        if (this.maxMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long maxMiddle = s + (e - s) / 2;\n            if (middle > maxMiddle) {\n                this.maxMiddleIndex = index;           \n            }\n        }\n        else {\n            this.maxMiddleIndex = index;\n        }\n        \n        if (this.minEndIndex >= 0) {\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end < minEnd) {\n                this.minEndIndex = index;           \n            }\n        }\n        else {\n            this.minEndIndex = index;\n        }\n       \n        if (this.maxEndIndex >= 0) {\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end > maxEnd) {\n                this.maxEndIndex = index;           \n            }\n        }\n        else {\n            this.maxEndIndex = index;\n        }\n        \n    }",
    "fixed_code": "    private void updateBounds(TimePeriod period, int index) {\n        \n        long start = period.getStart().getTime();\n        long end = period.getEnd().getTime();\n        long middle = start + ((end - start) / 2);\n\n        if (this.minStartIndex >= 0) {\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start < minStart) {\n                this.minStartIndex = index;           \n            }\n        }\n        else {\n            this.minStartIndex = index;\n        }\n        \n        if (this.maxStartIndex >= 0) {\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start > maxStart) {\n                this.maxStartIndex = index;           \n            }\n        }\n        else {\n            this.maxStartIndex = index;\n        }\n        \n        if (this.minMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long minMiddle = s + (e - s) / 2;\n            if (middle < minMiddle) {\n                this.minMiddleIndex = index;           \n            }\n        }\n        else {\n            this.minMiddleIndex = index;\n        }\n        \n        if (this.maxMiddleIndex >= 0) {\n            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long maxMiddle = s + (e - s) / 2;\n            if (middle > maxMiddle) {\n                this.maxMiddleIndex = index;           \n            }\n        }\n        else {\n            this.maxMiddleIndex = index;\n        }\n        \n        if (this.minEndIndex >= 0) {\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end < minEnd) {\n                this.minEndIndex = index;           \n            }\n        }\n        else {\n            this.minEndIndex = index;\n        }\n       \n        if (this.maxEndIndex >= 0) {\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end > maxEnd) {\n                this.maxEndIndex = index;           \n            }\n        }\n        else {\n            this.maxEndIndex = index;\n        }\n        \n    }",
    "fixed_lines": "            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\n            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()",
    "masked_code": "    private void updateBounds(TimePeriod period, int index) {\n        \n        long start = period.getStart().getTime();\n        long end = period.getEnd().getTime();\n        long middle = start + ((end - start) / 2);\n\n        if (this.minStartIndex >= 0) {\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start < minStart) {\n                this.minStartIndex = index;           \n            }\n        }\n        else {\n            this.minStartIndex = index;\n        }\n        \n        if (this.maxStartIndex >= 0) {\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start > maxStart) {\n                this.maxStartIndex = index;           \n            }\n        }\n        else {\n            this.maxStartIndex = index;\n        }\n        \n        if (this.minMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long minMiddle = s + (e - s) / 2;\n            if (middle < minMiddle) {\n                this.minMiddleIndex = index;           \n            }\n        }\n        else {\n            this.minMiddleIndex = index;\n        }\n        \n        if (this.maxMiddleIndex >= 0) {\n                .getTime();\n>>> [ INFILL ] <<<\n                .getTime();\n            long maxMiddle = s + (e - s) / 2;\n            if (middle > maxMiddle) {\n                this.maxMiddleIndex = index;           \n            }\n        }\n        else {\n            this.maxMiddleIndex = index;\n        }\n        \n        if (this.minEndIndex >= 0) {\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end < minEnd) {\n                this.minEndIndex = index;           \n            }\n        }\n        else {\n            this.minEndIndex = index;\n        }\n       \n        if (this.maxEndIndex >= 0) {\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end > maxEnd) {\n                this.maxEndIndex = index;           \n            }\n        }\n        else {\n            this.maxEndIndex = index;\n        }\n        \n    }",
    "project": "Chart",
    "test_error_message": "junit.framework.AssertionFailedError: expected:<1> but was:<3>",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(1, s.getMaxMiddleIndex());",
    "test_name": "testGetMaxMiddleIndex",
    "test_suite": "org.jfree.data.time.junit.TimePeriodValuesTests",
    "time_buggy": "2008-06-10 02:20:57 -0700 ",
    "time_fixed": "2008-06-10 02:22:11 -0700 ",
    "bug_description": "Bug Title: Incorrect Index Calculations with AssertionFailedError\n\nBug ID: 7\nProject Name: Chart\nBug Type: Assertion Failed Error (SF)\n\nDescription:\n\nThe observed error is a failing Junit assertion. The test error message clearly mentioned that the expected index was '<1>' but the current implementation resulted in the index '<3>'. The severity of this issue was more when dealing with the 'updateBounds' function in the main project code. \n\nSteps to Reproduce:\n1. The error was traced back to the 'updateBounds' method where values are updated based on the calculation of various indexes (minStartIndex, maxStartIndex, minMiddleIndex, etc).\n2. While calling these index variants, it calculates the middle index (long middle = start + ((end - start) / 2)) and compares them with the corresponding index.\n3. The error lies in the block where the 'minMiddleIndex' and 'maxMiddleIndex' are calculated. For 'minMiddleIndex', the 'start' and 'end' times are fetched properly, and the middle index is calculated correctly.\n4. However, in the case of 'maxMiddleIndex', the 'start' and 'end' times were fetched from the 'minMiddleIndex', which was incorrect. Due to this wrong fetch, the calculated middle index was also incorrect.\n\nThis bug impacts the overall functionality as it incorrectly updates the bounds based on the middle index.\n\nTo fix this bug, in the if condition for 'maxMiddleIndex', replace the 'minMiddleIndex' with 'maxMiddleIndex' for fetching 'start' and 'end' times. With this correction, the calculated maxMiddle turns out to be accurate. The corrected function handles the edge condition and gives the correct middle index calculation results. Here, the algorithm maintains the correct index structure with the 'start' and 'end' time variables. \n\nAfter making this modification in the code, the implementation now returns the correct index as expected, thus resolving the original junit.framework.AssertionFailedError issue."
}