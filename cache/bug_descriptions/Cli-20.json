{
    "bug_id": 20,
    "bug_type": "SF",
    "buggy_lines": "                if (token.indexOf('=') != -1)\n                    tokens.add(token.substring(0, token.indexOf('=')));\n                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n                    tokens.add(token);",
    "code": "    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            String token = (String) iter.next();\n\n            // handle long option --foo or --foo=bar\n            if (token.startsWith(\"--\"))\n            {\n                if (token.indexOf('=') != -1)\n                {\n                    tokens.add(token.substring(0, token.indexOf('=')));\n                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                tokens.add(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                if (token.length() == 2)\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                else if (options.hasOption(token))\n                {\n                    tokens.add(token);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token);\n            }\n            else\n            {\n                tokens.add(token);\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }",
    "fixed_code": "    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            String token = (String) iter.next();\n\n            // handle long option --foo or --foo=bar\n            if (token.startsWith(\"--\"))\n            {\n                int pos = token.indexOf('=');\n                String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\n                if (!options.hasOption(opt) && stopAtNonOption)\n                {\n                    process(token);\n                }\n                else\n                {\n                    tokens.add(opt);\n                    if (pos != -1) {\n                        tokens.add(token.substring(pos + 1));\n                    }\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                tokens.add(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                if (token.length() == 2)\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                else if (options.hasOption(token))\n                {\n                    tokens.add(token);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token);\n            }\n            else\n            {\n                tokens.add(token);\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }",
    "fixed_lines": "                int pos = token.indexOf('=');\n                String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\n                if (!options.hasOption(opt) && stopAtNonOption)\n                    process(token);\n                    tokens.add(opt);\n                    if (pos != -1) {\n                        tokens.add(token.substring(pos + 1));\n                    }",
    "masked_code": "    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            String token = (String) iter.next();\n\n            // handle long option --foo or --foo=bar\n            if (token.startsWith(\"--\"))\n            {\n                {\n                }\n                else\n                {\n>>> [ INFILL ] <<<\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                tokens.add(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                if (token.length() == 2)\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                else if (options.hasOption(token))\n                {\n                    tokens.add(token);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token);\n            }\n            else\n            {\n                tokens.add(token);\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }",
    "project": "Cli",
    "test_error_message": "junit.framework.AssertionFailedError: Confirm 3 extra args: 7",
    "test_framework": "defects4j",
    "test_line": "        assertTrue(\"Confirm  3 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 3);",
    "test_name": "testStop3",
    "test_suite": "org.apache.commons.cli.PosixParserTest",
    "time_buggy": "2008-07-28 08:43:28 +0000",
    "time_fixed": "2008-07-28 09:47:05 +0000",
    "bug_description": "Bug ID: 20\nProject: Cli\nBug Type: Statement Fault (SF)\n\nThe error is related to junit.framework.AssertionFailedError: Confirm 3 extra args: 7, indicating that an assertion failed because an incorrect number of arguments were confirmed.\n\nDescription:\n\nThis bug is found in the \"flatten\" function of the Cli project. This function is supposed to flatten or reconcile command line options provided in the \"arguments\" array with the available options provided in the \"options\" object.\n\nIn the buggy code, if a command-line token starts with \"--\" and contains an \"=\" sign, the system attempts to separate the token into two parts: token part before \"=\" and token part after \"=\", and then add them to the token list. \n\nSteps Leading to Bug:\n\n1. In the function, an iterator is created for the command line tokens/arguments.\n2. All command line tokens are processed iteratively.\n3. If a token starts with a double hyphen (--), the program checks if the token includes an \"=\" sign.\n4. If there's an \"=\", the program breaks the token into three sections at the \"=\" character and adds them into the token list.\n5. The bug is at this step. It seems that the token is broken into three sections: token.substring(0, token.indexOf('=')), token.substring(token.indexOf('=') + 1, token.length()), and the whole token.\n\nSolution:\n\nThe fixed code handles the long option (--foo=bar) more properly. If a token contains \"=\", it does not add the whole token into the token list, but instead, takes only part following the \"=\" sign and adds the two parts into the token list, ensuring that an appropriate number of arguments reach the token list. Also, it verifies if the the option before \"=\" is valid by checking the 'options' object before adding it to the list which was missing in the buggy code. \n\nTherefore, in this scenario, the bug was caused due to the lack of proper token segmentation and validation, leading to the inflation of the token list with unnecessary and incorrect elements."
}