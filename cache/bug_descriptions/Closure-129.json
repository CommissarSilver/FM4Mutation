{
    "bug_id": 129,
    "bug_type": "SH SF",
    "buggy_lines": "",
    "code": "    private void annotateCalls(Node n) {\n      Preconditions.checkState(n.isCall());\n\n      // Keep track of of the \"this\" context of a call.  A call without an\n      // explicit \"this\" is a free call.\n      Node first = n.getFirstChild();\n\n      // ignore cast nodes.\n\n      if (!NodeUtil.isGet(first)) {\n        n.putBooleanProp(Node.FREE_CALL, true);\n      }\n\n      // Keep track of the context in which eval is called. It is important\n      // to distinguish between \"(0, eval)()\" and \"eval()\".\n      if (first.isName() &&\n          \"eval\".equals(first.getString())) {\n        first.putBooleanProp(Node.DIRECT_EVAL, true);\n      }\n    }",
    "fixed_code": "    private void annotateCalls(Node n) {\n      Preconditions.checkState(n.isCall());\n\n      // Keep track of of the \"this\" context of a call.  A call without an\n      // explicit \"this\" is a free call.\n      Node first = n.getFirstChild();\n\n      // ignore cast nodes.\n      while (first.isCast()) {\n        first = first.getFirstChild();\n      }\n\n      if (!NodeUtil.isGet(first)) {\n        n.putBooleanProp(Node.FREE_CALL, true);\n      }\n\n      // Keep track of the context in which eval is called. It is important\n      // to distinguish between \"(0, eval)()\" and \"eval()\".\n      if (first.isName() &&\n          \"eval\".equals(first.getString())) {\n        first.putBooleanProp(Node.DIRECT_EVAL, true);\n      }\n    }",
    "fixed_lines": "      while (first.isCast()) {\n        first = first.getFirstChild();\n      }",
    "masked_code": "    private void annotateCalls(Node n) {\n      Preconditions.checkState(n.isCall());\n\n      // Keep track of of the \"this\" context of a call.  A call without an\n      // explicit \"this\" is a free call.\n      Node first = n.getFirstChild();\n\n      // ignore cast nodes.\n>>> [ INFILL ] <<<\n\n      if (!NodeUtil.isGet(first)) {\n        n.putBooleanProp(Node.FREE_CALL, true);\n      }\n\n      // Keep track of the context in which eval is called. It is important\n      // to distinguish between \"(0, eval)()\" and \"eval()\".\n      if (first.isName() &&\n          \"eval\".equals(first.getString())) {\n        first.putBooleanProp(Node.DIRECT_EVAL, true);\n      }\n    }",
    "project": "Closure",
    "test_error_message": "junit.framework.AssertionFailedError:",
    "test_framework": "defects4j",
    "test_line": "    assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +",
    "test_name": "testIssue937",
    "test_suite": "com.google.javascript.jscomp.IntegrationTest",
    "time_buggy": "2013-03-20 09:48:14 -0700",
    "time_fixed": "2013-03-20 09:48:25 -0700",
    "bug_description": "Bug ID: 129\nProject: Closure\nBug Type: Software Harmful (SH) - Software Fault (SF)\nTest Error Message: junit.framework.AssertionFailedError\n\nBug Description:\n\nThe bug in the Closure project is related to handling of cast nodes in the function `annotateCalls()`.\n\nThe purpose of this function is to annotate calls in the program. It processes a Node n which, as per the precondition, must be a call. It tracks the \"this\" context of the call. If a call does not have an explicit \"this\", it is considered a free call.\n\nThe issue arises in the part of the code responsible for ignoring cast nodes. In the buggy version of the code, it simply checks if the first child of the node 'n' is not a \"Get-node\". If the condition does pass, it enters into the 'if' block where it set the FREE_CALL property of the node to 'true'.\n\nThe bug surfaces when the first child node is a cast-node. Since the original code does not account for the possibility of a cast-node being the first child of the node, it doesn't skip the 'if' block and wrongly sets FREE_CALL to 'true'. The test case expecting this situation fails and throws a junit.framework.AssertionFailedError.\n\nIn the fixed version, an additional while-loop is inserted to check if the first child of a node is a cast-node. If it is, it gets its first child and reassigns it as the new 'first'. Hence, it now correctly skips any number of cast nodes until a non-cast node is found, ensuring that the FREE_CALL property doesn't incorrectly set to 'true' when 'first' is a cast-node.\n\nSteps to Generate Similar Java Bugs for Artificial Purposes:\n\n1. Identify a type of node your program is supposed to ignore or handle in a certain way.\n2. Write conditional blocks depending on the desired behavior such as ignoring a certain type of node or performing specific operations when that node is found.\n3. Don't include handling for the ignored node type that may appear as the first child. Hence, when it arises, the program will produce errors because the logic is not being correctly applied to the ignored node type.\n4. Test the code with instances where the first child is an ignored node type. It will lead to assertion errors as the test and actual output will differ.\n5. Fix the bug by correctly handling or bypassing the identified type of node. Test the code to verify it now produces the expected output.\n6. This controlled artificial bug production and fixing process is ideal for developers to understand the lifecycle of a bug and how to correct it."
}