{
    "bug_id": 28,
    "bug_type": "SF",
    "buggy_lines": "",
    "code": "    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        // TODO: Protect from ArrayIndexOutOfBounds\n        if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n            }\n\n            int end = start;\n            while(input.charAt(end) != ';') {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n                return 0;\n            }\n\n                out.write(entityValue);\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }",
    "fixed_code": "    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        // TODO: Protect from ArrayIndexOutOfBounds\n        if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n            }\n\n            int end = start;\n            while(input.charAt(end) != ';') {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n                return 0;\n            }\n\n            if(entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                out.write(entityValue);\n            }\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }",
    "fixed_lines": "            if(entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n            }",
    "masked_code": "    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        // TODO: Protect from ArrayIndexOutOfBounds\n        if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n            }\n\n            int end = start;\n            while(input.charAt(end) != ';') {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n                return 0;\n            }\n\n                out.write(entityValue);\n>>> [ INFILL ] <<<\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }",
    "project": "Lang",
    "test_error_message": "junit.framework.ComparisonFailure: Failed to unescape numeric entities supplementary characters expected:<[\ud803\udc22]> but was:<[\u0c22]>",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(\"Failed to unescape numeric entities supplementary characters\", expected, result);",
    "test_name": "testSupplementaryUnescaping",
    "test_suite": "org.apache.commons.lang3.text.translate.NumericEntityUnescaperTest",
    "time_buggy": "2010-06-22 06:19:29 +0000",
    "time_fixed": "2010-06-22 06:34:18 +0000",
    "bug_description": "Bug ID: 28\nProject: Lang\nBug Type: SF (Software Fault)\n\nDescription:\n\nThe issue originates from the method 'translate' of some class in the Lang project. This method, whose purpose appears to be interpreting and translating character sequences, demonstrates a behavior that deviates from its expected functionality. \n\nThe test error message suggests that the method does not correctly convert or unescape numeric entities supplementary characters. The test expected the unescaped character \ud803\udc22, but it instead received \u0c22.\n\nObserved Failure:\n\nThis exception is of type 'junit.framework.ComparisonFailure', indicating that a comparison assertion in a Junit test case was unsuccessful. Specifically, the method failed to appropriately unescape a specific numeric entity, leading to a mismatch between the expected and actual output.\n\nCode Examination:\n\nUpon examining the original code block, it becomes noticeable that the 'translate' method parses a numeric entity from the input and then writes the corresponding character to the output. However, it ignores the fact that certain entity values correspond not to single characters, but to surrogate pairs in the UTF-16 encoding. \n\nNamely, entityValue is directly converted to a char and written to the Writer output. This method to write to the Writer does not correctly handle characters not encodable in 16 bits (those above the unicode 0xFFFF) that must be represented using surrogate pairs.\n\nFix Implementation:\n\nThe fix involves first checking if the character to write to the Writer is encodable in 16 bits (i.e., less than or equal to 0xFFFF). If this is the case, it is written as a single character. However, if it is not encodable in 16 bits, the character must be represented using a surrogate pair. \n\nThe fixed code therefore includes an additional 'if' statement to implement this check. If the entity value is above 0xFFFF, the character is converted to a char array (which will contain two characters for a valid surrogate pair) and the two characters are written separately to the Writer. Otherwise (if entityValue<=0xFFFF), the entityValue is written as before. \n\nBy treating surrogate pairs appropriately, the software can now correctly handle unescaping of all valid numeric entities."
}