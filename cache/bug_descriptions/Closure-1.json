{
    "bug_id": 1,
    "bug_type": "SH SF",
    "buggy_lines": "",
    "code": "  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // Notice that removing unreferenced function args breaks\n    // Function.prototype.length. In advanced mode, we don't really care\n    // about this: we consider \"length\" the equivalent of reflecting on\n    // the function's lexical source.\n    //\n    // Rather than create a new option for this, we assume that if the user\n    // is removing globals, then it's OK to remove unused function args.\n    //\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n\n    Node function = fnScope.getRootNode();\n\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      // The parameters object literal setters can not be removed.\n      return;\n    }\n\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites\n        && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n      // Strip unreferenced args off the end of the function declaration.\n      Node lastArg;\n      while ((lastArg = argList.getLastChild()) != null) {\n        Var var = fnScope.getVar(lastArg.getString());\n        if (!referenced.contains(var)) {\n          argList.removeChild(lastArg);\n          compiler.reportCodeChange();\n        } else {\n          break;\n        }\n      }\n    } else {\n      callSiteOptimizer.optimize(fnScope, referenced);\n    }\n  }",
    "fixed_code": "  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // Notice that removing unreferenced function args breaks\n    // Function.prototype.length. In advanced mode, we don't really care\n    // about this: we consider \"length\" the equivalent of reflecting on\n    // the function's lexical source.\n    //\n    // Rather than create a new option for this, we assume that if the user\n    // is removing globals, then it's OK to remove unused function args.\n    //\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n    if (!removeGlobals) {\n      return;\n    }\n\n    Node function = fnScope.getRootNode();\n\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      // The parameters object literal setters can not be removed.\n      return;\n    }\n\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites\n        && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n      // Strip unreferenced args off the end of the function declaration.\n      Node lastArg;\n      while ((lastArg = argList.getLastChild()) != null) {\n        Var var = fnScope.getVar(lastArg.getString());\n        if (!referenced.contains(var)) {\n          argList.removeChild(lastArg);\n          compiler.reportCodeChange();\n        } else {\n          break;\n        }\n      }\n    } else {\n      callSiteOptimizer.optimize(fnScope, referenced);\n    }\n  }",
    "fixed_lines": "    if (!removeGlobals) {\n      return;\n    }",
    "masked_code": "  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // Notice that removing unreferenced function args breaks\n    // Function.prototype.length. In advanced mode, we don't really care\n    // about this: we consider \"length\" the equivalent of reflecting on\n    // the function's lexical source.\n    //\n    // Rather than create a new option for this, we assume that if the user\n    // is removing globals, then it's OK to remove unused function args.\n    //\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n>>> [ INFILL ] <<<\n\n    Node function = fnScope.getRootNode();\n\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      // The parameters object literal setters can not be removed.\n      return;\n    }\n\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites\n        && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n      // Strip unreferenced args off the end of the function declaration.\n      Node lastArg;\n      while ((lastArg = argList.getLastChild()) != null) {\n        Var var = fnScope.getVar(lastArg.getString());\n        if (!referenced.contains(var)) {\n          argList.removeChild(lastArg);\n          compiler.reportCodeChange();\n        } else {\n          break;\n        }\n      }\n    } else {\n      callSiteOptimizer.optimize(fnScope, referenced);\n    }\n  }",
    "project": "Closure",
    "test_error_message": "junit.framework.AssertionFailedError:",
    "test_framework": "defects4j",
    "test_line": "      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +",
    "test_name": "testSimpleModeLeavesUnusedParams",
    "test_suite": "com.google.javascript.jscomp.CommandLineRunnerTest",
    "time_buggy": "2013-01-04 21:36:23 +0000",
    "time_fixed": "2013-01-05 01:20:43 +0000",
    "bug_description": "Bug ID: 1\nProject: Closure\nBug Type: Syntax/ Semantic Fault (inferred from \"SH SF\")\n\nBug Location: The bug is located within the 'removeUnreferencedFunctionArgs' method in the function removal code within the Closure compiler project.\n\nBuggy Code Description: \n\nThe underlying issue in the buggy code is that the function 'removeUnreferencedFunctionArgs' proceeds to remove the unused function arguments without checking if the user intended to remove the globals. This may lead to unintended behavior as some unused function arguments may be getting removed even if the user did not want that. \n\nThis can potentially affect the functioning and performance of the application negatively, as the removal of global variables might not always be intended or beneficial. \n\nFixed Code Description: \n\nIn the fixed code, a condition has been added right at the beginning of the 'removeUnreferencedFunctionArgs' method to check if the variable 'removeGlobals' is set to 'false'. If so, the method will simply return without executing any further code. This ensures that the function arguments are not removed unless the 'removeGlobals' variable is set to 'true'. \n\nThe 'removeGlobals' variable likely controls whether global variables should be removed or not. The fixes ensure that the removal of unreferenced function arguments only happens when the 'removeGlobals' is set to true, thus ensuring that the user's choice is respected.\n\nThe bug and its fix relate to understanding the context and the purpose of variables and their implications on the entire project. This bug shows the importance of correctly checking the state and relevancy of variables before proceeding with significant actions such as function argument removal. \n\nAfter the fix, the function behaves as expected and does not remove the unreferenced function arguments if 'removeGlobals' is set to false, thereby preserving the purpose of the original code while mitigating the risk of potential issues."
}