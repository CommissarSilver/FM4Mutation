{
    "bug_id": 5,
    "bug_type": "SH SF",
    "buggy_lines": "            throw new JXPathException(\n                    \"Cannot compare pointers that do not belong to the same tree: '\"\n                            + p1 + \"' and '\" + p2 + \"'\");",
    "code": "    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2) \n    {\n        if (depth1 < depth2) {\n            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n            return r == 0 ? 1 : r;\n        }\n        if (p1 == null && p2 == null) {\n            return 0;\n        }\n\n        if (p1 != null && p1.equals(p2)) {\n            return 0;\n        }\n\n        if (depth1 == 1) {\n            throw new JXPathException(\n                    \"Cannot compare pointers that do not belong to the same tree: '\"\n                            + p1 + \"' and '\" + p2 + \"'\");\n        }\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n        if (r != 0) {\n            return r;\n        }\n\n        return p1.parent.compareChildNodePointers(p1, p2);\n    }",
    "fixed_code": "    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2) \n    {\n        if (depth1 < depth2) {\n            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n            return r == 0 ? 1 : r;\n        }\n        if (p1 == null && p2 == null) {\n            return 0;\n        }\n\n        if (p1 != null && p1.equals(p2)) {\n            return 0;\n        }\n\n        if (depth1 == 1) {\n            return 0;\n        }\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n        if (r != 0) {\n            return r;\n        }\n\n        return p1.parent.compareChildNodePointers(p1, p2);\n    }",
    "fixed_lines": "            return 0;",
    "masked_code": "    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2) \n    {\n        if (depth1 < depth2) {\n            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n            return r == 0 ? 1 : r;\n        }\n        if (p1 == null && p2 == null) {\n            return 0;\n        }\n\n        if (p1 != null && p1.equals(p2)) {\n            return 0;\n        }\n\n        if (depth1 == 1) {\n>>> [ INFILL ] <<<\n        }\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n        if (r != 0) {\n            return r;\n        }\n\n        return p1.parent.compareChildNodePointers(p1, p2);\n    }",
    "project": "JxPath",
    "test_error_message": "org.apache.commons.jxpath.JXPathException: Cannot compare pointers that do not belong to the same tree: '' and '$var'",
    "test_framework": "defects4j",
    "test_line": "        for (Iterator ptrs = context.iteratePointers(\"$var | /MAIN/A\"); ptrs.hasNext(); sz++) {",
    "test_name": "testUnionOfVariableAndNode",
    "test_suite": "org.apache.commons.jxpath.ri.compiler.VariableTest",
    "time_buggy": "2007-06-21 22:21:21 +0000",
    "time_fixed": "2007-07-02 20:47:47 +0000",
    "bug_description": "Bug ID: 5\nProject: JxPath\nBug Type: Semantic/ Syntactic Fault (SH SF)\n\nDescription:\n\n1. The issue is present within the \"compareNodePointers\" method of the JxPath project.\n\n2. The function is supposed to compare two 'NodePointer' objects, p1 and p2, by taking their respective depths into account - depth1 and depth2.\n\n3. The bug surfaces when the depth1 variable equals to 1. At this stage, the original code throws a JXPathException error. This happens due to an oversight in handling when pointers do not belong to the same tree.\n\n    Original Buggy Line:\n            if (depth1 == 1) {\n                throw new JXPathException(\n                        \"Cannot compare pointers that do not belong to the same tree: '\"\n                                + p1 + \"' and '\" + p2 + \"'\");\n            }\n\n4. The exception message states: \"Cannot compare pointers that do not belong to the same tree: '' and '$var'\". This actually reveals the root of the problem - the pointers are not being catered for correctly when they belong to different trees.\n\n5. To fix this bug, instead of throwing an exception when depth1 equals 1, we return 0. This is based on the precedent set elsewhere in the same method, mainly when p1 is null and p2 is null, or, also, when p1 is not null and equals p2.\n\n    Fixed Line is: \n            if (depth1 == 1) {\n                return 0;\n            }\n\n5. With this fix, the system no longer throws an error falsely whenever it encounters pointers from different trees, allowing the system to run more robustly.\n\nIn conclusion, this bug stemmed from an oversight in the logic of the \"compareNodePointers\" function when comparing pointers from different trees. Correcting this resulted in an improved, error-free performance of the function."
}