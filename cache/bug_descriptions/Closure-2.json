{
    "bug_id": 2,
    "bug_type": "SF",
    "buggy_lines": "",
    "code": "  private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n      String functionName, HashMap<String, ObjectType> properties,\n      HashMap<String, ObjectType> currentProperties,\n      ObjectType interfaceType) {\n    ObjectType implicitProto = interfaceType.getImplicitPrototype();\n    Set<String> currentPropertyNames;\n      // This can be the case if interfaceType is proxy to a non-existent\n      // object (which is a bad type annotation, but shouldn't crash).\n      currentPropertyNames = implicitProto.getOwnPropertyNames();\n    for (String name : currentPropertyNames) {\n      ObjectType oType = properties.get(name);\n      if (oType != null) {\n        if (!interfaceType.getPropertyType(name).isEquivalentTo(\n            oType.getPropertyType(name))) {\n          compiler.report(\n              t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n                  functionName, name, oType.toString(),\n                  interfaceType.toString()));\n        }\n      }\n      currentProperties.put(name, interfaceType);\n    }\n    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n      checkInterfaceConflictProperties(t, n, functionName, properties,\n          currentProperties, iType);\n    }\n  }",
    "fixed_code": "  private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n      String functionName, HashMap<String, ObjectType> properties,\n      HashMap<String, ObjectType> currentProperties,\n      ObjectType interfaceType) {\n    ObjectType implicitProto = interfaceType.getImplicitPrototype();\n    Set<String> currentPropertyNames;\n    if (implicitProto == null) {\n      // This can be the case if interfaceType is proxy to a non-existent\n      // object (which is a bad type annotation, but shouldn't crash).\n      currentPropertyNames = ImmutableSet.of();\n    } else {\n      currentPropertyNames = implicitProto.getOwnPropertyNames();\n    }\n    for (String name : currentPropertyNames) {\n      ObjectType oType = properties.get(name);\n      if (oType != null) {\n        if (!interfaceType.getPropertyType(name).isEquivalentTo(\n            oType.getPropertyType(name))) {\n          compiler.report(\n              t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n                  functionName, name, oType.toString(),\n                  interfaceType.toString()));\n        }\n      }\n      currentProperties.put(name, interfaceType);\n    }\n    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n      checkInterfaceConflictProperties(t, n, functionName, properties,\n          currentProperties, iType);\n    }\n  }",
    "fixed_lines": "    if (implicitProto == null) {\n      currentPropertyNames = ImmutableSet.of();\n    } else {\n    }",
    "masked_code": "  private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n      String functionName, HashMap<String, ObjectType> properties,\n      HashMap<String, ObjectType> currentProperties,\n      ObjectType interfaceType) {\n    ObjectType implicitProto = interfaceType.getImplicitPrototype();\n    Set<String> currentPropertyNames;\n      // This can be the case if interfaceType is proxy to a non-existent\n      // object (which is a bad type annotation, but shouldn't crash).\n      currentPropertyNames = implicitProto.getOwnPropertyNames();\n>>> [ INFILL ] <<<\n    for (String name : currentPropertyNames) {\n      ObjectType oType = properties.get(name);\n      if (oType != null) {\n        if (!interfaceType.getPropertyType(name).isEquivalentTo(\n            oType.getPropertyType(name))) {\n          compiler.report(\n              t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n                  functionName, name, oType.toString(),\n                  interfaceType.toString()));\n        }\n      }\n      currentProperties.put(name, interfaceType);\n    }\n    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n      checkInterfaceConflictProperties(t, n, functionName, properties,\n          currentProperties, iType);\n    }\n  }",
    "project": "Closure",
    "test_error_message": "java.lang.NullPointerException",
    "test_framework": "defects4j",
    "test_line": "    makeTypeCheck().processForTesting(null, n);",
    "test_name": "testBadInterfaceExtendsNonExistentInterfaces",
    "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
    "time_buggy": "2012-12-21 22:48:30 +0000",
    "time_fixed": "2012-12-22 00:16:42 +0000",
    "bug_description": "Bug Description:\n\nBug ID: 2\n\nBug Type: Code Smell (SF)\n\nApplication/Module: Closure\n\nComponent: checkInterfaceConflictProperties\n\nSummary: Issue caused by a NullPointerException due to a missing null check before calling a method on an object\n\nTechnologies and/or Libraries used: Java, HashMap, ObjectTypes, ImmutableSet\n\nDetails:\n\nThe reported issue is present in the checkInterfaceConflictProperties function where a NullPointerException is being thrown. The central cause of the issue in the code seems to be associated with the variable \"implicitProto\". The code fails to consider a scenario where this could be null and directly attempts to call a method upon it, leading to the encountered exception.\n\nThis error happens at the line: currentPropertyNames = implicitProto.getOwnPropertyNames();\n\nThe correction is to include a null check before calling the function getOwnPropertyNames() on the implicitProto. If implicitProto is null, we assign an ImmutableSet.of() to the currentPropertyNames. If it is not null, we assign implicitProto.getOwnPropertyNames() to the currentPropertyNames.\n\nThis handled scenario prevents the NullPointerException from occurring and allows the function to proceed its process without crashing.\n\nUpon applying the fix, the code does not crash when executing the function with an interfaceType that has a non-existent implicit prototype. \n\nThe developer needs to validate this fix by executing various scenario test cases and ensuring that the NullPointerException does not occur again in other related parts of the code.\n\nIn conclusion, always ensure to add null checks when calling methods from an object to prevent the occurrence of a NullPointerException."
}