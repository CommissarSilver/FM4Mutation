{
    "bug_id": 22,
    "bug_type": "SF",
    "buggy_lines": "        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {",
    "code": "    private static int greatestCommonDivisor(int u, int v) {\n        // From Commons Math:\n        //if either operand is abs 1, return 1:\n        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n            return 1;\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        if (u>0) { u=-u; } // make u negative\n        if (v>0) { v=-v; } // make v negative\n        // B1. [Find power of 2]\n        int k=0;\n        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n            u/=2; v/=2; k++; // cast out twos.\n        }\n        if (k==31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        //     one is odd.\n        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t&1)==0) { // while t is even..\n                t/=2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t>0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u)/2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t!=0);\n        return -u*(1<<k); // gcd is u*2^k\n    }",
    "fixed_code": "    private static int greatestCommonDivisor(int u, int v) {\n        // From Commons Math:\n        if ((u == 0) || (v == 0)) {\n            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n                throw new ArithmeticException(\"overflow: gcd is 2^31\");\n            }\n            return Math.abs(u) + Math.abs(v);\n        }\n        //if either operand is abs 1, return 1:\n        if (Math.abs(u) == 1 || Math.abs(v) == 1) {\n            return 1;\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        if (u>0) { u=-u; } // make u negative\n        if (v>0) { v=-v; } // make v negative\n        // B1. [Find power of 2]\n        int k=0;\n        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n            u/=2; v/=2; k++; // cast out twos.\n        }\n        if (k==31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        //     one is odd.\n        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t&1)==0) { // while t is even..\n                t/=2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t>0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u)/2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t!=0);\n        return -u*(1<<k); // gcd is u*2^k\n    }",
    "fixed_lines": "        if ((u == 0) || (v == 0)) {\n            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n                throw new ArithmeticException(\"overflow: gcd is 2^31\");\n            }\n            return Math.abs(u) + Math.abs(v);\n        }\n        if (Math.abs(u) == 1 || Math.abs(v) == 1) {",
    "masked_code": "    private static int greatestCommonDivisor(int u, int v) {\n        // From Commons Math:\n        //if either operand is abs 1, return 1:\n>>> [ INFILL ] <<<\n            return 1;\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        if (u>0) { u=-u; } // make u negative\n        if (v>0) { v=-v; } // make v negative\n        // B1. [Find power of 2]\n        int k=0;\n        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n            u/=2; v/=2; k++; // cast out twos.\n        }\n        if (k==31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        //     one is odd.\n        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t&1)==0) { // while t is even..\n                t/=2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t>0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u)/2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t!=0);\n        return -u*(1<<k); // gcd is u*2^k\n    }",
    "project": "Lang",
    "test_error_message": "junit.framework.AssertionFailedError: expected:<-1073741824> but was:<-2147483648>",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(Integer.MIN_VALUE / 2, f.getNumerator());",
    "test_name": "testReducedFactory_int_int",
    "test_suite": "org.apache.commons.lang3.math.FractionTest",
    "time_buggy": "2011-01-17 04:12:36 +0000",
    "time_fixed": "2011-01-17 04:30:05 +0000",
    "bug_description": "Bug ID: 22\nProject: Lang\nBug Type: Semantic Failure (SF)\n\nIn the original buggy code, an issue arises in the 'greatestCommonDivisor' function where it doesn't properly handle the scenario of either 'u' or 'v' being 0 or the absolute minimum integer value. Consequently, this causes the test to fail as the expected and actual results do not align. \n\nDetailed Description:\n\n1. The function 'greatestCommonDivisor' takes in two integer variables 'u' and 'v' as parameters. \n\n2. The code then checks if the absolute value of either 'u' or 'v' is less than or equal to 1. If true, the function early returns 1. This part of the code is the origin of the bug as the exhaustion of all possibilities was not considered. \n\n3. Converting this code to check if either 'u' or 'v' is 0 and if they equate to the minimum integer value could handle this exception. \n\nError Message: \njunit.framework.AssertionFailedError: expected:<-1073741824> but was:<-2147483648>.\n\n4. The error message indicates that the return value from the failing test case was -2147483648 (which is the value of Integer.MIN_VALUE), yet the expected value was -1073741824.\n\n5. The error stems from the check for the absolute value of 'u' and 'v' being less than or equal to 1, which does not account for the scenario of the value(s) being 0 or Integer.MIN_VALUE.\n\nFix:\n\n6. The fix in the code involves adding a check at the start of the function for if either 'u' or 'v' is 0.\n\n7. Following this, a further check is made to see if 'u' or 'v' equals the Integer.MIN_VALUE. If either of these checks are true, an ArithmeticException is thrown with the appropriate error message.\n\n8. If neither 'u' nor 'v' are 0, then the absolute value of both 'u' and 'v' are returned. \n\n9. The condition for returning 1 has been adjusted. The function now returns 1 if the absolute value of either 'u' or 'v' equals 1; not less than or equal to 1, as was previously the case.\n\nBy implementing these changes within the given method, the bug was addressed and the function now handles all edge cases appropriately."
}