{
    "bug_id": 24,
    "bug_type": "SF",
    "buggy_lines": "        }",
    "code": "    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        int type = n.getType();\n        Node parent = n.getParent();\n        if (parent.isVar()) {\n          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n          String name = n.getString();\n          Var aliasVar = scope.getVar(name);\n          aliases.put(name, aliasVar);\n\n          String qualifiedName =\n              aliasVar.getInitialValue().getQualifiedName();\n          transformation.addAlias(name, qualifiedName);\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else {\n          // TODO(robbyw): Support using locals for private variables.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n        }\n      }\n    }",
    "fixed_code": "    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        int type = n.getType();\n        Node parent = n.getParent();\n        if (parent.isVar() &&\n            n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n          String name = n.getString();\n          Var aliasVar = scope.getVar(name);\n          aliases.put(name, aliasVar);\n\n          String qualifiedName =\n              aliasVar.getInitialValue().getQualifiedName();\n          transformation.addAlias(name, qualifiedName);\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else {\n          // TODO(robbyw): Support using locals for private variables.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }",
    "fixed_lines": "        } else if (v.isBleedingFunction()) {\n        } else if (parent.getType() == Token.LP) {",
    "masked_code": "    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        int type = n.getType();\n        Node parent = n.getParent();\n          String name = n.getString();\n          Var aliasVar = scope.getVar(name);\n          aliases.put(name, aliasVar);\n\n          String qualifiedName =\n              aliasVar.getInitialValue().getQualifiedName();\n          transformation.addAlias(name, qualifiedName);\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else {\n          // TODO(robbyw): Support using locals for private variables.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n>>> [ INFILL ] <<<\n      }\n    }",
    "project": "Closure",
    "test_error_message": "junit.framework.AssertionFailedError: There should be one error. expected:<1> but was:<0>",
    "test_framework": "defects4j",
    "test_line": "    test(\"goog.scope(function() {\" + code + \"});\", null, expectedError);",
    "test_name": "testNonAliasLocal",
    "test_suite": "com.google.javascript.jscomp.ScopedAliasesTest",
    "time_buggy": "2012-05-23 16:49:41 +0000",
    "time_fixed": "2012-05-24 15:54:23 +0000",
    "bug_description": "Bug ID: 24\n\nProject: Closure\n\nBug Type: SF (Statement Fault)\n\nTest Error Message: junit.framework.AssertionFailedError: There should be one error. expected:<1> but was:<0>\n\n1. Bug Overview:\nThe bug was identified in the 'findAliases' method, of the Closure project. This method is intended to find aliases by traversing nodes. The JUnit test associated with this method failed due to some Assertion Error. It was expecting one error while processing but it ended up with no errors. The assertion error shows that the bug is related to some logical flaw in the code, causing the test to fail.\n\n2. Detailed Bug Description:\nThe erroneous code has a block of if and else code. According to the 'if' condition, it inspects if the parent is a variable and the current node has children and the first child is a qualified name. If the condition is satisfied, the logic to add alias is implemented. But there is no further specified conditions for other probable situations. It simply sends an error message that non-alias locals are unsupported. This might be producing the error as some other conditions are not handled properly and that is why there occurred no error when it was expected.\n\n3. Bug Replication:\nTo reproduce the error, the specific method 'findAliases' needs to be called. Case would be where  there is a situation other than having the parent as a variable and the first child being a qualified name, which is not handled by the faulty code. The error was identified by the failing JUnit test, which expected an error to occur during processing but ended up having no such error.\n\n4. Bug Fix:\nThe fixed code is updated with specific conditions to handle the other probable cases including when 'v' is a bleeding function or the parent type is LP(Token). Now it is altered such that it doesn't raise a 'BAD_PARAMETERS' error in these cases. Additionally, the block for adding alias is moved inside the 'if' condition ensuring it will not be included in other conditions. Rest of the codeblock remains the same. \n\n5. Testing After Bug Fix:\nAfter the bug fix, the method should be tested again with the same input parameters to ensure that the assertion error does not occur, and that the expected error is thrown when those specific conditions are met. \n\n6. Concluding Note:\nThis bug was essentially a statement fault, possibly due to unhandled conditions in the code. The fix introduced a proper condition based logic to handle certain situations which were not initially taken into account, leading to the error."
}