{
    "bug_id": 19,
    "bug_type": "SL SH SF",
    "buggy_lines": "        } else if (offsetLocal > 0) {",
    "code": "    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal > 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }",
    "fixed_code": "    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal >= 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }",
    "fixed_lines": "        } else if (offsetLocal >= 0) {",
    "masked_code": "    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n>>> [ INFILL ] <<<\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }",
    "project": "Time",
    "test_error_message": "junit.framework.ComparisonFailure: expected:<...1-10-30T01:15:00.000[+01:00]> but was:<...1-10-30T01:15:00.000[Z]>",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(\"2011-10-30T01:15:00.000+01:00\", base.toString());",
    "test_name": "testDateTimeCreation_london",
    "test_suite": "org.joda.time.TestDateTimeZoneCutover",
    "time_buggy": "2011-10-23 13:07:54 +0100",
    "time_fixed": "2011-10-24 00:16:21 +0100",
    "bug_description": "Bug ID: 19\nProject: Time\n\nDescription: \nThe bug is of type SL SH SF and is located in the 'getOffsetFromLocal' method of the 'Time' project. Specifically, it lies at the line that contains the condition `} else if (offsetLocal > 0) {`.\n\nThe method 'getOffsetFromLocal()' was initially written to calculate the offset from the local time. However, there is a discrepancy noticed for the cases where the offsetLocal was exactly zero, where the buggy line of code led to an inaccurate time calculation.\n\nError Message: \nThe bug was detected by a JUnit test case which yielded a 'junit.framework.ComparisonFailure'. The error occurred when expected and actual results did not match. The error message detail is 'expected:<...1-10-30T01:15:00.000[+01:00]> but was:<...1-10-30T01:15:00.000[Z]>', indicating that there was an issue with timestamp comparison that led to this test case failure.\n\nResolution: \nThe condition at the bug point was altered from `} else if (offsetLocal > 0) {` to `} else if (offsetLocal >= 0) {` in the fixed code. The change ensures that even for the case when the offsetLocal equates to zero, the condition becomes true and the respective 'if' block properly executes. This consideration fixed the failing test case without affecting the functionality of other parts of the code.\n\nSteps for Simulating:\n1. Developers can create a scenario where getOffset() method call results in a zero offsetLocal.\n2. Utilize JUnit or similar unit testing suite to assert and compare the actual output value of 'getOffsetFromLocal()' with the expected output.\n3. Include edge case scenarios where the offsetLocal is exactly zero.\n4. Observe the failing test case and correct the implementation to include the zero offsetLocal scenario described in the 'Resolution'.\n\nIt is a common tendency to overlook 'edge cases' like when offsetLocal exactly equates to zero which could lead to the generation of such bugs. It is suggested to always take into account all possible values that a variable can adopt and how these values would behave in different scenarios."
}