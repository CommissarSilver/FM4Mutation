{
    "bug_id": 1,
    "bug_type": "SL SH SF",
    "buggy_lines": "        if (dataset != null) {",
    "code": "    public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n        if (dataset != null) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }",
    "fixed_code": "    public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n        if (dataset == null) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }",
    "fixed_lines": "        if (dataset == null) {",
    "masked_code": "    public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n>>> [ INFILL ] <<<\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }",
    "project": "Chart",
    "test_error_message": "junit.framework.AssertionFailedError: expected:<1> but was:<0>",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(1, lic.getItemCount());",
    "test_name": "test2947660",
    "test_suite": "org.jfree.chart.renderer.category.junit.AbstractCategoryItemRendererTests",
    "time_buggy": "2010-01-19 23:25:06 -0800 ",
    "time_fixed": "2010-02-09 13:23:49 -0800 ",
    "bug_description": "Bug ID: 1\nProject: Chart\nBug Type: SL SH SF (Single-line change, statement hierarchy change, statement content change)\n\nBug Description:\nThe issue lies in the code of the \"getLegendItems()\" method in which the validation code for \"dataset\" variable incorrectly returns a result when the dataset has a valid reference.\n\nSteps to Identify the Bug:\n\nStep 1: Start by examining the provided error message: junit.framework.AssertionFailedError: expected:<1> but was:<0>. This suggests that there might be an error with return values or condition checking in one of the methods.\n\nStep 2: Review the method where the reported error has occurred - \"public LegendItemCollection getLegendItems() {\".\n\nStep 3: The error seems to occur at this condition check in the code -\n\"if (dataset != null) {\n  return result; \n}\". Here, a new LegendItemCollection is created and returned if the variable \"dataset\" is not null.\n\nStep 4: However, this is incorrect because the code beneath this condition check is never run if \"dataset\" is, indeed, not null. Which means, even if the dataset variable has a valid reference (not null), the method returns an empty LegendItemCollection(), which logically doesn't seem to be the correct behavior.\n\nSteps to Resolve the Bug:\n\nStep 1: The error can be fixed by ensuring that the condition checks if dataset is null, instead of if it is not null.\n\nStep 2: In the bug fix provided, the condition is correctly changed to\n\"if (dataset == null) {\n  return result;\n}\". \n\nNow, if the variable \"dataset\" is null, an empty LegendItemCollection is returned, and if it is not null, the method continues to execute the subsequent lines of code, which involve adding items from the dataset into the result object. Therefore, unless the dataset is null, the code no longer returns an empty LegendItemCollection. \n\nIn conclusion, reviewing the expected functions of our conditions and then testing to ensure they work as expected can help catch these types of bugs. This bug represents an instance where the code was written in a way that goes against the logical expectations of the method."
}