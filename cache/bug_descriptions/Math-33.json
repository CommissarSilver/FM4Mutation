{
    "bug_id": 33,
    "bug_type": "SL SH SF",
    "buggy_lines": "            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {",
    "code": "    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n        columnsToDrop.add(0);\n\n        // positive cost non-artificial variables\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n            final double entry = tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }\n        }\n\n        // non-basic artificial variables\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int col = i + getArtificialVariableOffset();\n          if (getBasicRow(col) == null) {\n            columnsToDrop.add(col);\n          }\n        }\n\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n        for (int i = 1; i < getHeight(); i++) {\n          int col = 0;\n          for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n              matrix[i - 1][col++] = tableau.getEntry(i, j);\n            }\n          }\n        }\n\n        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n          columnLabels.remove((int) columnsToDrop.get(i));\n        }\n\n        this.tableau = new Array2DRowRealMatrix(matrix);\n        this.numArtificialVariables = 0;\n    }",
    "fixed_code": "    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n        columnsToDrop.add(0);\n\n        // positive cost non-artificial variables\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n            final double entry = tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0d, epsilon) > 0) {\n                columnsToDrop.add(i);\n            }\n        }\n\n        // non-basic artificial variables\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int col = i + getArtificialVariableOffset();\n          if (getBasicRow(col) == null) {\n            columnsToDrop.add(col);\n          }\n        }\n\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n        for (int i = 1; i < getHeight(); i++) {\n          int col = 0;\n          for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n              matrix[i - 1][col++] = tableau.getEntry(i, j);\n            }\n          }\n        }\n\n        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n          columnLabels.remove((int) columnsToDrop.get(i));\n        }\n\n        this.tableau = new Array2DRowRealMatrix(matrix);\n        this.numArtificialVariables = 0;\n    }",
    "fixed_lines": "            if (Precision.compareTo(entry, 0d, epsilon) > 0) {",
    "masked_code": "    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n        columnsToDrop.add(0);\n\n        // positive cost non-artificial variables\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n            final double entry = tableau.getEntry(0, i);\n>>> [ INFILL ] <<<\n                columnsToDrop.add(i);\n            }\n        }\n\n        // non-basic artificial variables\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int col = i + getArtificialVariableOffset();\n          if (getBasicRow(col) == null) {\n            columnsToDrop.add(col);\n          }\n        }\n\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n        for (int i = 1; i < getHeight(); i++) {\n          int col = 0;\n          for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n              matrix[i - 1][col++] = tableau.getEntry(i, j);\n            }\n          }\n        }\n\n        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n          columnLabels.remove((int) columnsToDrop.get(i));\n        }\n\n        this.tableau = new Array2DRowRealMatrix(matrix);\n        this.numArtificialVariables = 0;\n    }",
    "project": "Math",
    "test_error_message": "junit.framework.AssertionFailedError",
    "test_framework": "defects4j",
    "test_line": "        Assert.assertTrue(Precision.compareTo(solution.getPoint()[0], 0.0d, epsilon) > 0);",
    "test_name": "testMath781",
    "test_suite": "org.apache.commons.math3.optimization.linear.SimplexSolverTest",
    "time_buggy": "2012-05-02 14:24:55 +0000",
    "time_fixed": "2012-05-02 18:28:37 +0000",
    "bug_description": "Bug Description:\nBug ID 33 is located in the 'Math' project. The bug falls under the type SL SH SF, which means it's a 'single line, single hunk, and single file bug'. This bug has caused a 'junit.framework.AssertionFailedError', which is normally due to a failed assertion in JUnit test cases. \n\nThe defective line of code is:\n```\nif (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n```\nIn this line, an incorrect comparison is being made. This part of the code is responsible for comparing the 'entry' value with '0' considering a certain precision represented by 'maxUlps'. If the comparison is greater than '0', it adds 'i' to the list of columns to drop. The comparison made here is incorrect, as a result, the false condition is being triggered.\n\nProposal for Corrective Action:\n\nThe error lies in the use of the variable 'maxUlps' in the 'compareTo' method. If the programmer intended 'maxUlps' to represent epsilon, the uncertainty measurement in mathematical calculations, then it should have been declared as 'epsilon', not 'maxUlps', as 'maxUlps' is typically a specific amount and does not suit the purpose of maintaining precision.\n\nThe corrected line of code should replace 'maxUlps' with 'epsilon':\n```\nif (Precision.compareTo(entry, 0d, epsilon) > 0) {\n```\nThe 'epsilon' variable would act as a control variable for comparing 'entry' with '0'. It means that if the absolute difference between 'entry' and '0' is less than 'epsilon', then they are considered equal.\n\nThis modification will now ensure the program works as expected and the JUnit test cases would pass - fix the 'junit.framework.AssertionFailedError'. In the broader context, this would improve the 'dropPhase1Objective()' function correctly identifies columns to drop from the mathematical table representation."
}