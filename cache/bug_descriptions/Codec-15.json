{
    "bug_id": 15,
    "bug_type": "SF",
    "buggy_lines": "            final char hwChar = str.charAt(index - 1);\n            if ('H' == hwChar || 'W' == hwChar) {\n                final char preHWChar = str.charAt(index - 2);\n                final char firstCode = this.map(preHWChar);\n                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {",
    "code": "    private char getMappingCode(final String str, final int index) {\n        // map() throws IllegalArgumentException\n        final char mappedChar = this.map(str.charAt(index));\n        // HW rule check\n        if (index > 1 && mappedChar != '0') {\n            final char hwChar = str.charAt(index - 1);\n            if ('H' == hwChar || 'W' == hwChar) {\n                final char preHWChar = str.charAt(index - 2);\n                final char firstCode = this.map(preHWChar);\n                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n                    return 0;\n                }\n            }\n        }\n        return mappedChar;\n    }",
    "fixed_code": "    private char getMappingCode(final String str, final int index) {\n        // map() throws IllegalArgumentException\n        final char mappedChar = this.map(str.charAt(index));\n        // HW rule check\n        if (index > 1 && mappedChar != '0') {\n            for (int i=index-1 ; i>=0 ; i--) {\n                final char prevChar = str.charAt(i);\n                if (this.map(prevChar)==mappedChar) {\n                    return 0;\n                }\n                if ('H'!=prevChar && 'W'!=prevChar) {\n                    break;\n                }\n            }\n        }\n        return mappedChar;\n    }",
    "fixed_lines": "            for (int i=index-1 ; i>=0 ; i--) {\n                final char prevChar = str.charAt(i);\n                if (this.map(prevChar)==mappedChar) {\n                if ('H'!=prevChar && 'W'!=prevChar) {\n                    break;\n                }",
    "masked_code": "    private char getMappingCode(final String str, final int index) {\n        // map() throws IllegalArgumentException\n        final char mappedChar = this.map(str.charAt(index));\n        // HW rule check\n        if (index > 1 && mappedChar != '0') {\n                    return 0;\n                }\n>>> [ INFILL ] <<<\n            }\n        }\n        return mappedChar;\n    }",
    "project": "Codec",
    "test_error_message": "junit.framework.AssertionFailedError: expected:<Y3[3]0> but was:<Y3[0]0>",
    "test_framework": "defects4j",
    "test_line": "        Assert.assertEquals(\"Y330\", this.getStringEncoder().encode(\"yhwdyt\"));",
    "test_name": "testHWRuleEx1",
    "test_suite": "org.apache.commons.codec.language.SoundexTest",
    "time_buggy": "2015-03-22 17:32:16 +0000",
    "time_fixed": "2015-03-22 18:48:52 +0000",
    "bug_description": "Bug ID: 15\nProject: Codec\nBug Type: Semantic Fault (SF)\n\nBug Location:\nLines in method getMappingCode() \n    - final char hwChar = str.charAt(index - 1);\n    - if ('H' == hwChar || 'W' == hwChar) {\n    - final char preHWChar = str.charAt(index - 2);\n    - final char firstCode = this.map(preHWChar);\n    - if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n\nDescription:\nThe test error message reveals that the junit.framework.AssertionFailedError was thrown due to an unexpected result produced by the aforementioned lines of the method. The error message shows that there was an assertion failure, where the expected result was \"Y3[3]0\", but the actual result was \"Y3[0]0\".\n\nAfter closely reviewing the buggy code, it appears that the problematic lines are those involved with the so-called \"HW rule check\". The code checks whether the character at the specified index in the input string (`str.charAt(index)`) is either the character 'H' or 'W', and then it maps the preceding character to a particular code.    Unfortunately, the faulty logic misappropriates the character's mapping situation, yielding incorrect results.\n\nThe bug was fixed by slightly altering the logic. Instead of merely checking at fixed positions, the fixed code iterates backwards from the current position to the start of the string. For each character, it maps them and if the mapped character is same as the current position's mapped character, the method returns '0'. Otherwise, if the character is not 'H' or 'W', it breaks the loop. \n\nThe incorrect manipulation and interpretation of 'H' and 'W' as per pre-existing rules and conditions appears to be the cause of the bug. The revisions made in the fixed code is essentially a more accurate and robust paradigm for executing this \"HW rule check\".\n\nSo, this is a Semantic Fault (SF), where the logic and requirements were misunderstood or misinterpreted, leading to incorrect coding. In order to artificially generate a bug like this in Java, simply take a code piece with conditional mapping and checks, then deliberately alter the mapping or checking mechanisms to misinterpret the requirements, creating an incorrect outcome."
}