{
    "bug_id": 11,
    "bug_type": "SF",
    "buggy_lines": "",
    "code": "    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException {\n        if (in == null) {\n            throw new IllegalArgumentException(\"Stream must not be null.\");\n        }\n\n        if (!in.markSupported()) {\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        try {\n            int signatureLength = in.read(signature);\n            in.reset();\n            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n                return new ZipArchiveInputStream(in);\n            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n                return new JarArchiveInputStream(in);\n            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n                return new ArArchiveInputStream(in);\n            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n                return new CpioArchiveInputStream(in);\n            }\n\n            // Dump needs a bigger buffer to check the signature;\n            final byte[] dumpsig = new byte[32];\n            in.mark(dumpsig.length);\n            signatureLength = in.read(dumpsig);\n            in.reset();\n            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n                return new DumpArchiveInputStream(in);\n            }\n\n            // Tar needs an even bigger buffer to check the signature; read the first block\n            final byte[] tarheader = new byte[512];\n            in.mark(tarheader.length);\n            signatureLength = in.read(tarheader);\n            in.reset();\n            if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n                return new TarArchiveInputStream(in);\n            }\n            // COMPRESS-117 - improve auto-recognition\n            try {\n                TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                tais.getNextEntry();\n                return new TarArchiveInputStream(in);\n            } catch (Exception e) { // NOPMD\n                // can generate IllegalArgumentException as well as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            }\n        } catch (IOException e) {\n            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n        }\n\n        throw new ArchiveException(\"No Archiver found for the stream signature\");\n    }",
    "fixed_code": "    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException {\n        if (in == null) {\n            throw new IllegalArgumentException(\"Stream must not be null.\");\n        }\n\n        if (!in.markSupported()) {\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        try {\n            int signatureLength = in.read(signature);\n            in.reset();\n            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n                return new ZipArchiveInputStream(in);\n            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n                return new JarArchiveInputStream(in);\n            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n                return new ArArchiveInputStream(in);\n            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n                return new CpioArchiveInputStream(in);\n            }\n\n            // Dump needs a bigger buffer to check the signature;\n            final byte[] dumpsig = new byte[32];\n            in.mark(dumpsig.length);\n            signatureLength = in.read(dumpsig);\n            in.reset();\n            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n                return new DumpArchiveInputStream(in);\n            }\n\n            // Tar needs an even bigger buffer to check the signature; read the first block\n            final byte[] tarheader = new byte[512];\n            in.mark(tarheader.length);\n            signatureLength = in.read(tarheader);\n            in.reset();\n            if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n                return new TarArchiveInputStream(in);\n            }\n            // COMPRESS-117 - improve auto-recognition\n            if (signatureLength >= 512) {\n            try {\n                TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                tais.getNextEntry();\n                return new TarArchiveInputStream(in);\n            } catch (Exception e) { // NOPMD\n                // can generate IllegalArgumentException as well as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            }\n            }\n        } catch (IOException e) {\n            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n        }\n\n        throw new ArchiveException(\"No Archiver found for the stream signature\");\n    }",
    "fixed_lines": "            }",
    "masked_code": "    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException {\n        if (in == null) {\n            throw new IllegalArgumentException(\"Stream must not be null.\");\n        }\n\n        if (!in.markSupported()) {\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        try {\n            int signatureLength = in.read(signature);\n            in.reset();\n            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n                return new ZipArchiveInputStream(in);\n            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n                return new JarArchiveInputStream(in);\n            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n                return new ArArchiveInputStream(in);\n            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n                return new CpioArchiveInputStream(in);\n            }\n\n            // Dump needs a bigger buffer to check the signature;\n            final byte[] dumpsig = new byte[32];\n            in.mark(dumpsig.length);\n            signatureLength = in.read(dumpsig);\n            in.reset();\n            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n                return new DumpArchiveInputStream(in);\n            }\n\n            // Tar needs an even bigger buffer to check the signature; read the first block\n            final byte[] tarheader = new byte[512];\n            in.mark(tarheader.length);\n            signatureLength = in.read(tarheader);\n            in.reset();\n            if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n                return new TarArchiveInputStream(in);\n            }\n            // COMPRESS-117 - improve auto-recognition\n            try {\n                TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                tais.getNextEntry();\n                return new TarArchiveInputStream(in);\n            } catch (Exception e) { // NOPMD\n                // can generate IllegalArgumentException as well as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            }\n>>> [ INFILL ] <<<\n        } catch (IOException e) {\n            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n        }\n\n        throw new ArchiveException(\"No Archiver found for the stream signature\");\n    }",
    "project": "Compress",
    "test_error_message": "junit.framework.AssertionFailedError: created an input stream for a non-archive",
    "test_framework": "defects4j",
    "test_line": "            fail(\"created an input stream for a non-archive\");",
    "test_name": "shortTextFilesAreNoTARs",
    "test_suite": "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest",
    "time_buggy": "2011-12-22 17:22:19 +0000",
    "time_fixed": "2012-01-29 20:56:50 +0000",
    "bug_description": "Bug ID: #11\nProject: Compress\nBug Type: SF (Software Fault)\n\n1. Bug Overview: \nThe bug in question lies in the Compress project. This project is largely responsible for creating ArchiveInputSteam from an InputStream. The reported bug here is a software malfunction within the logic of the code.\n\n2. Test Error Message: \nThe error message being thrown is \"junit.framework.AssertionFailedError: created an input stream for a non-archive\". It suggests that an InputStream for a non-archive file is being created. \n\n3. Detail Explanation: \nIn the buggy code, an InputStream is processed to create an ArchiveInputStream. The InputStream is first checked for a null, then for mark support, and later multiple archive file signatures (for ZIP, JAR, AR, CPIO, Dump, TAR) are matched. If none is matched, an exception is thrown: \"No Archiver found for the stream signature\". \n\nThe bug occurs in the part where TAR file signature is checked. The issue exists in the TAR auto-recognition phase. According to the buggy version of the code, irrespective of the InputStream's content, an TARArchiveInputStream is attempted to be created which could inadvertently pass an InputStream that is not a TAR archive, thus leading to the error.\n\n4. Bug Fix:\nIn the fixed code, an additional condition is added to check the length of the signature before attempting to create TARArchiveInputStream. This would prevent non-archive Inputstreams to be mistakenly identified as TAR archives. Here, \"signatureLength >= 512\" ensures that there are enough bytes to read from InputStream to prevent erroneous InputStreams from being passed as TAR archives.\n\n5. Step-by-step Bug Manifestation:\n\n    Step 1: The \"createArchiveInputStream\" method is called with non-archive InputStream.\n    Step 2: The InputStream passes the null check and mark support check.\n    Step 3: The InputStream fails to match any archive signatures of ZIP, JAR, AR, CPIO, and Dump.\n    Step 4: During TAR auto-recognition, the InputStream wrongly gets identified as TAR archive without verifying that it has enough length, causing an AssertionFailedError.\n    Step 5: \"Created an input stream for a non-archive\" is thrown due to invalid InputStream being created as TARArchiveInputStream. \n\nNote: To reproduce this bug, you can run the junit test with a non-archive file as input stream for the method 'createArchiveInputStream'.\n\n6. Suggested Test to Prevent Future Occurrences:\nInclude edge case tests where InputStreams of non-archive files are provided to the function and assert that the correct ArchiveException (\"No Archiver found for the stream signature\") is thrown."
}