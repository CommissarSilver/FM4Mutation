{
    "bug_id": 20,
    "bug_type": "SH SF",
    "buggy_lines": "      if (value != null) {",
    "code": "  private Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() &&\n          callTarget.getString().equals(\"String\")) {\n      // Fold String(a) to '' + (a) on immutable literals,\n      // which allows further optimizations\n      //\n      // We can't do this in the general case, because String(a) has\n      // slightly different semantics than '' + (a). See\n      // http://code.google.com/p/closure-compiler/issues/detail?id=759\n      Node value = callTarget.getNext();\n      if (value != null) {\n        Node addition = IR.add(\n            IR.string(\"\").srcref(callTarget),\n            value.detachFromParent());\n        n.getParent().replaceChild(n, addition);\n        reportCodeChange();\n        return addition;\n      }\n    }\n    return n;\n  }",
    "fixed_code": "  private Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() &&\n          callTarget.getString().equals(\"String\")) {\n      // Fold String(a) to '' + (a) on immutable literals,\n      // which allows further optimizations\n      //\n      // We can't do this in the general case, because String(a) has\n      // slightly different semantics than '' + (a). See\n      // http://code.google.com/p/closure-compiler/issues/detail?id=759\n      Node value = callTarget.getNext();\n      if (value != null && value.getNext() == null &&\n          NodeUtil.isImmutableValue(value)) {\n        Node addition = IR.add(\n            IR.string(\"\").srcref(callTarget),\n            value.detachFromParent());\n        n.getParent().replaceChild(n, addition);\n        reportCodeChange();\n        return addition;\n      }\n    }\n    return n;\n  }",
    "fixed_lines": "      if (value != null && value.getNext() == null &&\n          NodeUtil.isImmutableValue(value)) {",
    "masked_code": "  private Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() &&\n          callTarget.getString().equals(\"String\")) {\n      // Fold String(a) to '' + (a) on immutable literals,\n      // which allows further optimizations\n      //\n      // We can't do this in the general case, because String(a) has\n      // slightly different semantics than '' + (a). See\n      // http://code.google.com/p/closure-compiler/issues/detail?id=759\n      Node value = callTarget.getNext();\n>>> [ INFILL ] <<<\n        Node addition = IR.add(\n            IR.string(\"\").srcref(callTarget),\n            value.detachFromParent());\n        n.getParent().replaceChild(n, addition);\n        reportCodeChange();\n        return addition;\n      }\n    }\n    return n;\n  }",
    "project": "Closure",
    "test_error_message": "junit.framework.AssertionFailedError:",
    "test_framework": "defects4j",
    "test_line": "    testSame(\"var a = String('hello', bar());\");",
    "test_name": "testSimpleFunctionCall",
    "test_suite": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest",
    "time_buggy": "2012-06-20 22:35:47 +0000",
    "time_fixed": "2012-06-21 22:45:36 +0000",
    "bug_description": "Bug ID: 20\nProject: Closure\nBug Type: SH SF (Syntax/ Semantic Fault)\nTest Error Message: junit.framework.AssertionFailedError:\n\nBug Description:\n\nThe compiled code snippet showcased above reports an error with the junit.framework.AssertionFailedError. This indicates that a condition that was expected to be true, turned out to be false. The bug essentially manifests itself when the code enters the second \"if\" condition.\n\nBuggy code explanation:\n\nThe initial condition checks if the \"value\" node object is not null. If this condition is met, an addition operation is performed on it. This operation entails replacing the original node, \"n\", with \"addition\". This is done even if there are multiple child nodes under the \"value\" node. No verification is done to determine if \"value\" is the last child node.\n\nFixed code explanation:\n\nThe fixed code also has an added check in the if condition to verify that the retrieved \"value\" node is indeed the last child node. This is done by checking that the next node after \"value\" is null via the method `value.getNext() == null`. This ensures that the program does not presume it is working with a single child node when there are actually more. Additionally, the condition `NodeUtil.isImmutableValue(value)` ensures the immutability of the value, which is important for the `''+(a)` transformation which allows further optimizations. If \"value\" is not an immutable value, the function will terminate prematurely, resulting in the `AssertionFailedError`.\n\nSteps to Replicate and Debug:\n\n1. Run the method `tryFoldSimpleFunctionCall` with a \"n\" Node object with a child node named \"String\" and multiple sub-child nodes. \n2. Observe that the `AssertionFailedError` message is triggered because the code conducts an operation with the first child node but does not check for other child nodes.\n3. To fix this bug, include a condition to verify that there are no sub-child nodes, as seen in the fixed code above.\n4. Run the test again to verify that the updated code now works as expected. The error should no longer occur under the same circumstances."
}