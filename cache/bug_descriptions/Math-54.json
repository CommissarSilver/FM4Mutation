{
    "bug_id": 54,
    "bug_type": "SL SH SF",
    "buggy_lines": "        if (lessThan(getZero())) {",
    "code": "    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        if (lessThan(getZero())) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }",
    "fixed_code": "    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }",
    "fixed_lines": "        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {",
    "masked_code": "    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n>>> [ INFILL ] <<<\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }",
    "project": "Math",
    "test_error_message": "junit.framework.AssertionFailedError: expected:<0.0> but was:<-Infinity>",
    "test_framework": "defects4j",
    "test_line": "        Assert.assertEquals(0.0, field.getZero().toDouble(), MathUtils.SAFE_MIN);",
    "test_name": "testIssue567",
    "test_suite": "org.apache.commons.math.dfp.DfpTest",
    "time_buggy": "2011-05-05 12:37:31 +0000",
    "time_fixed": "2011-05-05 19:41:28 +0000",
    "bug_description": "Bug ID: 54\nProject: Math\nBug Type: Software Logic Syntax & Software Function (SL SH SF)\n\nThis Bug report is regarding a failure observed in a method 'toDouble()' in a math-related programming project, where the expected result was not aligned with the actual result. The test error message reads: junit.framework.AssertionFailedError: expected:<0.0> but was:<-Infinity>. Indicating,  expected execution outcome was to return a value of '0.0', but instead, it produced '-Infinity' as an output.\n\nBug Detailing:\n\n1. The error emerges from flawed logic within if-else decision-making constructs that determine the return values under specific conditions.\n\n2. From the bug report, it seems that the issue lies specifically in one of the conditional checks where it is determined if a number is less than zero. The line in question is isolated under the 'Buggy Lines' header:\n        \"if (lessThan(getZero()))\"\n\n3. However, the method is failing to return zero (0.0) while dealing with zero. Rather, it is producing '-Infinity' as the return value.\n\n    Code Fragment with Bug:\n\n        \"if (lessThan(getZero())) {\n            y = negate();\n            negate = true;\n        }\"\n\n4. Assuming that the 'lessThan()' is a function to compare the calling value with its argument, the condition should internally handle for equality with zero but it doesn't. This causes the function to not properly handle the case when the current instance represents zero.\n\n    The Crux of bug: Instead of returning '0.0' when a zero or negative zero is encountered, it returns '-Infinity'.\n\nRecommended Fix:\n\nThe code should be revised to include a conditional check for equality with zero. If the current instance represents a zero, then in this case, the sign of the zero should be checked. If it's a negative zero, return '-0.0', if it's a positive zero, return '+0.0'.\n\nImplemented Fix in the provided code:\n\n    int cmp0 = compare(this, getZero());\n    if (cmp0 == 0) {\n        return sign < 0 ? -0.0 : +0.0;\n    } else if (cmp0 < 0) {\n        y = negate();\n        negate = true;\n    }\n\nAbove coding allows the method to correctly handle zero and negative zero, returning the expected values and thus resolving the bug."
}