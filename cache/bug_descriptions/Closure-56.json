{
    "bug_id": 56,
    "bug_type": "SF",
    "buggy_lines": "",
    "code": "  public String getLine(int lineNumber) {\n    String js = \"\";\n    try {\n      // NOTE(nicksantos): Right now, this is optimized for few warnings.\n      // This is probably the right trade-off, but will be slow if there\n      // are lots of warnings in one file.\n      js = getCode();\n    } catch (IOException e) {\n      return null;\n    }\n\n    int pos = 0;\n    int startLine = 1;\n\n    // If we've saved a previous offset and it's for a line less than the\n    // one we're searching for, then start at that point.\n    if (lineNumber >= lastLine) {\n      pos = lastOffset;\n      startLine = lastLine;\n    }\n\n    for (int n = startLine; n < lineNumber; n++) {\n      int nextpos = js.indexOf('\\n', pos);\n      if (nextpos == -1) {\n        return null;\n      }\n      pos = nextpos + 1;\n    }\n\n    // Remember this offset for the next search we do.\n    lastOffset = pos;\n    lastLine = lineNumber;\n\n    if (js.indexOf('\\n', pos) == -1) {\n      // If next new line cannot be found, there are two cases\n      // 1. pos already reaches the end of file, then null should be returned\n      // 2. otherwise, return the contents between pos and the end of file.\n        return null;\n    } else {\n      return js.substring(pos, js.indexOf('\\n', pos));\n    }\n  }",
    "fixed_code": "  public String getLine(int lineNumber) {\n    String js = \"\";\n    try {\n      // NOTE(nicksantos): Right now, this is optimized for few warnings.\n      // This is probably the right trade-off, but will be slow if there\n      // are lots of warnings in one file.\n      js = getCode();\n    } catch (IOException e) {\n      return null;\n    }\n\n    int pos = 0;\n    int startLine = 1;\n\n    // If we've saved a previous offset and it's for a line less than the\n    // one we're searching for, then start at that point.\n    if (lineNumber >= lastLine) {\n      pos = lastOffset;\n      startLine = lastLine;\n    }\n\n    for (int n = startLine; n < lineNumber; n++) {\n      int nextpos = js.indexOf('\\n', pos);\n      if (nextpos == -1) {\n        return null;\n      }\n      pos = nextpos + 1;\n    }\n\n    // Remember this offset for the next search we do.\n    lastOffset = pos;\n    lastLine = lineNumber;\n\n    if (js.indexOf('\\n', pos) == -1) {\n      // If next new line cannot be found, there are two cases\n      // 1. pos already reaches the end of file, then null should be returned\n      // 2. otherwise, return the contents between pos and the end of file.\n      if (pos >= js.length()) {\n        return null;\n      } else {\n        return js.substring(pos, js.length());\n      }\n    } else {\n      return js.substring(pos, js.indexOf('\\n', pos));\n    }\n  }",
    "fixed_lines": "      if (pos >= js.length()) {\n      } else {\n        return js.substring(pos, js.length());\n      }",
    "masked_code": "  public String getLine(int lineNumber) {\n    String js = \"\";\n    try {\n      // NOTE(nicksantos): Right now, this is optimized for few warnings.\n      // This is probably the right trade-off, but will be slow if there\n      // are lots of warnings in one file.\n      js = getCode();\n    } catch (IOException e) {\n      return null;\n    }\n\n    int pos = 0;\n    int startLine = 1;\n\n    // If we've saved a previous offset and it's for a line less than the\n    // one we're searching for, then start at that point.\n    if (lineNumber >= lastLine) {\n      pos = lastOffset;\n      startLine = lastLine;\n    }\n\n    for (int n = startLine; n < lineNumber; n++) {\n      int nextpos = js.indexOf('\\n', pos);\n      if (nextpos == -1) {\n        return null;\n      }\n      pos = nextpos + 1;\n    }\n\n    // Remember this offset for the next search we do.\n    lastOffset = pos;\n    lastLine = lineNumber;\n\n    if (js.indexOf('\\n', pos) == -1) {\n      // If next new line cannot be found, there are two cases\n      // 1. pos already reaches the end of file, then null should be returned\n      // 2. otherwise, return the contents between pos and the end of file.\n        return null;\n>>> [ INFILL ] <<<\n    } else {\n      return js.substring(pos, js.indexOf('\\n', pos));\n    }\n  }",
    "project": "Closure",
    "test_error_message": "junit.framework.ComparisonFailure: expected:<foo2:third line> but was:<null>",
    "test_framework": "defects4j",
    "test_line": "    assertEquals(\"foo2:third line\", provider.getSourceLine(\"foo2\", 3));",
    "test_name": "testExceptNoNewLine",
    "test_suite": "com.google.javascript.jscomp.JSCompilerSourceExcerptProviderTest",
    "time_buggy": "2011-08-22 21:35:58 +0000",
    "time_fixed": "2011-08-22 22:18:55 +0000",
    "bug_description": "Bug ID: 56\nProject Name: Closure\nBug Type: SF (Statement Fault - incorrect statement)\n\nTest Error Message:\njunit.framework.ComparisonFailure: expected:<foo2:third line> but was:<null>\n\nBuggy Line:\nThere isn't a specific line provided where the bug exists, however the error message indicates a null return value which points to the issue likely being in the getLine function. \n\nBug Description:\n\nThe bug identified is rooted in the application's inability to correctly handle situations where the requested line is the last line of the string 'js' or there is not a newline character ('\\n') at the end of the string 'js'. This results in the function incorrectly returning null, causing a mismatch between expected and actual returned values. This is flagged by the unit test failure: junit.framework.ComparisonFailure: expected:<foo2:third line> but was:<null>.\n\nIn the following block of code:\n\nif (js.indexOf('\\n', pos) == -1) {\n  // If next new line cannot be found, there are two cases\n  // 1. pos already reaches the end of file, then null should be returned\n  // 2. otherwise, return the contents between pos and the end of file.\n  return null;\n}\n\nThe function runs into an issue where it attempts to find a newline character following 'pos', but if it cannot, it immediately returns null. This does not account for the situation where the text after 'pos' and before the end of the file is the target line.\n\nSteps for Developers to Reproduce the Bug:\n\n1. Run test cases that call the getLine function with the 'lineNumber' variable set to return the last line of the 'js' string, or a line number where the line does not end with a newline character.\n2. Any test case where the expected output includes the final line of 'js' will fail, and instead result in junit.framework.ComparisonFailure with the output: expected:<foo2:third line> but was:<null>.\n\nFixed Code:\n\nIn the fixed code, a check has been added in the previously buggy handler for js.indexOf('\\n', pos) == -1. Now, if the 'pos' variable is greater than or equal to the length of the string 'js' (indicating it's at the end), it still returns null, but otherwise it will now return the remainder of 'js' starting at position 'pos'. It no longer indiscriminately returns null in scenarios where no newline character can be found after 'pos'. This fixes the junit.framework.ComparisonFailure output, ensuring that the last line of text in 'js' or expected lines without a newline character are correctly returned rather than null."
}