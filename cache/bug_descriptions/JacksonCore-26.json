{
    "bug_id": 26,
    "bug_type": "SL SH SF",
    "buggy_lines": "",
    "code": "    public void feedInput(byte[] buf, int start, int end) throws IOException\n    {\n        // Must not have remaining input\n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        // and shouldn't have been marked as end-of-input\n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n        // Time to update pointers first\n        _currInputProcessed += _origBufferLen;\n\n        // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n        _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n        // And then update buffer settings\n        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        _origBufferLen = end - start;\n    }",
    "fixed_code": "    public void feedInput(byte[] buf, int start, int end) throws IOException\n    {\n        // Must not have remaining input\n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        // and shouldn't have been marked as end-of-input\n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n        // Time to update pointers first\n        _currInputProcessed += _origBufferLen;\n\n        // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n        _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n        // And then update buffer settings\n        _currBufferStart = start;\n        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        _origBufferLen = end - start;\n    }",
    "fixed_lines": "        _currBufferStart = start;",
    "masked_code": "    public void feedInput(byte[] buf, int start, int end) throws IOException\n    {\n        // Must not have remaining input\n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        // and shouldn't have been marked as end-of-input\n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n        // Time to update pointers first\n        _currInputProcessed += _origBufferLen;\n\n        // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n        _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n        // And then update buffer settings\n>>> [ INFILL ] <<<\n        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        _origBufferLen = end - start;\n    }",
    "project": "JacksonCore",
    "test_error_message": "junit.framework.AssertionFailedError: expected:<1> but was:<3>",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(1, parser.getCurrentLocation().getByteOffset());",
    "test_name": "testLocationOffsets",
    "test_suite": "com.fasterxml.jackson.core.json.async.AsyncLocationTest",
    "time_buggy": "2019-03-08 21:07:10 -0800",
    "time_fixed": "2019-04-05 20:34:58 -0700",
    "bug_description": "Bug Description:\n\nBug ID: 26\nProject: JacksonCore\nBug Type: Semantic Error (SL SH SF)\n\nDescription:\n\nThis bug is a semantic error in the \"feedInput\" function of the JacksonCore project. \n\n1. Error Symptom:\nThe test cases fail with an AssertionFailedError, expecting a result of '1' but a result of '3' was returned. This shows that feedInput function is not behaving as expected.\n\n2. Possible Cause:\nLooking at the code snippet, it appears that the variable '_currBufferStart' is missing in the original buggy code. The implication is that the shift of bytes from the previous testing or running environment wasn't correctly updated. This likely leads to input data still being read and processed from a wrong or old memory location, which can result in unexpected behavior or inaccurate data processing.\n\n3. Diagnosis & Fix:\nDevelopers should declare the '_currBufferStart' variable and update it along with other buffer settings. This will correctly shift the points of the byte buffer, directing the function to the right memory. The fixed code suggests adding the line of '_currBufferStart = start;' right before assigning the parameter 'buf' to '_inputBuffer'. This effectively corrects the starting point of the buffer, providing accurate references for data input.\n\nSteps to Recreate:\nThis bug likely surfaced during the execution of the 'feedInput' function. Interpret the expected<1> but was <3> error message in the context of this function. If other developers are trying to reproduce or introduce arbitrary Java bugs, similar mismatches can be orchestrated by manipulating functions responsible for controlling data flow or data alignment, such as data feeding, data reading or data interface functions. Changing or skipping critical operations like buffer re-direction, re-initialization or misplacing function calls will generate similar bugs. \n\nIn this case, try to comment out the line where '_currBufferStart = start;' or change the value assignment of '_currBufferStart'. Then, run tests using various input data makes sense according to your program."
}