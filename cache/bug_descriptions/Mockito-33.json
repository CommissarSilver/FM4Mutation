{
    "bug_id": 33,
    "bug_type": "SF",
    "buggy_lines": "        return m1.equals(m2);",
    "code": "    public boolean hasSameMethod(Invocation candidate) {        \n        //not using method.equals() for 1 good reason:\n        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n        \n        \t/* Avoid unnecessary cloning */\n        return m1.equals(m2);\n    }",
    "fixed_code": "    public boolean hasSameMethod(Invocation candidate) {        \n        //not using method.equals() for 1 good reason:\n        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n        \n        if (m1.getName() != null && m1.getName().equals(m2.getName())) {\n        \t/* Avoid unnecessary cloning */\n        \tClass[] params1 = m1.getParameterTypes();\n        \tClass[] params2 = m2.getParameterTypes();\n        \tif (params1.length == params2.length) {\n        \t    for (int i = 0; i < params1.length; i++) {\n        \t\tif (params1[i] != params2[i])\n        \t\t    return false;\n        \t    }\n        \t    return true;\n        \t}\n        }\n        return false;\n    }",
    "fixed_lines": "        if (m1.getName() != null && m1.getName().equals(m2.getName())) {\n        \tClass[] params1 = m1.getParameterTypes();\n        \tClass[] params2 = m2.getParameterTypes();\n        \tif (params1.length == params2.length) {\n        \t    for (int i = 0; i < params1.length; i++) {\n        \t\tif (params1[i] != params2[i])\n        \t\t    return false;\n        \t    }\n        \t    return true;\n        \t}\n        }\n        return false;",
    "masked_code": "    public boolean hasSameMethod(Invocation candidate) {        \n        //not using method.equals() for 1 good reason:\n        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n        \n        \t/* Avoid unnecessary cloning */\n>>> [ INFILL ] <<<\n    }",
    "project": "Mockito",
    "test_error_message": "junit.framework.AssertionFailedError",
    "test_framework": "defects4j",
    "test_line": "        Assert.assertNotNull(((Iterable) iterable).iterator());",
    "test_name": "shouldStubbingWork",
    "test_suite": "org.mockitousage.bugs.InheritedGenericsPolimorphicCallTest",
    "time_buggy": "2010-06-16 11:24:05 +0000",
    "time_fixed": "2010-06-22 05:32:13 +0000",
    "bug_description": "Bug ID: 33\nProject: Mockito\nBug Type: SF (Statement Fault)\n\nBug Description:\n\nThe bug in the Mockito project was encountered in the method \"hasSameMethod()\" of an unknown class. The issue lies in the line of code where the equals() method is being used directly to compare two Method objects, m1 and m2.\n\nThis is problematic because the equals() method checks for exact object equivalence rather than comparing the key properties of the method such as the method name and the parameter types, which are relevant and needed in this context. Due to this, the 'junit.framework.AssertionFailedError' test error message was produced.\n\nBuggy Code:\nreturn m1.equals(m2);\n\nThe test failure can be traced back to the fact that the equals() method does not work as expected in this scenario.\n\nSteps to reproduce:\n1) Two Invocation objects are created such that they have methods which are logically identical, i.e., they have the same method name and parameter types, but they are not the exact same Method objects.\n2) These Invocation objects are passed into the hasSameMethod() method.\n\nHere, instead of returning true as expected due to the logical equivalence of the methods, the flawed code will return false, as the methods being compared are not the exact same objects.\n\nFixed Code:\nThe issue is fixed by comparing the name of the methods using the equals() method and by comparing the parameter types for each method. This is done by looping through the parameters ensuring they match consecutively for both methods. If any parameter doesn't match, it immediately returns false. Otherwise, it returns true confirming that both methods are logically the same.\n\nThe fix concludes that the equals() method should not be used directly to compare the Method objects. Instead, the relevant attributes like method name and parameter types should be compared to determine if two methods are functionally the same."
}