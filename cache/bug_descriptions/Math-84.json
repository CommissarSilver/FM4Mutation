{
    "bug_id": 84,
    "bug_type": "SF",
    "buggy_lines": "",
    "code": "    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // save the original vertex\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            // perform a reflection step\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                // compute the expanded simplex\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // accept the reflected simplex\n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n            if (comparator.compare(contracted, best) < 0) {\n                // accept the contracted simplex\n\n            // check convergence\n                return;\n            }\n\n        }\n\n    }",
    "fixed_code": "    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        final RealConvergenceChecker checker = getConvergenceChecker();\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // save the original vertex\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            // perform a reflection step\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                // compute the expanded simplex\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // accept the reflected simplex\n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n            if (comparator.compare(contracted, best) < 0) {\n                // accept the contracted simplex\n                return;\n            }\n\n            // check convergence\n            final int iter = getIterations();\n            boolean converged = true;\n            for (int i = 0; i < simplex.length; ++i) {\n                converged &= checker.converged(iter, original[i], simplex[i]);\n            }\n            if (converged) {\n                return;\n            }\n\n        }\n\n    }",
    "fixed_lines": "                return;\n            }\n            final int iter = getIterations();\n            boolean converged = true;\n            for (int i = 0; i < simplex.length; ++i) {\n                converged &= checker.converged(iter, original[i], simplex[i]);\n            }\n            if (converged) {",
    "masked_code": "    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // save the original vertex\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            // perform a reflection step\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                // compute the expanded simplex\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // accept the reflected simplex\n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n            if (comparator.compare(contracted, best) < 0) {\n                // accept the contracted simplex\n\n            // check convergence\n>>> [ INFILL ] <<<\n                return;\n            }\n\n        }\n\n    }",
    "project": "Math",
    "test_error_message": "junit.framework.AssertionFailedError",
    "test_framework": "defects4j",
    "test_line": "      Assert.assertTrue(optimizer.getEvaluations() < 150);",
    "test_name": "testMinimizeMaximize",
    "test_suite": "org.apache.commons.math.optimization.direct.MultiDirectionalTest",
    "time_buggy": "2009-08-07 01:16:00 +0000",
    "time_fixed": "2009-08-14 19:23:27 +0000",
    "bug_description": "Bug ID: 84\nProject: Math\nBug Type: Software Failure (SF)\n\nDETAILED DESCRIPTION:\n\n1. ORIGIN:\n   This bug originates from the 'Math' project. It specifically affects the operation of the method 'iterateSimplex' in the codebase.\n\n2. FUNCTIONALITY AFFECTED:\n   The method 'iterateSimplex' aims to perform certain mathematical calculations such as reflection, expansion and contraction of a simplex. But, due to the bug, it fails to properly verify whether the given conditions of operation have been met or not. As such, the bug causes an AssertionFailure Error due to the code running without proper break-points under certain conditions.\n\n3. SYMPTOMS:\n   The bug triggers a Junit assertion failure error, which possibly indicates that the expected conditions are not being met by the code execution, pointing towards a lack of proper logic implementation in the method.\n\n4. BUGGY CODE ANALYSIS:\n   On some occasions, the bug causes the program to enter an infinite loop - a scenario when code lacks appropriate exit conditions and iterates indefinitely. In this case, the while loop in the 'iterateSimplex' function doesn't break as intended in certain conditions. Also, it appears that the method 'iterateSimplex' fails to accept the contracted simplex and to check for convergence, thus allowing the program to proceed without the required conditions being met.\n\n5. FIX:\n   The code fix introduces a new instance of RealConvergenceChecker named 'checker'. After the contraction of simplex, an integer 'iter' is initialized with the number of iterations that have so far been conducted. The code then iterates through elements of simplex, checking their convergence using the 'checker', which eventually breaks the otherwise infinite loop when convergence is achieved.\n\n6. CONCLUSION:\n   Therefore, the problematic behavior of the software was due to the absence of proper check and break conditions in the iterateSimplex method. After the inclusion of the RealConvergenceChecker and applying it to the elements of simplex, the convergence conditions are checked properly, thus fixing the bug.\n\nIn order to reproduce the bug one would need to try and call the 'iterateSimplex' method without having achieving the conditions of convergence, which would lead to an indefinite loop, eventually causing the junit.framework.AssertionFailedError."
}