{
    "bug_id": 94,
    "bug_type": "SL SH SF",
    "buggy_lines": "        if (u * v == 0) {",
    "code": "    public static int gcd(int u, int v) {\n        if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        /* assert u!=0 && v!=0; */\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                            // both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t & 1) == 0) { // while t is even..\n                t /= 2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u) / 2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t != 0);\n        return -u * (1 << k); // gcd is u*2^k\n    }",
    "fixed_code": "    public static int gcd(int u, int v) {\n        if ((u == 0) || (v == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        /* assert u!=0 && v!=0; */\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                            // both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t & 1) == 0) { // while t is even..\n                t /= 2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u) / 2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t != 0);\n        return -u * (1 << k); // gcd is u*2^k\n    }",
    "fixed_lines": "        if ((u == 0) || (v == 0)) {",
    "masked_code": "    public static int gcd(int u, int v) {\n>>> [ INFILL ] <<<\n            return (Math.abs(u) + Math.abs(v));\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        /* assert u!=0 && v!=0; */\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                            // both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t & 1) == 0) { // while t is even..\n                t /= 2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u) / 2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t != 0);\n        return -u * (1 << k); // gcd is u*2^k\n    }",
    "project": "Math",
    "test_error_message": "junit.framework.AssertionFailedError: expected:<98304> but was:<3440640>",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(3 * (1<<15), MathUtils.gcd(3 * (1<<20), 9 * (1<<15)));",
    "test_name": "testGcd",
    "test_suite": "org.apache.commons.math.util.MathUtilsTest",
    "time_buggy": "2009-01-06 03:46:29 +0000",
    "time_fixed": "2009-01-16 23:06:32 +0000",
    "bug_description": "Bug ID: 94\nProject: Math\nBug Type: SL SH SF\n\nDescription:\n\nThe issue lies in the method `gcd(int u, int v)`, specifically at the starting of the code where it validates if the product of `u` and `v` equals 0. If so, it returns the absolute sum of `u` and `v`. \n\nError:\n\nThe error message displays `junit.framework.AssertionFailedError: expected:<98304> but was:<3440640>`. This suggests a failure in validation of the values returned by the `gcd` function.\n\nBuggy Code:\n\nThe buggy line of code is as follows:\n```\nif (u * v == 0) {\n    return (Math.abs(u) + Math.abs(v));\n}\n```\n\nDetailed Problem:\n\nThe problem with the code is that it checks if the product of `u` and `v` is equal to zero to decide if to returns the absolute sum of `u` and `v`. In some scenarios where `u` and `v` are not equal to zero but their product is, due to integer overflow, the condition wrongly validates to true leading to unexpected outcomes.\n\nFixed Code:\n\nThe condition should be changed to `(u == 0) || (v == 0)`. The corrected line of code is:\n```\nif ((u == 0) || (v == 0)) {\n    return (Math.abs(u) + Math.abs(v));\n}\n```\n\nBy modifying the condition to check separately if either `u` or `v` is zero rather than checking if their product is, we can avoid the integer overflow issue. Now, if either `u` or `v` is zero, irrespective of the value of the other, it returns the absolute sum of `u` and `v` as intended. \n\nStep-by-step guide to reproduce the bug:\n\n1. Declare and initialize two variables `u` and `v` such that `u*v` is greater than the maximum int value (i.e., 2^31 - 1), causing an overflow.\n2. Declare and initialize a variable `res` to store the result of the `gcd(int u, int v)` function.\n3. Call the `gcd(int u,int v)` function with `u` and `v` as arguments and store the result in `res`.\n4. Print the value of `res`. It will show the absolute sum of `u` and `v` due to the incorrect condition, whereas it was expected to calculate the greatest common divisor (gcd) of `u` and `v`.\n5. The printed value of `res` will not match the expected result, hence causing the test error message: `junit.framework.AssertionFailedError: expected:<98304> but was:<3440640>`."
}