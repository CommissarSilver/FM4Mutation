{
    "bug_id": 161,
    "bug_type": "SH SF",
    "buggy_lines": "",
    "code": "  private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n    Node parent = n.getParent();\n    // If GETPROP/GETELEM is used as assignment target the array literal is\n    // acting as a temporary we can't fold it here:\n    //    \"[][0] += 1\"\n\n    if (right.getType() != Token.NUMBER) {\n      // Sometimes people like to use complex expressions to index into\n      // arrays, or strings to index into array methods.\n      return n;\n    }\n\n    double index = right.getDouble();\n    int intIndex = (int) index;\n    if (intIndex != index) {\n      error(INVALID_GETELEM_INDEX_ERROR, right);\n      return n;\n    }\n\n    if (intIndex < 0) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    Node elem = left.getFirstChild();\n    for (int i = 0; elem != null && i < intIndex; i++) {\n      elem = elem.getNext();\n    }\n\n    if (elem == null) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    if (elem.getType() == Token.EMPTY) {\n      elem = NodeUtil.newUndefinedNode(elem);\n    } else {\n      left.removeChild(elem);\n    }\n\n    // Replace the entire GETELEM with the value\n    n.getParent().replaceChild(n, elem);\n    reportCodeChange();\n    return elem;\n  }",
    "fixed_code": "  private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n    Node parent = n.getParent();\n    // If GETPROP/GETELEM is used as assignment target the array literal is\n    // acting as a temporary we can't fold it here:\n    //    \"[][0] += 1\"\n    if (isAssignmentTarget(n)) {\n      return n;\n    }\n\n    if (right.getType() != Token.NUMBER) {\n      // Sometimes people like to use complex expressions to index into\n      // arrays, or strings to index into array methods.\n      return n;\n    }\n\n    double index = right.getDouble();\n    int intIndex = (int) index;\n    if (intIndex != index) {\n      error(INVALID_GETELEM_INDEX_ERROR, right);\n      return n;\n    }\n\n    if (intIndex < 0) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    Node elem = left.getFirstChild();\n    for (int i = 0; elem != null && i < intIndex; i++) {\n      elem = elem.getNext();\n    }\n\n    if (elem == null) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    if (elem.getType() == Token.EMPTY) {\n      elem = NodeUtil.newUndefinedNode(elem);\n    } else {\n      left.removeChild(elem);\n    }\n\n    // Replace the entire GETELEM with the value\n    n.getParent().replaceChild(n, elem);\n    reportCodeChange();\n    return elem;\n  }",
    "fixed_lines": "    if (isAssignmentTarget(n)) {\n      return n;\n    }",
    "masked_code": "  private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n    Node parent = n.getParent();\n    // If GETPROP/GETELEM is used as assignment target the array literal is\n    // acting as a temporary we can't fold it here:\n    //    \"[][0] += 1\"\n>>> [ INFILL ] <<<\n\n    if (right.getType() != Token.NUMBER) {\n      // Sometimes people like to use complex expressions to index into\n      // arrays, or strings to index into array methods.\n      return n;\n    }\n\n    double index = right.getDouble();\n    int intIndex = (int) index;\n    if (intIndex != index) {\n      error(INVALID_GETELEM_INDEX_ERROR, right);\n      return n;\n    }\n\n    if (intIndex < 0) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    Node elem = left.getFirstChild();\n    for (int i = 0; elem != null && i < intIndex; i++) {\n      elem = elem.getNext();\n    }\n\n    if (elem == null) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    if (elem.getType() == Token.EMPTY) {\n      elem = NodeUtil.newUndefinedNode(elem);\n    } else {\n      left.removeChild(elem);\n    }\n\n    // Replace the entire GETELEM with the value\n    n.getParent().replaceChild(n, elem);\n    reportCodeChange();\n    return elem;\n  }",
    "project": "Closure",
    "test_error_message": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_INDEX_OUT_OF_BOUNDS_ERROR. Array index out of bounds: NUMBER 1.0 1 [source_file: testcode] at testcode line 1 : 3 expected:<0> but was:<1>",
    "test_framework": "defects4j",
    "test_line": "    testSame(\"[][1] = 1;\");",
    "test_name": "testIssue522",
    "test_suite": "com.google.javascript.jscomp.PeepholeFoldConstantsTest",
    "time_buggy": "2011-08-02 14:59:29 +0000",
    "time_fixed": "2011-08-02 19:34:59 +0000",
    "bug_description": "Bug ID: 161\n\nProject: Closure\n\nBug Type: SH SF\n\nThe bug is identified to affect the 'tryFoldArrayAccess' method within the Closure project. The error is noted to arise due to an array accessing operation that seems to go out of bounds. More specifically, the error throws a 'JSC_INDEX_OUT_OF_BOUNDS_ERROR' and complains about the array index being '1.0' as opposed to the expected '0'. This is in line with the method attempting to fold array elements using a for-loop on instances where the GETPROP/GETELEM operation functions more like a temporary assignment operator, i.e., \"[][0] += 1\". \n\nThe following behavior can be noted for the Buggy Code:\n\n1. When invoked, the 'tryFoldArrayAccess' method accepts three node inputs.\n2. The method starts by acquiring the parent node and checking if the right node type is not a number. In this case, it simply returns the node (n).\n3. However, if it\u2019s a number, the method converts the value to an integer and verifies if it\u2019s still equivalent to the initial double value. If not, an 'INVALID_GETELEM_INDEX_ERROR' is flagged.\n4. Negative index numbers also raise an 'INDEX_OUT_OF_BOUNDS_ERROR'.\n5. Beyond this point, the code proceeds to loop through the elements of the left node's matrix, each time adding one to the index until it reaches the input value.\n6. If an index goes out of bounds (input number large than the array of elements), triggering another 'INDEX_OUT_OF_BOUNDS_ERROR'.\n7. Furthermore, if an element of 'Token.EMPTY' type is found, the method replaces it with an undefined node.\n8. The method eventually replaces GETELEM with the resulting element and reports a code change.\n\nThe Fixed Code introduces an important check that determines whether the node under consideration is indeed functioning as a target for assignment. In such instances, the method simply ignores the request and returns the node (n) as it is. \n\nIn terms of reproducing this bug artificially, one could focus on manipulating the function inputs (right node) or the array construction within the function to generate the eager index errors reported. Also, one might also manipulate the method to not account for the check set by the 'isAssignmentTarget(n)' function, thus reproducing the bug's conditions in the initial code."
}