{
    "bug_id": 5,
    "bug_type": "SF",
    "buggy_lines": "",
    "code": "    protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n    {\n        List<Class<?>> parents = new ArrayList<Class<?>>();\n        parents.add(mixInCls);\n        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n        for (Class<?> mixin : parents) {\n            for (Method m : mixin.getDeclaredMethods()) {\n                if (!_isIncludableMemberMethod(m)) {\n                    continue;\n                }\n                AnnotatedMethod am = methods.find(m);\n                /* Do we already have a method to augment (from sub-class\n                 * that will mask this mixIn)? If so, add if visible\n                 * without masking (no such annotation)\n                 */\n                if (am != null) {\n                    _addMixUnders(m, am);\n                    /* Otherwise will have precedence, but must wait\n                     * until we find the real method (mixIn methods are\n                     * just placeholder, can't be called)\n                     */\n                } else {\n                    // Well, or, as per [Issue#515], multi-level merge within mixins...\n                        mixIns.add(_constructMethod(m));\n                }\n            }\n        }\n    }",
    "fixed_code": "    protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n    {\n        List<Class<?>> parents = new ArrayList<Class<?>>();\n        parents.add(mixInCls);\n        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n        for (Class<?> mixin : parents) {\n            for (Method m : mixin.getDeclaredMethods()) {\n                if (!_isIncludableMemberMethod(m)) {\n                    continue;\n                }\n                AnnotatedMethod am = methods.find(m);\n                /* Do we already have a method to augment (from sub-class\n                 * that will mask this mixIn)? If so, add if visible\n                 * without masking (no such annotation)\n                 */\n                if (am != null) {\n                    _addMixUnders(m, am);\n                    /* Otherwise will have precedence, but must wait\n                     * until we find the real method (mixIn methods are\n                     * just placeholder, can't be called)\n                     */\n                } else {\n                    // Well, or, as per [Issue#515], multi-level merge within mixins...\n                    am = mixIns.find(m);\n                    if (am != null) {\n                        _addMixUnders(m, am);\n                    } else {\n                        mixIns.add(_constructMethod(m));\n                    }\n                }\n            }\n        }\n    }",
    "fixed_lines": "                    am = mixIns.find(m);\n                    if (am != null) {\n                        _addMixUnders(m, am);\n                    } else {\n                    }",
    "masked_code": "    protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n    {\n        List<Class<?>> parents = new ArrayList<Class<?>>();\n        parents.add(mixInCls);\n        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n        for (Class<?> mixin : parents) {\n            for (Method m : mixin.getDeclaredMethods()) {\n                if (!_isIncludableMemberMethod(m)) {\n                    continue;\n                }\n                AnnotatedMethod am = methods.find(m);\n                /* Do we already have a method to augment (from sub-class\n                 * that will mask this mixIn)? If so, add if visible\n                 * without masking (no such annotation)\n                 */\n                if (am != null) {\n                    _addMixUnders(m, am);\n                    /* Otherwise will have precedence, but must wait\n                     * until we find the real method (mixIn methods are\n                     * just placeholder, can't be called)\n                     */\n                } else {\n                    // Well, or, as per [Issue#515], multi-level merge within mixins...\n                        mixIns.add(_constructMethod(m));\n>>> [ INFILL ] <<<\n                }\n            }\n        }\n    }",
    "project": "JacksonDatabind",
    "test_error_message": "com.fasterxml.jackson.databind.JsonMappingException: No serializer found for class com.fasterxml.jackson.databind.introspect.TestMixinMerging$PersonImpl and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) )",
    "test_framework": "defects4j",
    "test_line": "",
    "test_name": "testDisappearingMixins515",
    "test_suite": "com.fasterxml.jackson.databind.introspect.TestMixinMerging",
    "time_buggy": "2014-08-13 12:28:39 -0700",
    "time_fixed": "2014-08-13 16:04:04 -0700",
    "bug_description": "Bug ID: 5\n\nProject: JacksonDatabind\n\nBug Description:\n\nIn the JacksonDataBind project, a Serialization Feature (SF) type bug with ID 5 was identified. This bug is causing a JsonMappingException with the error message: \"No serializer found for class com.fasterxml.jackson.databind.introspect.TestMixinMerging$PersonImpl and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS)\". This exception is thrown when trying to serialize a JSON payload.\n\nHere's a detailed step-by-step description of the bug:\n\n1. Start the JacksonDatabind project.\n\n2. The bug can be traced to a method '_addMethodMixIns' in this project. This method is intended to handle the mix-in annotations (annotations that target other classes) and adds them to a list of annotated methods.\n\n3. In this method, a loop iterates over a collection of parent classes and for each, it finds and declares its methods.\n\n4. Those methods that pass the '_isIncludableMemberMethod' check are considered and an annotated method (let's call it 'am') is fetched from the 'methods' map based on the declared method.\n\n5. If the annotated method 'am' is already present, a method is added with '_addMixUnders' function. If it's not present, it is just added to the 'mixIns' map by constructing the method using '_constructMethod(m)' function. \n\n6. The issue seems to originate within this else block where it's supposed to handle situations where there isn't an existing corresponding method in the 'methods' map, hence a new method is expected to be created. However, there doesn't seem to be a check that confirms whether the method already exists in 'mixIns'. Therefore, it just keeps adding new method instances which shouldn't be the case.\n\nResolution:\n\n1. In the else block, after the comment '// Well, or, as per [Issue#515], multi-level merge within mixins...', \n\n2. Before just blindly adding a new method instance, it's important to do a check whether the method is already there in 'mixIns' or not.\n\n3. This is achieved by fetching the method from 'mixIns' map again and if it's present, then it is handled, otherwise, a new method is created using the '_constructMethod(m)' function.\n\n4. This modification avoids unnecessary heaps of methods in 'mixIns' and prevents duplicates, thus fixing the JsonMappingException issue. \n\nThis change can be seen in the 'Fixed Code' section above. This minor tweak in the code ensures that the serializers are properly set and properties are discovered to create BeanSerializer, thereby taking care of the thrown exception."
}