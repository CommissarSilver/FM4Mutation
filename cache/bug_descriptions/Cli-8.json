{
    "bug_id": 8,
    "bug_type": "SL SH SF",
    "buggy_lines": "            pos = findWrapPos(text, width, nextLineTabStop);",
    "code": "    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, nextLineTabStop);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }",
    "fixed_code": "    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }",
    "fixed_lines": "            pos = findWrapPos(text, width, 0);",
    "masked_code": "    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n>>> [ INFILL ] <<<\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }",
    "project": "Cli",
    "test_error_message": "junit.framework.ComparisonFailure: single line padded text 2 expected:<...TE[-DATE] where DATE[",
    "test_framework": "defects4j",
    "test_line": "      assertEquals(\"single line padded text 2\", expected, sb.toString());",
    "test_name": "testPrintWrapped",
    "test_suite": "org.apache.commons.cli.HelpFormatterTest",
    "time_buggy": "2008-04-26 17:31:48 +0000",
    "time_fixed": "2008-05-08 06:40:58 +0000",
    "bug_description": "Bug Description:\n\nBug ID: 8\nProject: CLI\nBug Type: Single Line, Single Hunk, Single File (SL SH SF)\nOccurred Error Type: junit.framework.ComparisonFailure: single line padded text 2 expected\n\nDetails:\n\n- The bug issue is in the method `renderWrappedText()` of the CLI project. Specifically, the bug lies in the function `findWrapPos()` and how it is called within `renderWrappedText()`.\n- The `renderWrappedText()` method attempts to wrap a given text within a specified width. However, due to an incorrect calling of `findWrapPos()`, the function does not perform correctly.\n\nWhat the bug affects:\n\n- The bug leads to incorrect text wrapping, causing inconsistencies in how the program handles and presents text.\n\nSteps to reproduce:\n\n1. In `renderWrappedText()`, a position `pos` is found where the text should be wrapped. The method `findWrapPos()` is used to determine this position.\n2. If `pos` is -1 (indicating no valid wrap position was found), the original text is appended to `sb` directly.\n3. If `pos` is not -1, the text preceding the wrap position is appended to `sb` along with a new line. Subsequent lines in the text should be padded with `nextLineTabStop` space characters.\n4. Thereafter, in an infinite loop, the remaining portion of the text from `pos` and onward is padded and the process is repeated. Here lies the actual bug: `findWrapPos()` is called with `nextLineTabStop` as the last argument instead of '0'. This results in incorrect calculations of wrap positions in subsequent lines, causing improper text wrapping and misalignment.\n\nBug fix:\n\n- To fix the bug, `findWrapPos()` method should be called with '0' as the last argument, instead of `nextLineTabStop`. This correctly considers the padding for subsequent lines, and ensures the text is wrapped correctly.\n- The fixed code modifies the `pos = findWrapPos(text, width, nextLineTabStop);` line within the infinite loop to `pos = findWrapPos(text, width, 0);`.\n\nHow to recreate the bug:\n\nDevelopers trying to recreate this bug for testing purposes should replace the '0' in the fixed code's `findWrapPos()` call (inside the loop) to `nextLineTabStop`, mimicking the original erroneous condition. This will result in incorrect text wrapping and misalignment, recreating the bug.\n"
}