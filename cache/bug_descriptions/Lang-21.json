{
    "bug_id": 21,
    "bug_type": "SL SH SF",
    "buggy_lines": "                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&",
    "code": "    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());\n    }",
    "fixed_code": "    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());\n    }",
    "fixed_lines": "                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&",
    "masked_code": "    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n>>> [ INFILL ] <<<\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());\n    }",
    "project": "Lang",
    "test_error_message": "junit.framework.AssertionFailedError: LANG-677",
    "test_framework": "defects4j",
    "test_line": "        assertFalse(\"LANG-677\", DateUtils.isSameLocalTime(cal3, cal4));",
    "test_name": "testIsSameLocalTime_Cal",
    "test_suite": "org.apache.commons.lang3.time.DateUtilsTest",
    "time_buggy": "2011-02-02 07:15:29 +0000",
    "time_fixed": "2011-02-02 21:55:15 +0000",
    "bug_description": "Bug ID: 21\nBug Type: SL (Semantic Error Type, Type Wrong Method)\n\nDescription:\n\nProject \"Lang\" has a function \"isSameLocalTime\" which is supposed to compare two Calendar objects \"cal1\" and \"cal2\" and check if they represent the same local time. However, a Junit test flagged an assertion error (LANG-677) on a line of code in this function.\n\nThe error is in the way the function is checking for the hour field of these Calendar objects. The function currently checks the \"HOUR\" field of the Calendar object using the \"HOUR\" constant. This constant represents the hour in AM/PM (0 - 11) format. This is highlighted in the code given as shown below:\n\n        Buggy Line: cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n\nThis can lead to erroneous results if one of the time (or both) is in the PM. For example, 2 PM and 2 AM would return from the function as being the same time, as the \"HOUR\" constant only checks the hour without considering if it is AM or PM.\n\nThis problem is fixed by changing the \"HOUR\" constant to \"HOUR_OF_DAY\". The \"HOUR_OF_DAY\" constant represents the hour in 24-hour format (0 - 23), thus accurately differentiating between AM and PM hours. The fixed line of code is shown below:\n\n        Fixed: cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n\nThis fix ensures that the function accurately checks if the two Calendar objects represent the same local time irrespective of them being in AM or PM.\n\nSteps to Replicate:\n\n1. Create two Calendar instances, set one to time in the AM and the other to the same time but in the PM.\n2. Call the function \"isSameLocalTime\" passing these two instances.\n3. The function will return 'true' indicating that they represent the same time, which is not correct. This error will also be flagged by a Junit test (if present as in this case) configured to assert the correctness of this function."
}