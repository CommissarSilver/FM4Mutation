{
    "bug_id": 28,
    "bug_type": "SF",
    "buggy_lines": "            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n                p.nextToken();\n            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());",
    "code": "        public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n                p.nextToken();\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ObjectNode.class);\n         }\n    }\n        \n    final static class ArrayDeserializer\n        extends BaseNodeDeserializer<ArrayNode>\n    {\n        private static final long serialVersionUID = 1L;\n\n        protected final static ArrayDeserializer _instance = new ArrayDeserializer();\n\n        protected ArrayDeserializer() { super(ArrayNode.class); }\n\n        public static ArrayDeserializer getInstance() { return _instance; }\n        \n        @Override\n        public ArrayNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.isExpectedStartArrayToken()) {\n                return deserializeArray(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ArrayNode.class);\n        }",
    "fixed_code": "        public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.isExpectedStartObjectToken() || p.hasToken(JsonToken.FIELD_NAME)) {\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (p.hasToken(JsonToken.END_OBJECT)) {\n                return ctxt.getNodeFactory().objectNode();\n            }\n            throw ctxt.mappingException(ObjectNode.class);\n         }\n    }\n        \n    final static class ArrayDeserializer\n        extends BaseNodeDeserializer<ArrayNode>\n    {\n        private static final long serialVersionUID = 1L;\n\n        protected final static ArrayDeserializer _instance = new ArrayDeserializer();\n\n        protected ArrayDeserializer() { super(ArrayNode.class); }\n\n        public static ArrayDeserializer getInstance() { return _instance; }\n        \n        @Override\n        public ArrayNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.isExpectedStartArrayToken()) {\n                return deserializeArray(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ArrayNode.class);\n        }",
    "fixed_lines": "            if (p.isExpectedStartObjectToken() || p.hasToken(JsonToken.FIELD_NAME)) {\n            if (p.hasToken(JsonToken.END_OBJECT)) {\n                return ctxt.getNodeFactory().objectNode();",
    "masked_code": "        public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n>>> [ INFILL ] <<<\n            }\n            throw ctxt.mappingException(ObjectNode.class);\n         }\n    }\n        \n    final static class ArrayDeserializer\n        extends BaseNodeDeserializer<ArrayNode>\n    {\n        private static final long serialVersionUID = 1L;\n\n        protected final static ArrayDeserializer _instance = new ArrayDeserializer();\n\n        protected ArrayDeserializer() { super(ArrayNode.class); }\n\n        public static ArrayDeserializer getInstance() { return _instance; }\n        \n        @Override\n        public ArrayNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.isExpectedStartArrayToken()) {\n                return deserializeArray(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ArrayNode.class);\n        }",
    "project": "JacksonDatabind",
    "test_error_message": "com.fasterxml.jackson.databind.JsonMappingException: Can not deserialize instance of com.fasterxml.jackson.databind.node.ObjectNode out of END_OBJECT token",
    "test_framework": "defects4j",
    "test_line": "        MyValue de2 = MAPPER.readValue(json, MyValue.class);  // but this throws exception",
    "test_name": "testIssue941",
    "test_suite": "com.fasterxml.jackson.databind.node.TestObjectNode",
    "time_buggy": "2015-09-23 15:36:00 -0700",
    "time_fixed": "2015-09-23 16:04:09 -0700",
    "bug_description": "Bug ID: 28\nProject: JacksonDatabind\n\nBug Type: Semantic Fault (SF)\n\n1. Brief Description:\n\nThe issue lies in the method deserialize in the class ObjectNode. The bug causes a JsonMappingException with the message: \"Can not deserialize instance of com.fasterxml.jackson.databind.node.ObjectNode out of END_OBJECT token\".\n\n2. Detailed Description:\n\nThe error occurs when the parser encounters the JSON token END_OBJECT. In the original code, if the current token is START_OBJECT, the next token is fetched efficiently. However, if the current token is FIELD_NAME, the deserialization happens without apparent checks for END_OBJECT. Consequently, when the parser encounters an END_OBJECT token, it raises the JsonMappingException due to the inability to create an instance of ObjectNode.\n\n3. Code Details:\n\nThe problematic part of the code lies in the two conditional statements:\nFirst part:\n```\nif (p.getCurrentToken() == JsonToken.START_OBJECT) {\n    p.nextToken();\n    return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n}\n```   \nSecond part:\n```\nif (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n    return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n}\n```\nInstead of moving to next token when START_OBJECT is encountered and deserializing on FIELD_NAME, there should also be an equivalent handling for END_OBJECT tokens. \n\n4. Fix:\n\nThe fix is to add additional checks for existence of FIELD_NAME token in the if condition for START_OBJECT and also add a separate handling for END_OBJECT token. The fixed code is as follows:\n\n```\nif (p.isExpectedStartObjectToken() || p.hasToken(JsonToken.FIELD_NAME)) {\n    return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n}\n```   \nFor END_OBJECT token:\n```\nif (p.hasToken(JsonToken.END_OBJECT)) {\n    return ctxt.getNodeFactory().objectNode();\n}\n```\n\n5. Test Error Message:\n\nThe test encounters a com.fasterxml.jackson.databind.JsonMappingException with the message: \"Can not deserialize instance of com.fasterxml.jackson.databind.node.ObjectNode out of END_OBJECT token\" which is resolved with the fix applied. \n\nThis detailed bug description should assist developers in generating similar artificial Java bugs for testing purposes."
}