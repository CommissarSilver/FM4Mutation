{
    "bug_id": 26,
    "bug_type": "SH SF",
    "buggy_lines": "",
    "code": "    public static long skip(InputStream input, long numToSkip) throws IOException {\n        long available = numToSkip;\n        while (numToSkip > 0) {\n            long skipped = input.skip(numToSkip);\n            if (skipped == 0) {\n                break;\n            }\n            numToSkip -= skipped;\n        }\n            \n        return available - numToSkip;\n    }",
    "fixed_code": "    public static long skip(InputStream input, long numToSkip) throws IOException {\n        long available = numToSkip;\n        while (numToSkip > 0) {\n            long skipped = input.skip(numToSkip);\n            if (skipped == 0) {\n                break;\n            }\n            numToSkip -= skipped;\n        }\n            \n        if (numToSkip > 0) {\n            byte[] skipBuf = new byte[SKIP_BUF_SIZE];\n            while (numToSkip > 0) {\n                int read = readFully(input, skipBuf, 0,\n                                     (int) Math.min(numToSkip, SKIP_BUF_SIZE));\n                if (read < 1) {\n                    break;\n                }\n                numToSkip -= read;\n            }\n        }\n        return available - numToSkip;\n    }",
    "fixed_lines": "        if (numToSkip > 0) {\n            byte[] skipBuf = new byte[SKIP_BUF_SIZE];\n            while (numToSkip > 0) {\n                int read = readFully(input, skipBuf, 0,\n                                     (int) Math.min(numToSkip, SKIP_BUF_SIZE));\n                if (read < 1) {\n                    break;\n                }\n                numToSkip -= read;\n            }\n        }",
    "masked_code": "    public static long skip(InputStream input, long numToSkip) throws IOException {\n        long available = numToSkip;\n        while (numToSkip > 0) {\n            long skipped = input.skip(numToSkip);\n            if (skipped == 0) {\n                break;\n            }\n            numToSkip -= skipped;\n        }\n            \n>>> [ INFILL ] <<<\n        return available - numToSkip;\n    }",
    "project": "Compress",
    "test_error_message": "junit.framework.AssertionFailedError: expected:<10> but was:<0>",
    "test_framework": "defects4j",
    "test_line": "        Assert.assertEquals(10, IOUtils.skip(sut, 10));",
    "test_name": "skipUsingRead",
    "test_suite": "org.apache.commons.compress.utils.IOUtilsTest",
    "time_buggy": "2014-04-12 16:20:54 +0000",
    "time_fixed": "2014-04-12 17:05:57 +0000",
    "bug_description": "Bug ID: 26\nProject: Compress\nBug Type: SH SF (Stubborn Hard to Find / Smelly Fowl)\n\nStep 1: Description of Functionality & Expected Outcome\nThe function \u201cskip(InputStream input, long numToSkip)\" is part of a compression application. Its intended functionality is to skip a certain number of bytes in the InputStream as directed by the input argument \"numToSkip\". The number of bytes that have been successfully skipped is to be returned by the function.\n\nA unit test conducted with an expected outcome of \"10\" but the function returned \"0\", thereby causing an AssertionFailedError: expected:<10> but was:<0>.\n\nStep 2: Identified Problem in the Source Code\nUpon examining the original source code, it seems the function encounters a problem when it is not able to skip the desired number of bytes if the \"input.skip(numToSkip)\" returns \"0\" (indicating that no further bytes could be skipped). At this point, the function breaks from the loop and proceeds to return the number of bytes skipped. This scenario could occur if, for example, the InputStream stops being readable before 'numToSkip' bytes have been skipped.\n\nStep 3: Description of Implemented Fix \nThe fixed code incorporates a check after the first 'while' loop, to see if the number of bytes left to skip 'numToSkip' is still greater than 0 (meaning there were not enough bytes skipped in the first 'while' loop). If that is the case, the fix creates a byte array 'skipBuf' with a length of 'SKIP_BUF_SIZE' and a further 'while' loop that continuously tries to read fully from the InputStream to this buffer until either the remaining bytes have been skipped or the InputStream is no longer readable (signified by read < 1). The number of bytes skipped is then reduced according to the number of bytes read. The function will now account for scenarios where skipping bytes through InputStream's skip() method is not possible till 'numToSkip'.\n\nStep 4: Outcome\nAs a result of this fix, the function 'skip()' now handles additional edge cases when the InputStream's \"skip()\" method is not able to skip the required number of bytes.\n\nThis detailed description can be used for generating artificial bugs in Java teaching developers how to address issues related to read/skip methods of InputStreams in Java."
}