{
    "bug_id": 67,
    "bug_type": "SF",
    "buggy_lines": "                return _createEnumKeyDeserializer(ctxt, type);\n            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);",
    "code": "    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        KeyDeserializer deser = null;\n        if (_factoryConfig.hasKeyDeserializers()) {\n            BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n                deser = d.findKeyDeserializer(type, config, beanDesc);\n                if (deser != null) {\n                    break;\n                }\n            }\n        }\n        // the only non-standard thing is this:\n        if (deser == null) {\n            if (type.isEnumType()) {\n                return _createEnumKeyDeserializer(ctxt, type);\n            }\n            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n        }\n        // and then post-processing\n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyKeyDeserializer(config, type, deser);\n                }\n            }\n        }\n        return deser;\n    }",
    "fixed_code": "    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        KeyDeserializer deser = null;\n        if (_factoryConfig.hasKeyDeserializers()) {\n            BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n                deser = d.findKeyDeserializer(type, config, beanDesc);\n                if (deser != null) {\n                    break;\n                }\n            }\n        }\n        // the only non-standard thing is this:\n        if (deser == null) {\n            if (type.isEnumType()) {\n                deser = _createEnumKeyDeserializer(ctxt, type);\n            } else {\n                deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n            }\n        }\n        // and then post-processing\n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyKeyDeserializer(config, type, deser);\n                }\n            }\n        }\n        return deser;\n    }",
    "fixed_lines": "                deser = _createEnumKeyDeserializer(ctxt, type);\n            } else {\n                deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);",
    "masked_code": "    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        KeyDeserializer deser = null;\n        if (_factoryConfig.hasKeyDeserializers()) {\n            BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n                deser = d.findKeyDeserializer(type, config, beanDesc);\n                if (deser != null) {\n                    break;\n                }\n            }\n        }\n        // the only non-standard thing is this:\n        if (deser == null) {\n            if (type.isEnumType()) {\n            }\n>>> [ INFILL ] <<<\n        }\n        // and then post-processing\n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyKeyDeserializer(config, type, deser);\n                }\n            }\n        }\n        return deser;\n    }",
    "project": "JacksonDatabind",
    "test_error_message": "com.fasterxml.jackson.databind.exc.InvalidFormatException: Can not deserialize Map key of type com.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer$KeyEnum from String \"REPlaceMENTS\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Can not deserialize Map key of type com.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer$KeyEnum from String \"REPlaceMENTS\": not one of values excepted for Enum class: [rootDirectory, replacements, licenseString]",
    "test_framework": "defects4j",
    "test_line": "",
    "test_name": "testCustomEnumValueAndKeyViaModifier",
    "test_suite": "com.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer",
    "time_buggy": "2016-11-02 22:17:18 -0700",
    "time_fixed": "2016-11-09 20:39:22 -0800",
    "bug_description": "Bug ID: 67\nBug Type: Software Failure (SF)\n\nThe project exhibiting the bug is JacksonDatabind, which is a library for JSON serialization and deserialization in Java.\n\nFollowing is a detailed description of the bug:\n\n1. The bug surfaces when the program tries to deserialize a map key of type com.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer$KeyEnum from string \"REPlaceMENTS\". It's not considered as a valid representation since it's not one of the values defined for the Enum class. The Enum class expects either \"rootDirectory\", \"replacements\", or \"licenseString\".\n\n2. The error message clearly points out that the issue arises from deserializing the Map key. The code related to the bug is present in the method `createKeyDeserializer()` in the provided code snippet.\n\n3. The problem seems to be with the line of code \n    ```\n    return _createEnumKeyDeserializer(ctxt, type);\n    ```\n   and\n    ```\n    deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n    ```\n   One or both of these line(s) is/are failing to correctly deserialize the provided string \"REPlaceMENTS\" to a map key.\n\n4. In the bug fix, there is a slight change to the code. Now in the fixed code, instead of directly returning the \"_createEnumKeyDeserializer\", it sets it to the \"deser\" which then returned after some potential modifications applied later in the method.\n\n5. The key step that fixed the issue was replacing \n    ```\n    return _createEnumKeyDeserializer(ctxt, type);\n    ```\n   with\n    ```\n    deser = _createEnumKeyDeserializer(ctxt, type);\n    ```\n   By doing this, the function receives a chance to further modify the deserializer (\"deser\") before it is returned, which could be what's needed to successfully deserialize the problematic classes.\n\nIn order to artificially generate such a bug in a Java project, one might want to misuse or poorly handle enum deserialization, forcing a deserialization type which is inconsistent with the provided input."
}