{
    "bug_id": 31,
    "bug_type": "SH SF",
    "buggy_lines": "            if (currentByte == 0) {\n                break;\n            }",
    "code": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Trim all trailing NULs and spaces.\n        // The ustar and POSIX tar specs require a trailing NUL or\n        // space but some implementations use the extra digit for big\n        // sizes/uids/gids ...\n        byte trailer = buffer[end - 1];\n        while (start < end && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            if (currentByte == 0) {\n                break;\n            }\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }",
    "fixed_code": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Trim all trailing NULs and spaces.\n        // The ustar and POSIX tar specs require a trailing NUL or\n        // space but some implementations use the extra digit for big\n        // sizes/uids/gids ...\n        byte trailer = buffer[end - 1];\n        while (start < end && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }",
    "fixed_lines": "",
    "masked_code": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Trim all trailing NULs and spaces.\n        // The ustar and POSIX tar specs require a trailing NUL or\n        // space but some implementations use the extra digit for big\n        // sizes/uids/gids ...\n        byte trailer = buffer[end - 1];\n        while (start < end && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n>>> [ INFILL ] <<<\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }",
    "project": "Compress",
    "test_error_message": "junit.framework.AssertionFailedError: Expected IOException",
    "test_framework": "defects4j",
    "test_line": "            fail(\"Expected IOException\");",
    "test_name": "testCOMPRESS178",
    "test_suite": "org.apache.commons.compress.archivers.TarTestCase",
    "time_buggy": "2015-02-20 16:21:26 +0000",
    "time_fixed": "2015-02-20 16:30:45 +0000",
    "bug_description": "Bug Description:\n\n1. Bug ID: The identification number of the bug is 31. \n\n2. Project: The bug was encountered in the 'Compress' project. \n\n3. Bug Type: The type of the bug is 'SH SF'.\n\n4. Test Error Message: The error message provided by the JUnit framework is 'junit.framework.AssertionFailedError: Expected IOException.' \n\n5. Buggy Lines: The bug originated in the lines of code:\n                if (currentByte == 0) {\n                break;\n            }\n    These lines are within the 'for' loop where it's checking the buffer values. When the currentByte is 0, it breaks the loop.\n\n6. Code: The given buggy code is a method called 'parseOctal'. It is written to parse an Octal number from its byte array representation. If the length of array is less than 2, it throws an IllegalArgumentException stating \"Length must be at least 2\". If the start byte is 0, it returns directly with 0L. After skipping leading spaces and trailing NULs and spaces, it checks each byte for being in the octal number range ('0'-'7'). If the byte is not in this range, it throws another IllegalArgumentException. If the byte is 0, it breaks the loop and ends the method prematurely.\n\n7. Fixed Code: In the fixed version of the code, the buggy lines where the system breaks the loop when the currentByte equals 0 are no longer present. This means regardless of the byte being 0 or not, it will continue the loop until the end of the array (given the value is in the octal number range). This change allows the system to handle 0 value in the array properly and doesn't lead to unexpected termination of the method.\n\n8. Steps to reproduce: \n\n- Initialize an array of bytes which includes zero in the place where it was not expected.\n- Recoil this array, offset, and its length into the `parseOctal` method.\n- Run a junit test which expects an IOException.\n- The test will fail with 'junit.framework.AssertionFailedError: Expected IOException.' error.\n\nBy removing the check for 'currentByte == 0' and not breaking the loop, the IOException will not be thrown and the test case will pass."
}