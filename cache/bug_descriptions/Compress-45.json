{
    "bug_id": 45,
    "bug_type": "SF",
    "buggy_lines": "        formatBigIntegerBinary(value, buf, offset, length, negative);",
    "code": "    public static int formatLongOctalOrBinaryBytes(\n        final long value, final byte[] buf, final int offset, final int length) {\n\n        // Check whether we are dealing with UID/GID or SIZE field\n        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n        final boolean negative = value < 0;\n        if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\n            return formatLongOctalBytes(value, buf, offset, length);\n        }\n\n        if (length < 9) {\n            formatLongBinary(value, buf, offset, length, negative);\n        }\n        formatBigIntegerBinary(value, buf, offset, length, negative);\n\n        buf[offset] = (byte) (negative ? 0xff : 0x80);\n        return offset + length;\n    }",
    "fixed_code": "    public static int formatLongOctalOrBinaryBytes(\n        final long value, final byte[] buf, final int offset, final int length) {\n\n        // Check whether we are dealing with UID/GID or SIZE field\n        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n        final boolean negative = value < 0;\n        if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\n            return formatLongOctalBytes(value, buf, offset, length);\n        }\n\n        if (length < 9) {\n            formatLongBinary(value, buf, offset, length, negative);\n        } else {\n            formatBigIntegerBinary(value, buf, offset, length, negative);\n        }\n\n        buf[offset] = (byte) (negative ? 0xff : 0x80);\n        return offset + length;\n    }",
    "fixed_lines": "        } else {\n            formatBigIntegerBinary(value, buf, offset, length, negative);",
    "masked_code": "    public static int formatLongOctalOrBinaryBytes(\n        final long value, final byte[] buf, final int offset, final int length) {\n\n        // Check whether we are dealing with UID/GID or SIZE field\n        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n        final boolean negative = value < 0;\n        if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\n            return formatLongOctalBytes(value, buf, offset, length);\n        }\n\n        if (length < 9) {\n            formatLongBinary(value, buf, offset, length, negative);\n        }\n>>> [ INFILL ] <<<\n\n        buf[offset] = (byte) (negative ? 0xff : 0x80);\n        return offset + length;\n    }",
    "project": "Compress",
    "test_error_message": "java.lang.IllegalArgumentException: Value -72057594037927935 is too large for 8 byte field.",
    "test_framework": "defects4j",
    "test_line": "        TarUtils.formatLongOctalOrBinaryBytes(value, buffer, 0, buffer.length);",
    "test_name": "testRoundTripOctalOrBinary8",
    "test_suite": "org.apache.commons.compress.archivers.tar.TarUtilsTest",
    "time_buggy": "2017-06-17 21:46:53 +0200",
    "time_fixed": "2017-06-17 21:47:10 +0200",
    "bug_description": "Bug ID: 45\nProject: Compress\nBug Type: Semantic Fault (SF)\nFixed Version Code: Included above\n\nBug Description:\nThe bug exists in the method \"formatLongOctalOrBinaryBytes\". This method is called with a 'value' argument which is too large to fit into the 8-byte field as shown by the error message \"java.lang.IllegalArgumentException: Value -72057594037927935 is too large for 8 byte field\".\n\nStep by Step Occurrence:\n\n1. The method formatLongOctalOrBinaryBytes is intended to format a given long value into either octal or binary bytes depending upon the conditions in the method.\n\n2. It checks whether we are dealing with UID/GID or SIZE fields and assigns maximum values to the 'maxAsOctalChar' variable accordingly.\n\n3. If the value is not negative and is within permissible range to be stored as octal characters, it calls the method formatLongOctalBytes.\n\n4. If the length is less than 9, it calls formatLongBinary to format the value as binary. Here, the check for length less than 9 aims to ensure the value fits within the permitted byte limit.\n\n5. However, the method then executes formatBigIntegerBinary(value, buf, offset, length, negative) without any condition. This means that even when length is less than 9 (i.e. the value can be accommodated within 8 bytes), it is trying to format it as a BigIntegerBinary. As a result, when the value is too large to be accommodated within 8 bytes, it throws an IllegalArgumentException. \n\nFix:\nThe fix is to call formatBigIntegerBinary(value, buf, offset, length, negative) in the scenario where the length is equal to or more than 9. This checks whether the length of the byte array is sufficient to accommodate the BigIntegerBinary representation of the value, avoiding the IllegalArgumentException when the value is too large.\n\nHence, the fixed code provides an else condition to call the formatBigIntegerBinary method only when the length is equal to or more than 9."
}