{
    "bug_id": 94,
    "bug_type": "SF",
    "buggy_lines": "",
    "code": "  static boolean isValidDefineValue(Node val, Set<String> defines) {\n    switch (val.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n\n      // Binary operators are only valid if both children are valid.\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n\n      // Uniary operators are valid if the child is valid.\n      case Token.NOT:\n      case Token.NEG:\n        return isValidDefineValue(val.getFirstChild(), defines);\n\n      // Names are valid if and only if they are defines themselves.\n      case Token.NAME:\n      case Token.GETPROP:\n        if (val.isQualifiedName()) {\n          return defines.contains(val.getQualifiedName());\n        }\n    }\n    return false;\n  }",
    "fixed_code": "  static boolean isValidDefineValue(Node val, Set<String> defines) {\n    switch (val.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n\n      // Binary operators are only valid if both children are valid.\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return isValidDefineValue(val.getFirstChild(), defines)\n            && isValidDefineValue(val.getLastChild(), defines);\n\n      // Uniary operators are valid if the child is valid.\n      case Token.NOT:\n      case Token.NEG:\n      case Token.POS:\n        return isValidDefineValue(val.getFirstChild(), defines);\n\n      // Names are valid if and only if they are defines themselves.\n      case Token.NAME:\n      case Token.GETPROP:\n        if (val.isQualifiedName()) {\n          return defines.contains(val.getQualifiedName());\n        }\n    }\n    return false;\n  }",
    "fixed_lines": "      case Token.ADD:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return isValidDefineValue(val.getFirstChild(), defines)\n            && isValidDefineValue(val.getLastChild(), defines);\n      case Token.POS:",
    "masked_code": "  static boolean isValidDefineValue(Node val, Set<String> defines) {\n    switch (val.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n\n      // Binary operators are only valid if both children are valid.\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n\n      // Uniary operators are valid if the child is valid.\n      case Token.NOT:\n      case Token.NEG:\n>>> [ INFILL ] <<<\n        return isValidDefineValue(val.getFirstChild(), defines);\n\n      // Names are valid if and only if they are defines themselves.\n      case Token.NAME:\n      case Token.GETPROP:\n        if (val.isQualifiedName()) {\n          return defines.contains(val.getQualifiedName());\n        }\n    }\n    return false;\n  }",
    "project": "Closure",
    "test_error_message": "junit.framework.AssertionFailedError",
    "test_framework": "defects4j",
    "test_line": "    assertTrue(testValidDefineValue(\"1 + 8\"));",
    "test_name": "testValidDefine",
    "test_suite": "com.google.javascript.jscomp.NodeUtilTest",
    "time_buggy": "2010-10-01 20:41:43 +0000",
    "time_fixed": "2010-10-01 23:37:19 +0000",
    "bug_description": "Bug ID: 94\nProject: Closure\nBug Type: Semantic Failure (SF)\n\nBug Description: \nThe issue observed in the project 'Closure' pertains to the function 'isValidDefineValue' used to validate the define values for a given node. The bug is of semantic failure type, indicated by an AssertionFailedError during the junit test case execution. \n\nIn the buggy code, while verifying the validity of definitions, it did not properly account for all valid binary operators and failed to check both children of binary operators for validation. Binary operators are valid if both of their children are also valid.\n\nThe bug specifically lies in the 'switch' statement. In the case of binary operators such as 'Token.ADD', 'Token.DIV', 'Token.EQ', 'Token.GE', 'Token.GT', etc., the code does not accurately return the validator 'isValidDefineValue' for both the 'getFirstChild' and 'getLastChild'. In addition to it, it erroneously includes operator tokens such as 'Token.BITAND', 'Token.BITNOT', 'Token.BITOR', 'Token.BITXOR' which should be included in the binary operator tokens section.\n\nThe fixed code correctly checks for all binary operator tokens in their appropriate section applying the validator on both the first and last child nodes. It also correctly includes the unary operator 'Token.POS' in the unary operators section and applies the validator only on the first child node.\n\nTo reproduce the bug:\n\n1. Try to run a program/module that uses the 'isValidDefineValue' function with a binary operator like 'Token.ADD'.\n2. The function will fail to validate correctly as it's not checking the last child node of the binary operator.\n3. As a result, the unit tests related to this function will throw an 'AssertionFailedError'.\n\nThis bug can be resolved by updating the binary operator tokens in the switch case and applying the validator to the first child and last child nodes of binary operator tokens, as shown in the fixed code."
}