{
    "bug_id": 25,
    "bug_type": "SH SF",
    "buggy_lines": "",
    "code": "    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }",
    "fixed_code": "    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal > 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }",
    "fixed_lines": "        } else if (offsetLocal > 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }",
    "masked_code": "    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n>>> [ INFILL ] <<<\n        }\n        return offsetAdjusted;\n    }",
    "project": "Time",
    "test_error_message": "junit.framework.ComparisonFailure: expected:<...10-28T02:30:00.000+0[4]:00> but was:<...10-28T02:30:00.000+0[3]:00>",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(\"2007-10-28T02:30:00.000+04:00\", dt.toString());",
    "test_name": "test_DateTime_constructor_Moscow_Autumn",
    "test_suite": "org.joda.time.TestDateTimeZoneCutover",
    "time_buggy": "2010-12-05 21:27:36 +0000",
    "time_fixed": "2010-12-05 23:43:18 +0000",
    "bug_description": "Bug ID: 25\nProject: Time\nBug Type: Semantic/Syntactic Feature (SH SF)\n\nDescription:\n\nThe bug in question is causing a discrepancy in the expected and actual time offset.\n\nSteps to Understand the Bug:\n\nStep 1:\nThe bug is present in the `getOffsetFromLocal()` method in the Time module of the project. This function is responsible for calculating the offset from local time.\n\nStep 2:\nThe error appears to be within the calculation of different local and adjusted offsets. This mechanism is primarily responsible for handling cases near Daylight Saving Time (DST) boundaries.\n\nStep 3:\nThe 'junit.framework.ComparisonFailure' error suggests that there is an incorrect offset calculation in the function; the expected value differs from the actual value by an hour. In particular, the resulting offset is one hour behind the expected offset.\n\nStep 4:\nThis condition possibly arises when `(offsetLocal - offsetAdjusted) < 0` and the calculated `nextLocal` is not equal to `nextAdjusted`. Then the function returns `offsetLocal` as the offset.\n\nStep 5:\nEven though this addresses certain cases, it does not properly account for scenarios where the offsetLocal remains constant, but adjusted offset changes (i.e., positive DST offsets).\n\nResolution:\n\nThe fixed code correctly accounts for all cases by introducing an else-if condition to handles cases where offsetLocal does not change, but the offsetAdjusted does. This is a situation that naturally occurs for positive DST offsets. The new code handles this by returning a previous transition instead of the offsetLocal. The logic checks if the previous transition is less than instantAdjusted and then checks if the difference between the current instant and the previous transition is less than or equal to the difference between offsetPrev and offsetLocal. If both of these conditions are satisfied, it returns offsetPrev instead of offsetLocal.\n\nConclusion:\n\nThe bug was caused by an improper handling of DST offsets in the original code which did not account for positive offsets. The solution correctly handles these cases, resolving the time discrepancy."
}