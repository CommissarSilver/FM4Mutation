{
    "bug_id": 18,
    "bug_type": "SF",
    "buggy_lines": "",
    "code": "    void writePaxHeaders(String entryName,\n                         Map<String, String> headers) throws IOException {\n        String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n            // TarEntry's constructor would think this is a directory\n            // and not allow any data to be written\n        if (name.length() >= TarConstants.NAMELEN) {\n            name = name.substring(0, TarConstants.NAMELEN - 1);\n        }\n        TarArchiveEntry pex = new TarArchiveEntry(name,\n                                                  TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n\n        StringWriter w = new StringWriter();\n        for (Map.Entry<String, String> h : headers.entrySet()) {\n            String key = h.getKey();\n            String value = h.getValue();\n            int len = key.length() + value.length()\n                + 3 /* blank, equals and newline */\n                + 2 /* guess 9 < actual length < 100 */;\n            String line = len + \" \" + key + \"=\" + value + \"\\n\";\n            int actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            while (len != actualLength) {\n                // Adjust for cases where length < 10 or > 100\n                // or where UTF-8 encoding isn't a single octet\n                // per character.\n                // Must be in loop as size may go from 99 to 100 in\n                // first pass so we'd need a second.\n                len = actualLength;\n                line = len + \" \" + key + \"=\" + value + \"\\n\";\n                actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            }\n            w.write(line);\n        }\n        byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n        pex.setSize(data.length);\n        putArchiveEntry(pex);\n        write(data);\n        closeArchiveEntry();\n    }",
    "fixed_code": "    void writePaxHeaders(String entryName,\n                         Map<String, String> headers) throws IOException {\n        String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n        while (name.endsWith(\"/\")) {\n            // TarEntry's constructor would think this is a directory\n            // and not allow any data to be written\n            name = name.substring(0, name.length() - 1);\n        }\n        if (name.length() >= TarConstants.NAMELEN) {\n            name = name.substring(0, TarConstants.NAMELEN - 1);\n        }\n        TarArchiveEntry pex = new TarArchiveEntry(name,\n                                                  TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n\n        StringWriter w = new StringWriter();\n        for (Map.Entry<String, String> h : headers.entrySet()) {\n            String key = h.getKey();\n            String value = h.getValue();\n            int len = key.length() + value.length()\n                + 3 /* blank, equals and newline */\n                + 2 /* guess 9 < actual length < 100 */;\n            String line = len + \" \" + key + \"=\" + value + \"\\n\";\n            int actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            while (len != actualLength) {\n                // Adjust for cases where length < 10 or > 100\n                // or where UTF-8 encoding isn't a single octet\n                // per character.\n                // Must be in loop as size may go from 99 to 100 in\n                // first pass so we'd need a second.\n                len = actualLength;\n                line = len + \" \" + key + \"=\" + value + \"\\n\";\n                actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            }\n            w.write(line);\n        }\n        byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n        pex.setSize(data.length);\n        putArchiveEntry(pex);\n        write(data);\n        closeArchiveEntry();\n    }",
    "fixed_lines": "        while (name.endsWith(\"/\")) {\n            name = name.substring(0, name.length() - 1);\n        }",
    "masked_code": "    void writePaxHeaders(String entryName,\n                         Map<String, String> headers) throws IOException {\n        String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n            // TarEntry's constructor would think this is a directory\n            // and not allow any data to be written\n>>> [ INFILL ] <<<\n        if (name.length() >= TarConstants.NAMELEN) {\n            name = name.substring(0, TarConstants.NAMELEN - 1);\n        }\n        TarArchiveEntry pex = new TarArchiveEntry(name,\n                                                  TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n\n        StringWriter w = new StringWriter();\n        for (Map.Entry<String, String> h : headers.entrySet()) {\n            String key = h.getKey();\n            String value = h.getValue();\n            int len = key.length() + value.length()\n                + 3 /* blank, equals and newline */\n                + 2 /* guess 9 < actual length < 100 */;\n            String line = len + \" \" + key + \"=\" + value + \"\\n\";\n            int actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            while (len != actualLength) {\n                // Adjust for cases where length < 10 or > 100\n                // or where UTF-8 encoding isn't a single octet\n                // per character.\n                // Must be in loop as size may go from 99 to 100 in\n                // first pass so we'd need a second.\n                len = actualLength;\n                line = len + \" \" + key + \"=\" + value + \"\\n\";\n                actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            }\n            w.write(line);\n        }\n        byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n        pex.setSize(data.length);\n        putArchiveEntry(pex);\n        write(data);\n        closeArchiveEntry();\n    }",
    "project": "Compress",
    "test_error_message": "java.io.IOException: request to write '15' bytes exceeds size in header of '0' bytes for entry './PaxHeaders.X/fvv/'",
    "test_framework": "defects4j",
    "test_line": "        tos.putArchiveEntry(t);",
    "test_name": "testWriteNonAsciiDirectoryNamePosixMode",
    "test_suite": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest",
    "time_buggy": "2012-12-27 21:04:23 +0000",
    "time_fixed": "2012-12-27 21:34:35 +0000",
    "bug_description": "Title: Incorrect handling of PaxHeaders in TarEntry constructor resulting in IOException due to size exceeding header \n\nBug ID: 18\nProject: Compress\nBug Type: Software Fault (SF)\n\nDescription:\n\nA bug was found within the 'writePaxHeaders' function in the 'Compress' project. The function is supposed to add a new entry to the tar archive with the provided name and headers and write the data. However, in some cases when a new entry name ends with '/', it is mistakenly identified as a directory by the TarEntry's constructor, even if it's not a directory. This then does not allow any data to be written for that entry, eventually leading to a java.io.IOException.\n\nThis exception is caused by the fact that the attempt to write bytes of data for the directory exceeds the size of 0 bytes defined in the header for the entry. The actual error message displayed is \"java.io.IOException: request to write '15' bytes exceeds size in header of '0' bytes for entry './PaxHeaders.X/fvv/'\".\n\nHere are the detailed steps of the identified issue:\n\n1. A new entry with a name that ends with '/' is processed by the 'writePaxHeaders' function.\n2. The function prepares the name by appending it to \"./PaxHeaders.X/\" and removes any non 7-bit characters.\n3. The function checks if the resulting name's length is smaller than TarConstants.NAMELEN, if it is not, it reduces the name length by taking a substring of the length 'TarConstants.NAMELEN - 1'.\n     - There is no check if the resulting name ends with '/' which might indicate it\u2019s a directory even if it\u2019s not.\n4. As the name ends with '/', TarEntry's constructor assumes this is a directory and does not allow any data to be written.\n5. The system throws a java.io.IOException when trying to write data for this entry as it interprets it as a directory.\n\nFix:\n\nThe issue was fixed by adding a simple loop that removes the trailing '/' in the entry name before processing it further. The while loop checks if the entry names end with '/', and if they do, the last character ('/') is removed. This way, even if the original entry name ended with '/', it's no longer wrongly interpreted as a directory and can hold data, thus, solving the java.io.IOException."
}