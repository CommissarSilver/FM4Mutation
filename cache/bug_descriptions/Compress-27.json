{
    "bug_id": 27,
    "bug_type": "SH SF",
    "buggy_lines": "        if (start == end) {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, trailer));\n        }",
    "code": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Trim all trailing NULs and spaces.\n        // The ustar and POSIX tar specs require a trailing NUL or\n        // space but some implementations use the extra digit for big\n        // sizes/uids/gids ...\n        byte trailer = buffer[end - 1];\n        while (start < end && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n        if (start == end) {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, trailer));\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }",
    "fixed_code": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Trim all trailing NULs and spaces.\n        // The ustar and POSIX tar specs require a trailing NUL or\n        // space but some implementations use the extra digit for big\n        // sizes/uids/gids ...\n        byte trailer = buffer[end - 1];\n        while (start < end && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }",
    "fixed_lines": "",
    "masked_code": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Trim all trailing NULs and spaces.\n        // The ustar and POSIX tar specs require a trailing NUL or\n        // space but some implementations use the extra digit for big\n        // sizes/uids/gids ...\n        byte trailer = buffer[end - 1];\n        while (start < end && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n>>> [ INFILL ] <<<\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }",
    "project": "Compress",
    "test_error_message": "java.lang.IllegalArgumentException: Invalid byte 32 at offset 1 in ' {NUL}' len=2",
    "test_framework": "defects4j",
    "test_line": "        value = TarUtils.parseOctal(buffer,0, buffer.length);",
    "test_name": "testParseOctal",
    "test_suite": "org.apache.commons.compress.archivers.tar.TarUtilsTest",
    "time_buggy": "2014-04-18 14:29:36 +0000",
    "time_fixed": "2014-04-19 06:00:19 +0000",
    "bug_description": "Bug ID: 27\nProject: Compress\nBug Type: Software Hardware Software Failure (SH SF)\n\nBug Description Details:\n\n1. The bug is found in the software 'Compress', specifically in a method named 'parseOctal' which deals with the conversion of bytes and validation checks.\n\n2. The error message: java.lang.IllegalArgumentException: Invalid byte 32 at offset 1 in ' {NUL}' len=2, suggests that an IllegalArgumentException was thrown when the byte's value at index one of the array (offset 1) was invalid.\n\n3. In the Buggy Lines of this method:\n    if (start == end) {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, trailer));\n     }\nThe exception is thrown if the start equals the end, however, the exception's message was not clear about the actual error and didn't indicate the exact problem which made it difficult to understand the issue.\n\n4. The bug might have been a case where the start equals to end causing an IllegalArgumentException. This condition is problematic because it inhibits iterations on the buffer array.\n\n5. The issue might arise when the buffer array only contains leading spaces or trailing NULs and spaces which lead to a situation where start equals end.\n\n6. Considering the fixed code provided, it appears that there was no change made to the original method. This might be due to an external factor, such as invalid inputs being passed to the method triggering the exception, rather than there being an actual coding problem within the method.\n\nTo generate similar bugs, developers can:\n\na. Pass an array that only contains leading spaces or trailing NULs and spaces to the parseOctal method.\nb. Test cases where the length of the byte array is less than 2.\nc. Test cases where the byte array contains byte values less than '0' or greater than '7' (in ASCII), as this should throw an IllegalArgumentException.\nd. Test the array with different offsets and lengths. \n\nPlease ensure these test cases are included in your test suite. It will help developers identify bugs at early stages."
}