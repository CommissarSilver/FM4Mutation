{
    "bug_id": 19,
    "bug_type": "SH SF",
    "buggy_lines": "",
    "code": "    private void checkParameters() {\n        final double[] init = getStartPoint();\n        final double[] lB = getLowerBound();\n        final double[] uB = getUpperBound();\n\n        // Checks whether there is at least one finite bound value.\n        boolean hasFiniteBounds = false;\n        for (int i = 0; i < lB.length; i++) {\n            if (!Double.isInfinite(lB[i]) ||\n                !Double.isInfinite(uB[i])) {\n                hasFiniteBounds = true;\n                break;\n            }\n        }\n        // Checks whether there is at least one infinite bound value.\n        boolean hasInfiniteBounds = false;\n        if (hasFiniteBounds) {\n            for (int i = 0; i < lB.length; i++) {\n                if (Double.isInfinite(lB[i]) ||\n                    Double.isInfinite(uB[i])) {\n                    hasInfiniteBounds = true;\n                    break;\n                }\n            }\n\n            if (hasInfiniteBounds) {\n                // If there is at least one finite bound, none can be infinite,\n                // because mixed cases are not supported by the current code.\n                throw new MathUnsupportedOperationException();\n            } else {\n                // Convert API to internal handling of boundaries.\n                boundaries = new double[2][];\n                boundaries[0] = lB;\n                boundaries[1] = uB;\n\n                // Abort early if the normalization will overflow (cf. \"encode\" method).\n            }\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = null;\n        }\n\n        if (inputSigma != null) {\n            if (inputSigma.length != init.length) {\n                throw new DimensionMismatchException(inputSigma.length, init.length);\n            }\n            for (int i = 0; i < init.length; i++) {\n                if (inputSigma[i] < 0) {\n                    throw new NotPositiveException(inputSigma[i]);\n                }\n                if (boundaries != null) {\n                    if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                        throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                    }\n                }\n            }\n        }\n    }",
    "fixed_code": "    private void checkParameters() {\n        final double[] init = getStartPoint();\n        final double[] lB = getLowerBound();\n        final double[] uB = getUpperBound();\n\n        // Checks whether there is at least one finite bound value.\n        boolean hasFiniteBounds = false;\n        for (int i = 0; i < lB.length; i++) {\n            if (!Double.isInfinite(lB[i]) ||\n                !Double.isInfinite(uB[i])) {\n                hasFiniteBounds = true;\n                break;\n            }\n        }\n        // Checks whether there is at least one infinite bound value.\n        boolean hasInfiniteBounds = false;\n        if (hasFiniteBounds) {\n            for (int i = 0; i < lB.length; i++) {\n                if (Double.isInfinite(lB[i]) ||\n                    Double.isInfinite(uB[i])) {\n                    hasInfiniteBounds = true;\n                    break;\n                }\n            }\n\n            if (hasInfiniteBounds) {\n                // If there is at least one finite bound, none can be infinite,\n                // because mixed cases are not supported by the current code.\n                throw new MathUnsupportedOperationException();\n            } else {\n                // Convert API to internal handling of boundaries.\n                boundaries = new double[2][];\n                boundaries[0] = lB;\n                boundaries[1] = uB;\n\n                // Abort early if the normalization will overflow (cf. \"encode\" method).\n                for (int i = 0; i < lB.length; i++) {\n                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n                        final double max = Double.MAX_VALUE + boundaries[0][i];\n                        final NumberIsTooLargeException e\n                            = new NumberIsTooLargeException(boundaries[1][i],\n                                                            max,\n                                                            true);\n                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n                        e.getContext().addMessage(LocalizedFormats.INDEX, i);\n\n                        throw e;\n                    }\n                }\n            }\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = null;\n        }\n\n        if (inputSigma != null) {\n            if (inputSigma.length != init.length) {\n                throw new DimensionMismatchException(inputSigma.length, init.length);\n            }\n            for (int i = 0; i < init.length; i++) {\n                if (inputSigma[i] < 0) {\n                    throw new NotPositiveException(inputSigma[i]);\n                }\n                if (boundaries != null) {\n                    if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                        throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                    }\n                }\n            }\n        }\n    }",
    "fixed_lines": "                for (int i = 0; i < lB.length; i++) {\n                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n                        final double max = Double.MAX_VALUE + boundaries[0][i];\n                        final NumberIsTooLargeException e\n                            = new NumberIsTooLargeException(boundaries[1][i],\n                                                            max,\n                                                            true);\n                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n                        e.getContext().addMessage(LocalizedFormats.INDEX, i);\n\n                        throw e;\n                    }\n                }",
    "masked_code": "    private void checkParameters() {\n        final double[] init = getStartPoint();\n        final double[] lB = getLowerBound();\n        final double[] uB = getUpperBound();\n\n        // Checks whether there is at least one finite bound value.\n        boolean hasFiniteBounds = false;\n        for (int i = 0; i < lB.length; i++) {\n            if (!Double.isInfinite(lB[i]) ||\n                !Double.isInfinite(uB[i])) {\n                hasFiniteBounds = true;\n                break;\n            }\n        }\n        // Checks whether there is at least one infinite bound value.\n        boolean hasInfiniteBounds = false;\n        if (hasFiniteBounds) {\n            for (int i = 0; i < lB.length; i++) {\n                if (Double.isInfinite(lB[i]) ||\n                    Double.isInfinite(uB[i])) {\n                    hasInfiniteBounds = true;\n                    break;\n                }\n            }\n\n            if (hasInfiniteBounds) {\n                // If there is at least one finite bound, none can be infinite,\n                // because mixed cases are not supported by the current code.\n                throw new MathUnsupportedOperationException();\n            } else {\n                // Convert API to internal handling of boundaries.\n                boundaries = new double[2][];\n                boundaries[0] = lB;\n                boundaries[1] = uB;\n\n                // Abort early if the normalization will overflow (cf. \"encode\" method).\n>>> [ INFILL ] <<<\n            }\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = null;\n        }\n\n        if (inputSigma != null) {\n            if (inputSigma.length != init.length) {\n                throw new DimensionMismatchException(inputSigma.length, init.length);\n            }\n            for (int i = 0; i < init.length; i++) {\n                if (inputSigma[i] < 0) {\n                    throw new NotPositiveException(inputSigma[i]);\n                }\n                if (boundaries != null) {\n                    if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                        throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                    }\n                }\n            }\n        }\n    }",
    "project": "Math",
    "test_error_message": "java.lang.Exception: Unexpected exception, expected<org.apache.commons.math3.exception.NumberIsTooLargeException> but was<org.apache.commons.math3.exception.MathIllegalStateException>",
    "test_framework": "defects4j",
    "test_line": "                        throw new MathIllegalStateException();",
    "test_name": "testBoundaryRangeTooLarge",
    "test_suite": "org.apache.commons.math3.optimization.direct.CMAESOptimizerTest",
    "time_buggy": "2012-09-21 14:17:37 +0000",
    "time_fixed": "2012-09-21 15:32:18 +0000",
    "bug_description": "Bug Description:\n\nID: 19\nProject: Math\nBug Type: SH SF\nTest Error Message: java.lang.Exception: Unexpected exception, expected<org.apache.commons.math3.exception.NumberIsTooLargeException> but was<org.apache.commons.math3.exception.MathIllegalStateException>\n\nDetailed Steps:\n\n1. Our initial buggy code is part of a Math project. This application tries to implement mathematical functions and calculations.\n\n2. It contains a function named `checkParameters()`. The purpose of this function is to check parameters - specifically, to identify finite and infinite bounds within an array, and raises exceptions accordingly. \n\n3. Part of the code checks whether there is at least one finite and infinite bound values in two double type arrays `lB` and `uB`. If at least one finite bound and one infinite bound are found, it throws the exception `MathUnsupportedOperationException()`.\n\n4. The main issue comes when there is one finite and no infinite bounds in `lB` and `uB`. In this case, it moves forward to convert the API to internally handle the boundaries. It then immediately tries to normalize the bounds by subtracting the lower bound (lB) from the upper bound (uB). If the result is an infinite value, it does not handle this specific scenario and hence the main issue lies there.\n\n5. Since the application does not throw an expected exception (`NumberIsTooLargeException`), the actual exception thrown became `MathIllegalStateException`.\n\n6. The `java.lang.Exception` error message here indicates that the application failed to handle one particular case where the normalization of boundaries resulted in an infinite value, leading to the test case to fail.\n\n7. The fixed code added an extra logic to check if normalization of bounds becomes infinity. Before proceeding to normalization, it checks the value and if found infinity, it throws new exception `NumberIsTooLargeException()` which properly handles this specific case.\n\n8. This change solves the bug as the application can now correctly handle the case where the boundaries' normalization leads to overflow or infinities. It throws an appropriate exception instead of an unsupported operation exception, thereby aligning with the test case's expectations and pass the test case."
}