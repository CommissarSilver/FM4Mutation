{
    "bug_id": 25,
    "bug_type": "SF",
    "buggy_lines": "    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n      scope = traverse(arg, scope);\n    }",
    "code": "  private FlowScope traverseNew(Node n, FlowScope scope) {\n\n    Node constructor = n.getFirstChild();\n    scope = traverse(constructor, scope);\n    JSType constructorType = constructor.getJSType();\n    JSType type = null;\n    if (constructorType != null) {\n      constructorType = constructorType.restrictByNotNullOrUndefined();\n      if (constructorType.isUnknownType()) {\n        type = getNativeType(UNKNOWN_TYPE);\n      } else {\n        FunctionType ct = constructorType.toMaybeFunctionType();\n        if (ct == null && constructorType instanceof FunctionType) {\n          // If constructorType is a NoObjectType, then toMaybeFunctionType will\n          // return null. But NoObjectType implements the FunctionType\n          // interface, precisely because it can validly construct objects.\n          ct = (FunctionType) constructorType;\n        }\n        if (ct != null && ct.isConstructor()) {\n          type = ct.getInstanceType();\n        }\n      }\n    }\n    n.setJSType(type);\n    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n      scope = traverse(arg, scope);\n    }\n    return scope;\n  }",
    "fixed_code": "  private FlowScope traverseNew(Node n, FlowScope scope) {\n    scope = traverseChildren(n, scope);\n\n    Node constructor = n.getFirstChild();\n    JSType constructorType = constructor.getJSType();\n    JSType type = null;\n    if (constructorType != null) {\n      constructorType = constructorType.restrictByNotNullOrUndefined();\n      if (constructorType.isUnknownType()) {\n        type = getNativeType(UNKNOWN_TYPE);\n      } else {\n        FunctionType ct = constructorType.toMaybeFunctionType();\n        if (ct == null && constructorType instanceof FunctionType) {\n          // If constructorType is a NoObjectType, then toMaybeFunctionType will\n          // return null. But NoObjectType implements the FunctionType\n          // interface, precisely because it can validly construct objects.\n          ct = (FunctionType) constructorType;\n        }\n        if (ct != null && ct.isConstructor()) {\n          type = ct.getInstanceType();\n          backwardsInferenceFromCallSite(n, ct);\n        }\n      }\n    }\n    n.setJSType(type);\n    return scope;\n  }",
    "fixed_lines": "          backwardsInferenceFromCallSite(n, ct);",
    "masked_code": "  private FlowScope traverseNew(Node n, FlowScope scope) {\n\n    Node constructor = n.getFirstChild();\n    JSType constructorType = constructor.getJSType();\n    JSType type = null;\n    if (constructorType != null) {\n      constructorType = constructorType.restrictByNotNullOrUndefined();\n      if (constructorType.isUnknownType()) {\n        type = getNativeType(UNKNOWN_TYPE);\n      } else {\n        FunctionType ct = constructorType.toMaybeFunctionType();\n        if (ct == null && constructorType instanceof FunctionType) {\n          // If constructorType is a NoObjectType, then toMaybeFunctionType will\n          // return null. But NoObjectType implements the FunctionType\n          // interface, precisely because it can validly construct objects.\n          ct = (FunctionType) constructorType;\n        }\n        if (ct != null && ct.isConstructor()) {\n          type = ct.getInstanceType();\n        }\n      }\n    }\n    n.setJSType(type);\n>>> [ INFILL ] <<<\n    return scope;\n  }",
    "project": "Closure",
    "test_error_message": "junit.framework.ComparisonFailure: expected:<{[foo: (number|undefined)]}> but was:<{[]}>",
    "test_framework": "defects4j",
    "test_line": "    assertEquals(\"{foo: (number|undefined)}\", getType(\"y\").toString());",
    "test_name": "testBackwardsInferenceNew",
    "test_suite": "com.google.javascript.jscomp.TypeInferenceTest",
    "time_buggy": "2012-05-18 23:57:52 +0000",
    "time_fixed": "2012-05-18 23:58:44 +0000",
    "bug_description": "Bug ID: 25\n\nProject: Closure\n\nBug Type: Semantic Fault (SF)\n\nDescription:\n\nThis bug pertains to the \"Closure\" project and its occurrence is marked as a Semantic Fault. The test error message reveals a \"junit.framework.ComparisonFailure\", suggesting that the expected output did not align with the retrieved result. Here the expected result was '<{[foo: (number|undefined)]}>', but the output was empty '<{[]}>'. \n\nBuggy code section:\nWithin the \"traverseNew\" method, the buggy lines lie within the for-loop, where the function \"traverse(arg, scope)\" was used.\n\nThe original (buggy) code section is as follows:\n```\nfor (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n  scope = traverse(arg, scope);\n}\n```\n\nProblem details:\n\nIn the code, the method traverse(arg, scope) was supposed to change the 'scope' depending on each node (arg) linked to the 'constructor' node. However, the error message shows a discrepancy between the expected and retrieved outputs suggesting an issue with the way nodes are traversed, or the way 'scope' is being set or updated. \n\nRectified/Fixed Code:\n\nIn the fixed code, the iteration over the nodes linked to the 'constructor' node is removed, and instead, the method traverseChildren(n, scope) is used right at the start. \n\n```\nscope = traverseChildren(n, scope);\n```\n\nThis change indicates that the incorrect output may have been due to erroneous iterations and 'scope' set in the for-loop.\n\nTo replicate this Semantic Fault artificially, developers need to body a for-loop that navigates through various nodes linked to a 'constructor' node and involves an operation that updates a shared variable (i.e., 'scope' in this case). The for-loop should have an issue leading to a different scope being set, leading to incorrect retrieval output. The intended correct behavior shall involve traversing all the children of the node and setting the scope right at the start, before advancing to other operations."
}