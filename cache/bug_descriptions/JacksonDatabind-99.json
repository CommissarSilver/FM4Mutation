{
    "bug_id": 99,
    "bug_type": "SL SH SF",
    "buggy_lines": "",
    "code": "    protected String buildCanonicalName()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n        sb.append('<');\n        sb.append(_referencedType.toCanonical());\n        return sb.toString();\n    }",
    "fixed_code": "    protected String buildCanonicalName()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n        sb.append('<');\n        sb.append(_referencedType.toCanonical());\n        sb.append('>');\n        return sb.toString();\n    }",
    "fixed_lines": "        sb.append('>');",
    "masked_code": "    protected String buildCanonicalName()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n        sb.append('<');\n        sb.append(_referencedType.toCanonical());\n>>> [ INFILL ] <<<\n        return sb.toString();\n    }",
    "project": "JacksonDatabind",
    "test_error_message": "junit.framework.ComparisonFailure: expected:<...rence<java.lang.Long[>]> but was:<...rence<java.lang.Long[]>",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(\"java.util.concurrent.atomic.AtomicReference<java.lang.Long>\",",
    "test_name": "testCanonicalNames",
    "test_suite": "com.fasterxml.jackson.databind.type.TestTypeFactory",
    "time_buggy": "2018-06-07 22:49:25 -0700",
    "time_fixed": "2018-08-15 07:13:38 -0700",
    "bug_description": "Bug Title: JacksonDatabind project bug with mishandling string concatenation in buildCanonicalName method \n\nBug ID: 99\n\nProject Name: JacksonDatabind\n\nBug Type: SL SH SF (Single Literal, Single Hanger, Single Fix)\n\nDescription:\nThe bug is found in the 'buildCanonicalName' method in the class in the 'JacksonDatabind' project. The issue arises when the method is trying to build and return a canonical name. Specifically, the error is tied to the incorrect handling of string concatenation operation. \n\nFunctional Issue:\nThe error message from the test indicates a comparison failure. The expected format of the string was missing a '>' symbol. The string format that the test expected was '<java.lang.Long[>]>' but what was actually returned by the method was '<java.lang.Long[]'. The system was expected to cover all types and arrays representing the type canonical but it got stuck on the array type.\n\nTechnical Issue:\nLooking at the buggy code, the buildCanonicalName method does not append the closing '>' of the canonical representation, thus resulting in an error on the test expecting the right format. Here is the buggy code below: \n\n```java\nprotected String buildCanonicalName()\n    {\n    StringBuilder sb = new StringBuilder();\n    sb.append(_class.getName());\n    sb.append('<');\n    sb.append(_referencedType.toCanonical());\n    return sb.toString();\n    }\n```\nThe closing '>' was not included in the concatenated string, which led to an incorrect representation of the canonical name.\n\nIn the fixed code, the developer included the closing '>' in the string concatenation which makes the code now correctly generate the canonical name. Here is the corrected code:\n\n```java\nprotected String buildCanonicalName()\n    {\n    StringBuilder sb = new StringBuilder();\n    sb.append(_class.getName());\n    sb.append('<');\n    sb.append(_referencedType.toCanonical());\n    sb.append('>');\n    return sb.toString();\n    }\n```\n\nSteps to reproduce:\n1. Call the buildCanonicalName method with the parameter, '_class' having the name that maps to a class name and '_referencedType' mapping to a long Array type.\n2. The method will return a canonical name without the closing '>'.\n3. Run any unit test that validates if the returned canonical name matches the expected format.\n4. This will result in the comparison failure that we currently observe.\n\nThis was addressed by integrating the '>' character into the final string returned by the 'buildCanonicalName' method."
}