{
    "bug_id": 19,
    "bug_type": "SF",
    "buggy_lines": "            tokens.add(token);\n            tokens.add(token);",
    "code": "    private void processOptionToken(String token, boolean stopAtNonOption)\n    {\n        if (options.hasOption(token))\n        {\n            currentOption = options.getOption(token);\n            tokens.add(token);\n        }\n        else if (stopAtNonOption)\n        {\n            eatTheRest = true;\n            tokens.add(token);\n        }\n    }",
    "fixed_code": "    private void processOptionToken(String token, boolean stopAtNonOption)\n    {\n        if (options.hasOption(token))\n        {\n            currentOption = options.getOption(token);\n        }\n        else if (stopAtNonOption)\n        {\n            eatTheRest = true;\n        }\n\n        tokens.add(token);\n    }",
    "fixed_lines": "\n        tokens.add(token);",
    "masked_code": "    private void processOptionToken(String token, boolean stopAtNonOption)\n    {\n        if (options.hasOption(token))\n        {\n            currentOption = options.getOption(token);\n        }\n        else if (stopAtNonOption)\n        {\n            eatTheRest = true;\n        }\n>>> [ INFILL ] <<<\n    }",
    "project": "Cli",
    "test_error_message": "junit.framework.AssertionFailedError: UnrecognizedOptionException wasn't thrown",
    "test_framework": "defects4j",
    "test_line": "            fail(\"UnrecognizedOptionException wasn't thrown\");",
    "test_name": "testUnrecognizedOption2",
    "test_suite": "org.apache.commons.cli.PosixParserTest",
    "time_buggy": "2008-07-28 08:27:46 +0000",
    "time_fixed": "2008-07-28 08:43:28 +0000",
    "bug_description": "Bug ID: 19\n\nProject: Cli\n\nBug Type: Semantic Fault (SF)\n\nBug Description: \nThe bug in the project 'Cli' is of type Semantic Fault (SF). The error message obtained from the test was: `junit.framework.AssertionFailedError: UnrecognizedOptionException wasn't thrown`. This indicates that there was a failed assertion due to an exception that was not thrown as anticipated during the unit test.\n\nBuggy Code:\n\nIn the below section of the code:\n\n    private void processOptionToken(String token, boolean stopAtNonOption)\n    {\n        if (options.hasOption(token))\n        {\n            currentOption = options.getOption(token);\n            tokens.add(token);\n        }\n        else if (stopAtNonOption)\n        {\n            eatTheRest = true;\n            tokens.add(token);\n        }\n    }\n\nThe method `processOptionToken` is expected to process a token and determine whether it is an option or not. If it is an option, it is added to a list of tokens and if not, dependent on `stopAtNonOption`, the processing either stops or continues. The issue here lies in that the token is added to the list in both the `if` and `else if` clauses, which may cause potentially incorrect tokens to be added when they should not be. \n\nThis can lead to errors later on where checks that use the tokens list may fail or result in unexpected behavior as it might contain tokens that should not be present.\n\nFixed Code:\n\nThe code is fixed by moving the line `tokens.add(token);` outside of the `if` and `else if` statements to ensure that the token is always added, regardless of whether it is a valid option or not:\n\n    private void processOptionToken(String token, boolean stopAtNonOption)\n    {\n        if (options.hasOption(token))\n        {\n            currentOption = options.getOption(token);\n        }\n        else if (stopAtNonOption)\n        {\n            eatTheRest = true;\n        }\n\n        tokens.add(token);\n    }\n\nIn the fixed code, the addition of the token to the list is moved outside the branching structure. This guarantees that, regardless of the path taken by the code, all tokens are added to the list once processed, ensuring the integrity and consistency of the tokens list."
}