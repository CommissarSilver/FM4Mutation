{
    "bug_id": 38,
    "bug_type": "SF",
    "buggy_lines": "        return options.hasShortOption(optName);",
    "code": "    private boolean isShortOption(String token)\n    {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        // remove leading \"-\" and \"=value\"\n        int pos = token.indexOf(\"=\");\n        String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        return options.hasShortOption(optName);\n        // check for several concatenated short options\n    }",
    "fixed_code": "    private boolean isShortOption(String token)\n    {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        // remove leading \"-\" and \"=value\"\n        int pos = token.indexOf(\"=\");\n        String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        if (options.hasShortOption(optName))\n        {\n            return true;\n        }\n        // check for several concatenated short options\n        return optName.length() > 0 && options.hasShortOption(String.valueOf(optName.charAt(0)));\n    }",
    "fixed_lines": "        if (options.hasShortOption(optName))\n        {\n            return true;\n        }\n        return optName.length() > 0 && options.hasShortOption(String.valueOf(optName.charAt(0)));",
    "masked_code": "    private boolean isShortOption(String token)\n    {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        // remove leading \"-\" and \"=value\"\n        int pos = token.indexOf(\"=\");\n        String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        // check for several concatenated short options\n>>> [ INFILL ] <<<\n    }",
    "project": "Cli",
    "test_error_message": "junit.framework.AssertionFailedError: expected null, but was:<-ab>",
    "test_framework": "defects4j",
    "test_line": "        assertNull(commandLine.getOptionValue(\"t1\"));",
    "test_name": "shouldParseConcatenatedShortOptions",
    "test_suite": "org.apache.commons.cli.bug.BugCLI265Test",
    "time_buggy": "2016-09-07 20:20:04 +0000",
    "time_fixed": "2016-09-08 05:36:59 +0000",
    "bug_description": "Bug ID: 38\nProject: Cli\nBug Type: SF (Special Functional)\n\n1. Description:\nThe bug is located in the method isShortOption() of the CLI project, which is responsible for checking if a string representing a command line option is a short option or not. The test error message indicates that the expected output was null, but the method returns <-ab> instead.\n\n2. Problem Identification:\nThe buggy line is \"return options.hasShortOption(optName);\". The issue here is the function does not properly handle cases where several concatenated short options are passed in the argument string. \n\n3. Problem Replication:\nThe error can be reproduced by trying to test the cli application with a concatenated short option that doesn't exist, such as \"-ab\". The function will return 'true' even for those options, hence the assertionError.\n\n4. Bug Source:\nThe source of the bug is in the logic for checking a short option. When the string containing concatenated options, (i.e., \"-ab\") where each letter represents an option, is passed to the function as a token, and \"-ab\" is not in the options list, it returns false. Which is not the expected result, as it should return true for both \"-a\" and \"-b\" if existing individually.\n\n5. Fix:\nThe provided fixed code introduced a condition to check for each option internally if the provided token is a concatenated short option string. If any of the individual options exists, the function will return true, else false.  \n\n6. Bug Verification:\nThe verification of the bug can be done by running unit tests for the function using various scenarios, including the scenario which initially caused the bug to reproduce. When the fixed code passes the newly generated test case for concatenated short options, the bug is then considered as resolved."
}