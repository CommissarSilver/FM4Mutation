{
    "bug_id": 24,
    "bug_type": "SH SF",
    "buggy_lines": "",
    "code": "    public long computeMillis(boolean resetFields, String text) {\n        SavedField[] savedFields = iSavedFields;\n        int count = iSavedFieldsCount;\n        if (iSavedFieldsShared) {\n            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n            iSavedFieldsShared = false;\n        }\n        sort(savedFields, count);\n        if (count > 0) {\n            // alter base year for parsing if first field is month or day\n            DurationField months = DurationFieldType.months().getField(iChrono);\n            DurationField days = DurationFieldType.days().getField(iChrono);\n            DurationField first = savedFields[0].iField.getDurationField();\n            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n                saveField(DateTimeFieldType.year(), iDefaultYear);\n                return computeMillis(resetFields, text);\n            }\n        }\n\n        long millis = iMillis;\n        try {\n            for (int i = 0; i < count; i++) {\n                millis = savedFields[i].set(millis, resetFields);\n            }\n        } catch (IllegalFieldValueException e) {\n            if (text != null) {\n                e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n            }\n            throw e;\n        }\n        \n        if (iZone == null) {\n            millis -= iOffset;\n        } else {\n            int offset = iZone.getOffsetFromLocal(millis);\n            millis -= offset;\n            if (offset != iZone.getOffset(millis)) {\n                String message =\n                    \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n                if (text != null) {\n                    message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n                }\n                throw new IllegalArgumentException(message);\n            }\n        }\n        \n        return millis;\n    }",
    "fixed_code": "    public long computeMillis(boolean resetFields, String text) {\n        SavedField[] savedFields = iSavedFields;\n        int count = iSavedFieldsCount;\n        if (iSavedFieldsShared) {\n            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n            iSavedFieldsShared = false;\n        }\n        sort(savedFields, count);\n        if (count > 0) {\n            // alter base year for parsing if first field is month or day\n            DurationField months = DurationFieldType.months().getField(iChrono);\n            DurationField days = DurationFieldType.days().getField(iChrono);\n            DurationField first = savedFields[0].iField.getDurationField();\n            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n                saveField(DateTimeFieldType.year(), iDefaultYear);\n                return computeMillis(resetFields, text);\n            }\n        }\n\n        long millis = iMillis;\n        try {\n            for (int i = 0; i < count; i++) {\n                millis = savedFields[i].set(millis, resetFields);\n            }\n            if (resetFields) {\n                for (int i = 0; i < count; i++) {\n                    millis = savedFields[i].set(millis, i == (count - 1));\n                }\n            }\n        } catch (IllegalFieldValueException e) {\n            if (text != null) {\n                e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n            }\n            throw e;\n        }\n        \n        if (iZone == null) {\n            millis -= iOffset;\n        } else {\n            int offset = iZone.getOffsetFromLocal(millis);\n            millis -= offset;\n            if (offset != iZone.getOffset(millis)) {\n                String message =\n                    \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n                if (text != null) {\n                    message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n                }\n                throw new IllegalArgumentException(message);\n            }\n        }\n        \n        return millis;\n    }",
    "fixed_lines": "            if (resetFields) {\n                for (int i = 0; i < count; i++) {\n                    millis = savedFields[i].set(millis, i == (count - 1));\n                }\n            }",
    "masked_code": "    public long computeMillis(boolean resetFields, String text) {\n        SavedField[] savedFields = iSavedFields;\n        int count = iSavedFieldsCount;\n        if (iSavedFieldsShared) {\n            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n            iSavedFieldsShared = false;\n        }\n        sort(savedFields, count);\n        if (count > 0) {\n            // alter base year for parsing if first field is month or day\n            DurationField months = DurationFieldType.months().getField(iChrono);\n            DurationField days = DurationFieldType.days().getField(iChrono);\n            DurationField first = savedFields[0].iField.getDurationField();\n            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n                saveField(DateTimeFieldType.year(), iDefaultYear);\n                return computeMillis(resetFields, text);\n            }\n        }\n\n        long millis = iMillis;\n        try {\n            for (int i = 0; i < count; i++) {\n                millis = savedFields[i].set(millis, resetFields);\n            }\n>>> [ INFILL ] <<<\n        } catch (IllegalFieldValueException e) {\n            if (text != null) {\n                e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n            }\n            throw e;\n        }\n        \n        if (iZone == null) {\n            millis -= iOffset;\n        } else {\n            int offset = iZone.getOffsetFromLocal(millis);\n            millis -= offset;\n            if (offset != iZone.getOffset(millis)) {\n                String message =\n                    \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n                if (text != null) {\n                    message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n                }\n                throw new IllegalArgumentException(message);\n            }\n        }\n        \n        return millis;\n    }",
    "project": "Time",
    "test_error_message": "junit.framework.AssertionFailedError: expected:<2010-01-04> but was:<2008-12-29>",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(new LocalDate(2010, 1, 4, chrono), f.parseLocalDate(\"2010-01-01\"));",
    "test_name": "testParseLocalDate_weekyear_month_week_2010",
    "test_suite": "org.joda.time.format.TestDateTimeFormatter",
    "time_buggy": "2011-02-15 11:08:56 +0000",
    "time_fixed": "2011-02-15 14:53:51 +0000",
    "bug_description": "Bug ID: 24\nProject: Time\nBug Type: Semantic bug (SH SF)\n\nStep 1 - Problem Overview:\nThis bug is related to incorrect time parsing in the Time project. More specifically, an AssertionError was encountered during test execution implying incorrect parsing and highlighting an inconsistency between expected and actual date values. The faulty code involves a method, computeMillis, which does the time parsing.\n\nStep 2 - Failing Test:\nThe failing output is noted from the test error message: junit.framework.AssertionFailedError: expected: <2010-01-04> but was: <2008-12-29>\n\nStep 3 - Faulty Code:\nThe bug is majorly mediated by the computeMillis method within the SavedField class. The computeMillis method should properly parse and adjust datetime values, but is not working as expected. The bug focuses on the block of code, where the function savedFields[i].set(millis, resetFields) is being called. It seems like the function \"set()\" is called correctly, but the arguments \"millis\" and \"resetFields\" are not right, hence generating the incorrect results.\n\nStep 4 - Fix Implementation:\nThe fix has been implemented in the SavedField array within the computeMillis method. Besides the previous call to method \"set()\", an additional conditional check is implemented to ensure \"set()\" is called correctly with accurate parameters. This check comes in the form of the loop, where the condition (if resetFields) is used to decide how and when to call the \"set()\" method.\n\nStep 5 - Fixed Code:\nIn the fixed version of the code, an extra loop has been introduced which will run only if resetFields is true. This loop makes another call to \"set()\" method but the boolean argument is only true for the last field. This alteration in the argument of the set method during the second parsing of saved fields effectively corrects the time parsing inconsistencies and resolves the issue. \n\nThis bug underlines the necessity of thorough semantic validation with ambiguous parameters like \"resetFields\" being used in crucial procedural methods like \"set()\" in time processing applications."
}