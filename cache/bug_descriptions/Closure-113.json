{
    "bug_id": 113,
    "bug_type": "SL SH SF",
    "buggy_lines": "      if (provided != null) {",
    "code": "  private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n    Node left = n.getFirstChild();\n    Node arg = left.getNext();\n    if (verifyLastArgumentIsString(t, left, arg)) {\n      String ns = arg.getString();\n      ProvidedName provided = providedNames.get(ns);\n      if (provided == null || !provided.isExplicitlyProvided()) {\n        unrecognizedRequires.add(\n            new UnrecognizedRequire(n, ns, t.getSourceName()));\n      } else {\n        JSModule providedModule = provided.explicitModule;\n\n        // This must be non-null, because there was an explicit provide.\n        Preconditions.checkNotNull(providedModule);\n\n        JSModule module = t.getModule();\n        if (moduleGraph != null &&\n            module != providedModule &&\n            !moduleGraph.dependsOn(module, providedModule)) {\n          compiler.report(\n              t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                  providedModule.getName(),\n                  module.getName()));\n        }\n      }\n\n      maybeAddToSymbolTable(left);\n      maybeAddStringNodeToSymbolTable(arg);\n\n      // Requires should be removed before further processing.\n      // Some clients run closure pass multiple times, first with\n      // the checks for broken requires turned off. In these cases, we\n      // allow broken requires to be preserved by the first run to\n      // let them be caught in the subsequent run.\n      if (provided != null) {\n        parent.detachFromParent();\n        compiler.reportCodeChange();\n      }\n    }\n  }",
    "fixed_code": "  private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n    Node left = n.getFirstChild();\n    Node arg = left.getNext();\n    if (verifyLastArgumentIsString(t, left, arg)) {\n      String ns = arg.getString();\n      ProvidedName provided = providedNames.get(ns);\n      if (provided == null || !provided.isExplicitlyProvided()) {\n        unrecognizedRequires.add(\n            new UnrecognizedRequire(n, ns, t.getSourceName()));\n      } else {\n        JSModule providedModule = provided.explicitModule;\n\n        // This must be non-null, because there was an explicit provide.\n        Preconditions.checkNotNull(providedModule);\n\n        JSModule module = t.getModule();\n        if (moduleGraph != null &&\n            module != providedModule &&\n            !moduleGraph.dependsOn(module, providedModule)) {\n          compiler.report(\n              t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                  providedModule.getName(),\n                  module.getName()));\n        }\n      }\n\n      maybeAddToSymbolTable(left);\n      maybeAddStringNodeToSymbolTable(arg);\n\n      // Requires should be removed before further processing.\n      // Some clients run closure pass multiple times, first with\n      // the checks for broken requires turned off. In these cases, we\n      // allow broken requires to be preserved by the first run to\n      // let them be caught in the subsequent run.\n      if (provided != null || requiresLevel.isOn()) {\n        parent.detachFromParent();\n        compiler.reportCodeChange();\n      }\n    }\n  }",
    "fixed_lines": "      if (provided != null || requiresLevel.isOn()) {",
    "masked_code": "  private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n    Node left = n.getFirstChild();\n    Node arg = left.getNext();\n    if (verifyLastArgumentIsString(t, left, arg)) {\n      String ns = arg.getString();\n      ProvidedName provided = providedNames.get(ns);\n      if (provided == null || !provided.isExplicitlyProvided()) {\n        unrecognizedRequires.add(\n            new UnrecognizedRequire(n, ns, t.getSourceName()));\n      } else {\n        JSModule providedModule = provided.explicitModule;\n\n        // This must be non-null, because there was an explicit provide.\n        Preconditions.checkNotNull(providedModule);\n\n        JSModule module = t.getModule();\n        if (moduleGraph != null &&\n            module != providedModule &&\n            !moduleGraph.dependsOn(module, providedModule)) {\n          compiler.report(\n              t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                  providedModule.getName(),\n                  module.getName()));\n        }\n      }\n\n      maybeAddToSymbolTable(left);\n      maybeAddStringNodeToSymbolTable(arg);\n\n      // Requires should be removed before further processing.\n      // Some clients run closure pass multiple times, first with\n      // the checks for broken requires turned off. In these cases, we\n      // allow broken requires to be preserved by the first run to\n      // let them be caught in the subsequent run.\n>>> [ INFILL ] <<<\n        parent.detachFromParent();\n        compiler.reportCodeChange();\n      }\n    }\n  }",
    "project": "Closure",
    "test_error_message": "junit.framework.AssertionFailedError: There should be one error. required \"namespace.Class1\" namespace never provided",
    "test_framework": "defects4j",
    "test_line": "    test(\"goog.require('namespace.Class1');\\n\", null,",
    "test_name": "testNoUndeclaredVarWhenUsingClosurePass",
    "test_suite": "com.google.javascript.jscomp.VarCheckTest",
    "time_buggy": "2013-10-04 16:48:52 -0700",
    "time_fixed": "2013-10-04 16:50:10 -0700",
    "bug_description": "Bug ID: 113\n\nTitle: Failure on Providing Required Namespace \n\nSeverity: High\n\nBug Type: Syntax Logical Semantical (SL SH SF)\n\nDescription: \nThe Closure project encountered a bug while attempting to process the require call in the method 'processRequireCall'. When executing a test, an AssertionFailedError was raised, stating that an object 'namespace.Class1' is required but never provided. This is a result of the 'provided != null' condition in the code which bypasses the message to preserve broken requires for subsequent runs. \n\nSteps to Reproduce:\nThis bug occurs during the execution of the method 'processRequireCall' when the required namespace (in this case 'namespace.Class1') is not found during the processing. \n1. Call the method processRequireCall with a Node that does not have the required namespace.\n2. Process to the line 'if (provided != null)'.\n3. If the required namespace is not provided or recognized, the error is falsely bypassed due to the above condition.\n\nBuggy Lines:\nThe identified buggy line lies within the 'processRequireCall' method:\n\n```\nif (provided != null) {\n```\n\nExpected Behaviour:\nAn error should be produced indicating that the required \"namespace.Class1\" namespace is never provided. The application should not continue as if no error has occurred.\n\nActual Behaviour:\nThe application continues running, despite the error that the required namespace is not provided. \n\nProposed Fix:\nAdd an extra conditional check to the 'if' condition that cross-checks if requires level is on before detaching from parent:\n\n```\nif (provided != null || requiresLevel.isOn()) {\n```\n\nThis fix ensures that broken requires are caught early in subsequent runs, thus preventing illegal states of the application."
}