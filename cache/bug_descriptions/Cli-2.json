{
    "bug_id": 2,
    "bug_type": "SF",
    "buggy_lines": "                tokens.add(\"-\" + ch);\n}",
    "code": "    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        int tokenLength = token.length();\n\n        for (int i = 1; i < tokenLength; i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n            boolean hasOption = options.hasOption(ch);\n\n            if (hasOption)\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n            }\n            else\n            {\n                tokens.add(\"-\" + ch);\n            }\n        }\n    }",
    "fixed_code": "    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        int tokenLength = token.length();\n\n        for (int i = 1; i < tokenLength; i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n            boolean hasOption = options.hasOption(ch);\n\n            if (hasOption)\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }",
    "fixed_lines": "                tokens.add(token);\n                break;\n}",
    "masked_code": "    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        int tokenLength = token.length();\n\n        for (int i = 1; i < tokenLength; i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n            boolean hasOption = options.hasOption(ch);\n\n            if (hasOption)\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n            }\n            else\n            {\n>>> [ INFILL ] <<<\n            }\n        }\n    }",
    "project": "Cli",
    "test_error_message": "org.apache.commons.cli.UnrecognizedOptionException: Unrecognized option: -o",
    "test_framework": "defects4j",
    "test_line": "        commandLine = parser.parse( options, args );",
    "test_name": "test",
    "test_suite": "org.apache.commons.cli.bug.BugCLI51Test",
    "time_buggy": "2007-05-15 00:47:38 +0000",
    "time_fixed": "2007-05-22 17:47:16 +0000",
    "bug_description": "Bug ID: 2\n\nTitle: Unrecognized Option Exception in CLI token bursting method.\n\nSummary: The system is throwing an UnrecognizedOptionException due to a bug in the \"burstToken\" method in the CLI Project. When the system parses a token that it does not recognize, it responds with an error instead of processing the rest of the string.\n\nEnvironment: The bug has been identified in the CLI Project.\n\nSteps to Reproduce:\n1. Pass a command line argument that includes an option not recognized by the application.\n2. When the token parsing loop reaches this option, it will trigger an UnrecognizedOptionException. This is because the option is added directly on the tokens list even if it is not a recognized option.\n\nExpected Result:\nThe system should continue processing the rest of the string even if it encounters an unrecognized option.\n\nActual Result:\nAn UnrecognizedOptionException is thrown, causing the application to close prematurely.\n\nCode Snippet with Bug:\n```java\nelse\n{\n    tokens.add(\"-\" + ch);\n}\n```\n\nDescription of the Code Bug: The desired functionality was for the application to continue processing the remaining string even if it encountered an unrecognized option. However, in the existing implementation, the code is adding an unrecognized option directly to the tokens list, which leads to the UnrecognizedOptionException being thrown.\n\nFix:\nThe issue was resolved by modifying the condition where it adds the full token to the tokens list if the option is not recognized, and then breaks the loop. This ensures that the loop stops processing further when an unrecognized option is encountered, preventing the exception.\n\nCode With Bug Fix:\n```java\nelse\n{\n    tokens.add(token);\n    break;\n}\n```\n\nThis fix bypasses the unrecognized option and prevents breaking the application. It allows the program to continue processing remaining string tokens as expected."
}