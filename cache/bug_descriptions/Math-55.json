{
    "bug_id": 55,
    "bug_type": "SF",
    "buggy_lines": "      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);",
    "code": "  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n\n\n      // rescale both vectors without losing precision,\n      // to ensure their norm are the same order of magnitude\n\n      // we reduce cancellation errors by preconditioning,\n      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n      // v3 without loss of precision. See Kahan lecture\n      // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n      // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n\n      // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n\n\n      // compute cross product from v3 and v2 instead of v1 and v2\n      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n\n  }",
    "fixed_code": "  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n\n      final double n1 = v1.getNormSq();\n      final double n2 = v2.getNormSq();\n      if ((n1 * n2) < MathUtils.SAFE_MIN) {\n          return ZERO;\n      }\n\n      // rescale both vectors without losing precision,\n      // to ensure their norm are the same order of magnitude\n      final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;\n      final double x1    = FastMath.scalb(v1.x, -deltaExp);\n      final double y1    = FastMath.scalb(v1.y, -deltaExp);\n      final double z1    = FastMath.scalb(v1.z, -deltaExp);\n      final double x2    = FastMath.scalb(v2.x,  deltaExp);\n      final double y2    = FastMath.scalb(v2.y,  deltaExp);\n      final double z2    = FastMath.scalb(v2.z,  deltaExp);\n\n      // we reduce cancellation errors by preconditioning,\n      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n      // v3 without loss of precision. See Kahan lecture\n      // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n      // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n\n      // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);\n      final double rho   = FastMath.rint(256 * ratio) / 256;\n\n      final double x3 = x1 - rho * x2;\n      final double y3 = y1 - rho * y2;\n      final double z3 = z1 - rho * z2;\n\n      // compute cross product from v3 and v2 instead of v1 and v2\n      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);\n\n  }",
    "fixed_lines": "      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);\n      final double rho   = FastMath.rint(256 * ratio) / 256;\n      final double x3 = x1 - rho * x2;\n      final double y3 = y1 - rho * y2;\n      final double z3 = z1 - rho * z2;\n      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);",
    "masked_code": "  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n\n\n      // rescale both vectors without losing precision,\n      // to ensure their norm are the same order of magnitude\n\n      // we reduce cancellation errors by preconditioning,\n      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n      // v3 without loss of precision. See Kahan lecture\n      // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n      // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n\n      // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n\n\n      // compute cross product from v3 and v2 instead of v1 and v2\n>>> [ INFILL ] <<<\n\n  }",
    "project": "Math",
    "test_error_message": "junit.framework.AssertionFailedError: expected:<1.0> but was:<0.0>",
    "test_framework": "defects4j",
    "test_line": "        Assert.assertEquals(z, v.getZ(), 1.0e-12);",
    "test_name": "testCrossProductCancellation",
    "test_suite": "org.apache.commons.math.geometry.Vector3DTest",
    "time_buggy": "2011-04-03 14:33:00 +0000",
    "time_fixed": "2011-04-03 14:33:29 +0000",
    "bug_description": "Bug ID: 55\nProject: Math\nBug Type: SF (Software Fault)\n\nDescription:\n\nThe bug was found in the `crossProduct` method of a Vector3D class in the Math project. The method is supposed to return the cross product of two vector3D instances passed as parameters.\n\nThe bug was caught with unit testing that expected a return value of <1.0> but got <0.0> instead, throwing a junit.framework.AssertionFailedError. As indicated by the test error message, the returned value was not as expected.\n\nThe erroneous line of code was `return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);`. In this line, the cross product was calculated without any consideration of the magnitudes of the vectors v1 and v2 or any potential precision, scaling, and cancellation errors that may occur due to their arithmetic combination.\n\nThe fix involved a reimplementation of the entire `crossProduct` function. The fixed code included steps to rescale the vectors without losing precision to ensure their norms are of the same order of magnitude. This was done using the `FastMath.scalb` function in the Apache Commons Math library. Additionally, the preconditioning step was introduced to mitigate cancellation errors. The new vectors were calculated and the cross product was recalculated with these vectors instead of the original ones.\n\nIn terms of generating artificial bugs similar to this:\n\nStep 1: Develop a method/function that involves arithmetic combination such as addition, subtraction, or multiplication between instances/objects of a class. Do not introduce any consideration for magnitudes, precision, or potential for cancellation errors.\n\nStep 2: Develop unit tests for checking the correctness of the implementation.\n\nStep 3: When the test uncovers an error (ideally an assertion error where expected and actual results do not match), investigate the issue in the code.\n\nStep 4: To fix the bug, reintroduce precision control or adjust for potential cancellation/rounding errors, and correct your implementation.\n\nStep 5: Rerun the tests and confirm whether the bug has been fixed correctly."
}