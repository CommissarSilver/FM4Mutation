{
    "bug_id": 8,
    "bug_type": "SL SH SF",
    "buggy_lines": "            } else {",
    "code": "        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            if (actualTypeArgument instanceof WildcardType) {\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n            } else {\n                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n            // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n        }",
    "fixed_code": "        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            if (actualTypeArgument instanceof WildcardType) {\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n            } else if (typeParameter != actualTypeArgument) {\n                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n            // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n        }",
    "fixed_lines": "            } else if (typeParameter != actualTypeArgument) {",
    "masked_code": "        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            if (actualTypeArgument instanceof WildcardType) {\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n>>> [ INFILL ] <<<\n                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n            // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n        }",
    "project": "Mockito",
    "test_error_message": "java.lang.StackOverflowError",
    "test_framework": "defects4j",
    "test_line": "        Type type = this.contextualActualTypeParameters.get(typeParameter);",
    "test_name": "typeVariable_of_self_type",
    "test_suite": "org.mockito.internal.util.reflection.GenericMetadataSupportTest",
    "time_buggy": "2014-12-29 22:53:56 +0100",
    "time_fixed": "2014-12-29 22:59:47 +0100",
    "bug_description": "Bug ID: 8\nProject: Mockito\nBug Type: Stack Level Space Handling - Stack Overflow (SL SH SF)\nTest Error Message: java.lang.StackOverflowError\n\nDescription:\n\nThe error is of type \"StackOverflowError\", a common one raised when a program recurses too deeply and exhaustively consumes the stack space it is allotted.\n\nThe buggy part is as follows:\n\n    } else {\n        contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n    }\n\nThe bug is within the iterative part of the code where it checks if \"actualTypeArgument\" is an instance of \"WildcardType\". In a case where it is not an instance of \"WildcardType\", the code puts these \"actualTypeArgument\" and \"typeParameter\" into the \"contextualActualTypeParameters\" map.\n\nWithout any space handling mechanism, the unregulated and infinite loop of \"actualTypeArgument\" being never an instance of \"WildcardType\", constantly filling into the \"contextualActualTypeParameters\" map and thus continuously consuming the stack level space, leads to the \"StackOverflowError\". \n\nThe resolution for such a recursive loop causing a Stack Overflow is demonstrated in the fixed code part as an else-if condition, which checks if the \"typeParameter\" is not equal to the \"actualTypeArgument\", before putting them into the \"contextualActualTypeParameters\" map. This avoids the scenario where same values of \"actualTypeArgument\" and \"typeParameter\" are continuously put into the map, leading to an infinite loop.\n\n    } else if (typeParameter != actualTypeArgument) {\n        contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n    }\n\nThis bug report can be used to generate artificial java bugs by:\n\n1. Identifying a recursion part of code susceptible to lead to an infinite loop.\n2. Demonstrating a situation where the condition to exit the recursion is not properly implemented or non-existent.\n3. Showcase the potential consequences, such as a java.lang.StackOverflowError, of such implementations.\n4. Present a resolution where additional logic is introduced to properly handle such scenarios and safeguard against similar errors.\n5. Emphasize the importance of proper stack level space handling, especially in the presence of loops or recursion."
}