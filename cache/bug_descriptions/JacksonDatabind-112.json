{
    "bug_id": 112,
    "bug_type": "SF",
    "buggy_lines": "            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();",
    "code": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        // May need to resolve types for delegate-based creators:\n        JsonDeserializer<Object> delegate = null;\n        if (_valueInstantiator != null) {\n            // [databind#2324]: check both array-delegating and delegating\n            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n            if (delegateCreator != null) {\n                JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                delegate = findDeserializer(ctxt, delegateType, property);\n            }\n        }\n        JsonDeserializer<?> valueDeser = _valueDeserializer;\n        final JavaType valueType = _containerType.getContentType();\n        if (valueDeser == null) {\n            // [databind#125]: May have a content converter\n            valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n            if (valueDeser == null) {\n            // And we may also need to get deserializer for String\n                valueDeser = ctxt.findContextualValueDeserializer(valueType, property);\n            }\n        } else { // if directly assigned, probably not yet contextual, so:\n            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, valueType);\n        }\n        // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n        //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n        NullValueProvider nuller = findContentNullProvider(ctxt, property, valueDeser);\n        if (isDefaultDeserializer(valueDeser)) {\n            valueDeser = null;\n        }\n        return withResolved(delegate, valueDeser, nuller, unwrapSingle);\n    }",
    "fixed_code": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        // May need to resolve types for delegate-based creators:\n        JsonDeserializer<Object> delegate = null;\n        if (_valueInstantiator != null) {\n            // [databind#2324]: check both array-delegating and delegating\n            AnnotatedWithParams delegateCreator = _valueInstantiator.getArrayDelegateCreator();\n            if (delegateCreator != null) {\n                JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n                delegate = findDeserializer(ctxt, delegateType, property);\n            } else if ((delegateCreator = _valueInstantiator.getDelegateCreator()) != null) {\n                JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                delegate = findDeserializer(ctxt, delegateType, property);\n            }\n        }\n        JsonDeserializer<?> valueDeser = _valueDeserializer;\n        final JavaType valueType = _containerType.getContentType();\n        if (valueDeser == null) {\n            // [databind#125]: May have a content converter\n            valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n            if (valueDeser == null) {\n            // And we may also need to get deserializer for String\n                valueDeser = ctxt.findContextualValueDeserializer(valueType, property);\n            }\n        } else { // if directly assigned, probably not yet contextual, so:\n            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, valueType);\n        }\n        // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n        //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n        NullValueProvider nuller = findContentNullProvider(ctxt, property, valueDeser);\n        if (isDefaultDeserializer(valueDeser)) {\n            valueDeser = null;\n        }\n        return withResolved(delegate, valueDeser, nuller, unwrapSingle);\n    }",
    "fixed_lines": "            AnnotatedWithParams delegateCreator = _valueInstantiator.getArrayDelegateCreator();\n                JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n                delegate = findDeserializer(ctxt, delegateType, property);\n            } else if ((delegateCreator = _valueInstantiator.getDelegateCreator()) != null) {",
    "masked_code": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        // May need to resolve types for delegate-based creators:\n        JsonDeserializer<Object> delegate = null;\n        if (_valueInstantiator != null) {\n            // [databind#2324]: check both array-delegating and delegating\n            if (delegateCreator != null) {\n>>> [ INFILL ] <<<\n                JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                delegate = findDeserializer(ctxt, delegateType, property);\n            }\n        }\n        JsonDeserializer<?> valueDeser = _valueDeserializer;\n        final JavaType valueType = _containerType.getContentType();\n        if (valueDeser == null) {\n            // [databind#125]: May have a content converter\n            valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n            if (valueDeser == null) {\n            // And we may also need to get deserializer for String\n                valueDeser = ctxt.findContextualValueDeserializer(valueType, property);\n            }\n        } else { // if directly assigned, probably not yet contextual, so:\n            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, valueType);\n        }\n        // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n        //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n        NullValueProvider nuller = findContentNullProvider(ctxt, property, valueDeser);\n        if (isDefaultDeserializer(valueDeser)) {\n            valueDeser = null;\n        }\n        return withResolved(delegate, valueDeser, nuller, unwrapSingle);\n    }",
    "project": "JacksonDatabind",
    "test_error_message": "junit.framework.AssertionFailedError: expected not same",
    "test_framework": "defects4j",
    "test_line": "        assertNotSame(w, newW);",
    "test_name": "testViewSettings",
    "test_suite": "com.fasterxml.jackson.databind.ObjectWriterTest",
    "time_buggy": "2019-05-07 20:48:24 -0700",
    "time_fixed": "2019-05-10 22:48:16 -0700",
    "bug_description": "Bug ID: 112\nProject Name: JacksonDatabind\nBug Type: SF (Statement Fault)\n\nBug Description:\n\nThe bug exists within the \u2018createContextual\u2019 function in the JacksonDatabind project. The buggy line of code identified is:\n`AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();`\n\nThere seems to be an issue where we expect a certain instance result that isn't being returned, as indicated by the junit.framework.AssertionFailedError. \n\nStep by Step Description of Bug:\n\n1. The createContextual function is invoked with its parameters as DeserializationContext and BeanProperty, and is set to throw a JsonMappingException.\n2. Within this function, a null JsonDeserializer named delegate is initialized.\n3. The code checks if _valueInstantiator is not null.\n4. When the condition is true, it enters the block to execute the buggy line where it tries to get the delegateCreator using the function 'getDelegateCreator()'. The resulted delegateCreator is stored in an object of AnnotatedWithParams named delegateCreator.\n5. It seems like the expected and actual results of getDelegateCreator() are not the same, causing an assertion error.\n\nFixed Code Description:\n\n1. The fixed code includes the same checks initially in the function as per buggy code.\n2. But here, first, it attempts to get the ArrayDelegateCreator from _valueInstantiator and assigns it to delegateCreator.\n3. If the delegateCreator is not null, then it looks for the array delegate type and assigns the deserializer for it as the delegate.\n4. If the delegateCreator is still null, it attempts to get the regular delegate creator from _valueInstantiator (which was the initial buggy line in the original code and still presents as an additional check in the fixed code).\n5. Here it also checks for the delegate type and assigns the deserializer for it as the delegate only when delegateCreator is not null.\n\nThis approach of taking array delegates into account first seems to have fixed the bug caused by the original code. Further execution of the code is the same after these initial checks in both buggy and fixed versions of the code."
}