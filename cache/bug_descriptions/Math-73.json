{
    "bug_id": 73,
    "bug_type": "SH SF",
    "buggy_lines": "",
    "code": "    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifySequence(min, initial, max);\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(f, min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(f, min, yMin, max, yMax, initial, yInitial);\n\n    }",
    "fixed_code": "    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifySequence(min, initial, max);\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(f, min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n        if (yMin * yMax > 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n        }\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(f, min, yMin, max, yMax, initial, yInitial);\n\n    }",
    "fixed_lines": "        if (yMin * yMax > 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n        }",
    "masked_code": "    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifySequence(min, initial, max);\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(f, min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n>>> [ INFILL ] <<<\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(f, min, yMin, max, yMax, initial, yInitial);\n\n    }",
    "project": "Math",
    "test_error_message": "junit.framework.AssertionFailedError: Expecting IllegalArgumentException - non-bracketing",
    "test_framework": "defects4j",
    "test_line": "",
    "test_name": "testBadEndpoints",
    "test_suite": "org.apache.commons.math.analysis.solvers.BrentSolverTest",
    "time_buggy": "2010-02-21 21:46:12 +0000",
    "time_fixed": "2010-02-23 21:01:38 +0000",
    "bug_description": "Bug ID: 73\n\nBug Description:\nThis bug propagates around handling of non-bracketing (when the root of the function is not within the given interval [min, max]) in the univariate real function solver. The test error message hints at an expectation of an IllegalArgumentException being thrown in situations of non-bracketing, which isn't happening in the buggy code implementation.\n\nIn the buggy version of the code, there is no measure taken to ensure that the root of the function falls within the interval [min, max]. This misses instances when min and max both are on the same side of root which is undesired. \n\nThis bug reveals itself during the full execution of the Brent's algorithm where the root might lie outside the given [min, max] interval. The algorithm doesn't handle these cases, leading to either incorrect or unexpected results.\n\nSteps to Reproduce:\n1. Call the solve method using an object of the class UnivariateRealFunction, provide values for f, min, max and initial such that the root doesn't lie within the interval [min, max].\n2. The error handling is expected to throw an IllegalArgumentException in such cases, but in the buggy code, it doesn't.\n\nFixed Code Explanation:\nIn the fixed version of the code, an additional check has been added. This check evaluates the product of yMin (function value at min) and yMax (function value at max). This insights on the positioning of min and max w.r.t root. When both are on the same side the product is greater than 0. In such cases, an IllegalArgumentException is thrown suggesting that the interval doesn't straddle (bracket) a root and therefore, the method cannot continue to find the root.\n\nThis handles the buggy scenario correctly as it introduces the test for handling non-bracketing issues. Hence, developers trying to generate equivalent artificial Java bugs can introduce scenarios where certain important conditions aren't checked in the program that could lead to ambiguities or functionality failure, much like missing to verify whether the given interval covers the root in a function solver algorithm."
}