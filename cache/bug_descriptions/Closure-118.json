{
    "bug_id": 118,
    "bug_type": "SH SF",
    "buggy_lines": "",
    "code": "    private void handleObjectLit(NodeTraversal t, Node n) {\n      for (Node child = n.getFirstChild();\n          child != null;\n          child = child.getNext()) {\n        // Maybe STRING, GET, SET\n\n        // We should never see a mix of numbers and strings.\n        String name = child.getString();\n        T type = typeSystem.getType(getScope(), n, name);\n\n        Property prop = getProperty(name);\n        if (!prop.scheduleRenaming(child,\n                                   processProperty(t, prop, type, null))) {\n          // TODO(user): It doesn't look like the user can do much in this\n          // case right now.\n          if (propertiesToErrorFor.containsKey(name)) {\n            compiler.report(JSError.make(\n                t.getSourceName(), child, propertiesToErrorFor.get(name),\n                Warnings.INVALIDATION, name,\n                (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n          }\n        }\n      }\n    }",
    "fixed_code": "    private void handleObjectLit(NodeTraversal t, Node n) {\n      for (Node child = n.getFirstChild();\n          child != null;\n          child = child.getNext()) {\n        // Maybe STRING, GET, SET\n        if (child.isQuotedString()) {\n          continue;\n        }\n\n        // We should never see a mix of numbers and strings.\n        String name = child.getString();\n        T type = typeSystem.getType(getScope(), n, name);\n\n        Property prop = getProperty(name);\n        if (!prop.scheduleRenaming(child,\n                                   processProperty(t, prop, type, null))) {\n          // TODO(user): It doesn't look like the user can do much in this\n          // case right now.\n          if (propertiesToErrorFor.containsKey(name)) {\n            compiler.report(JSError.make(\n                t.getSourceName(), child, propertiesToErrorFor.get(name),\n                Warnings.INVALIDATION, name,\n                (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n          }\n        }\n      }\n    }",
    "fixed_lines": "        if (child.isQuotedString()) {\n          continue;\n        }",
    "masked_code": "    private void handleObjectLit(NodeTraversal t, Node n) {\n      for (Node child = n.getFirstChild();\n          child != null;\n          child = child.getNext()) {\n        // Maybe STRING, GET, SET\n>>> [ INFILL ] <<<\n\n        // We should never see a mix of numbers and strings.\n        String name = child.getString();\n        T type = typeSystem.getType(getScope(), n, name);\n\n        Property prop = getProperty(name);\n        if (!prop.scheduleRenaming(child,\n                                   processProperty(t, prop, type, null))) {\n          // TODO(user): It doesn't look like the user can do much in this\n          // case right now.\n          if (propertiesToErrorFor.containsKey(name)) {\n            compiler.report(JSError.make(\n                t.getSourceName(), child, propertiesToErrorFor.get(name),\n                Warnings.INVALIDATION, name,\n                (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n          }\n        }\n      }\n    }",
    "project": "Closure",
    "test_error_message": "junit.framework.ComparisonFailure: expected:<{[]}> but was:<{[a=[[Foo.prototype]]]}>",
    "test_framework": "defects4j",
    "test_line": "    assertEquals(",
    "test_name": "testOneType4",
    "test_suite": "com.google.javascript.jscomp.DisambiguatePropertiesTest",
    "time_buggy": "2013-08-26 12:47:25 -0400",
    "time_fixed": "2013-08-26 10:00:28 -0700",
    "bug_description": "Bug ID: 118\nProject: Closure\nBug Type: SH SF\n\nBug Description:\nThe bug exists within the function `handleObjectLit()`, which is a private method of NodeTraversal. \n\nThe issue lies with the object literal (object 'n') that is passed to the function. When traversing through the object properties using a loop, each property is attempted to be processed with its name and associated type.\n\nError:\nThe error arises when trying to process properties which are quoted strings because their type is returned as null. This results in an error: `junit.framework.ComparisonFailure: expected:<{[]}> but was:<{[a=[[Foo.prototype]]]}>` as the object literal comparison fails. This kind of bug type is SH SF which may stand for String Handling and String Format issues.\n\nHere, the code attempts to process this property by renaming it. However, due to the null type, it fails and throws a warning sign for invalidation. The invalidation warning contains information about the property name, the type (which is null), the name of the source object, and an empty string.\n\nFix:\nThe positive resolution for the bug is to add an additional condition to ignore the properties which are quoted strings. This means before the property processing (getting the property name and type), the function first checks if the property is a quoted string. If true, it skips the remainder of the current iteration and moves to the next property. This bypasses the actions that would normally cause the warning and the error.\n\nThis small but crucial change prevents the error from being thrown while still processing all other properties of the object literal correctly.\n\nChanges in the code:\n\nFrom:\n```\n// Maybe STRING, GET, SET\n\n// We should never see a mix of numbers and strings.\nString name = child.getString();\nT type = typeSystem.getType(getScope(), n, name);\n...\n```\n\nTo:\n```\n// Maybe STRING, GET, SET\nif (child.isQuotedString()) {\n  continue;\n}\n\n// We should never see a mix of numbers and strings.\nString name = child.getString();\nT type = typeSystem.getType(getScope(), n, name);\n...\n```  \n\nThe change checks if the child node is a quoted string, and if so, it skips that iteration of the loop. This prevents trying to resolve the type of quoted strings, thereby preventing the NullPointerException (as type would be 'null'). It also prevents the invalidation issue and thus the error."
}