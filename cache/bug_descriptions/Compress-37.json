{
    "bug_id": 37,
    "bug_type": "SH SF",
    "buggy_lines": "                if (ch == ' '){",
    "code": "    private void paxHeaders() throws IOException{\n        final Map<String, String> headers = parsePaxHeaders(this);\n        getNextEntry(); // Get the actual file entry\n        applyPaxHeadersToCurrentEntry(headers);\n    }\n\n    // NOTE, using a Map here makes it impossible to ever support GNU\n    // sparse files using the PAX Format 0.0, see\n    // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n        // Format is \"length keyword=value\\n\";\n        while(true){ // get length\n            int ch;\n            int len = 0;\n            int read = 0;\n            while((ch = i.read()) != -1) {\n                read++;\n                if (ch == ' '){\n                    // Get keyword\n                    final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                    while((ch = i.read()) != -1) {\n                        read++;\n                        if (ch == '='){ // end of keyword\n                            final String keyword = coll.toString(CharsetNames.UTF_8);\n                            // Get rest of entry\n                            final int restLen = len - read;\n                            if (restLen == 1) { // only NL\n                                headers.remove(keyword);\n                            } else {\n                                final byte[] rest = new byte[restLen];\n                                final int got = IOUtils.readFully(i, rest);\n                                if (got != restLen) {\n                                    throw new IOException(\"Failed to read \"\n                                                          + \"Paxheader. Expected \"\n                                                          + restLen\n                                                          + \" bytes, read \"\n                                                          + got);\n                                }\n                                // Drop trailing NL\n                                final String value = new String(rest, 0,\n                                                          restLen - 1, CharsetNames.UTF_8);\n                                headers.put(keyword, value);\n                            }\n                            break;\n                        }\n                        coll.write((byte) ch);\n                    }\n                    break; // Processed single header\n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1){ // EOF\n                break;\n            }\n        }\n        return headers;\n    }",
    "fixed_code": "    private void paxHeaders() throws IOException{\n        final Map<String, String> headers = parsePaxHeaders(this);\n        getNextEntry(); // Get the actual file entry\n        applyPaxHeadersToCurrentEntry(headers);\n    }\n\n    // NOTE, using a Map here makes it impossible to ever support GNU\n    // sparse files using the PAX Format 0.0, see\n    // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n        // Format is \"length keyword=value\\n\";\n        while(true){ // get length\n            int ch;\n            int len = 0;\n            int read = 0;\n            while((ch = i.read()) != -1) {\n                read++;\n                if (ch == '\\n') { // blank line in header\n                    break;\n                } else if (ch == ' '){ // End of length string\n                    // Get keyword\n                    final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                    while((ch = i.read()) != -1) {\n                        read++;\n                        if (ch == '='){ // end of keyword\n                            final String keyword = coll.toString(CharsetNames.UTF_8);\n                            // Get rest of entry\n                            final int restLen = len - read;\n                            if (restLen == 1) { // only NL\n                                headers.remove(keyword);\n                            } else {\n                                final byte[] rest = new byte[restLen];\n                                final int got = IOUtils.readFully(i, rest);\n                                if (got != restLen) {\n                                    throw new IOException(\"Failed to read \"\n                                                          + \"Paxheader. Expected \"\n                                                          + restLen\n                                                          + \" bytes, read \"\n                                                          + got);\n                                }\n                                // Drop trailing NL\n                                final String value = new String(rest, 0,\n                                                          restLen - 1, CharsetNames.UTF_8);\n                                headers.put(keyword, value);\n                            }\n                            break;\n                        }\n                        coll.write((byte) ch);\n                    }\n                    break; // Processed single header\n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1){ // EOF\n                break;\n            }\n        }\n        return headers;\n    }",
    "fixed_lines": "                if (ch == '\\n') { // blank line in header\n                    break;\n                } else if (ch == ' '){ // End of length string",
    "masked_code": "    private void paxHeaders() throws IOException{\n        final Map<String, String> headers = parsePaxHeaders(this);\n        getNextEntry(); // Get the actual file entry\n        applyPaxHeadersToCurrentEntry(headers);\n    }\n\n    // NOTE, using a Map here makes it impossible to ever support GNU\n    // sparse files using the PAX Format 0.0, see\n    // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n        // Format is \"length keyword=value\\n\";\n        while(true){ // get length\n            int ch;\n            int len = 0;\n            int read = 0;\n            while((ch = i.read()) != -1) {\n                read++;\n>>> [ INFILL ] <<<\n                    // Get keyword\n                    final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                    while((ch = i.read()) != -1) {\n                        read++;\n                        if (ch == '='){ // end of keyword\n                            final String keyword = coll.toString(CharsetNames.UTF_8);\n                            // Get rest of entry\n                            final int restLen = len - read;\n                            if (restLen == 1) { // only NL\n                                headers.remove(keyword);\n                            } else {\n                                final byte[] rest = new byte[restLen];\n                                final int got = IOUtils.readFully(i, rest);\n                                if (got != restLen) {\n                                    throw new IOException(\"Failed to read \"\n                                                          + \"Paxheader. Expected \"\n                                                          + restLen\n                                                          + \" bytes, read \"\n                                                          + got);\n                                }\n                                // Drop trailing NL\n                                final String value = new String(rest, 0,\n                                                          restLen - 1, CharsetNames.UTF_8);\n                                headers.put(keyword, value);\n                            }\n                            break;\n                        }\n                        coll.write((byte) ch);\n                    }\n                    break; // Processed single header\n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1){ // EOF\n                break;\n            }\n        }\n        return headers;\n    }",
    "project": "Compress",
    "test_error_message": "java.lang.NegativeArraySizeException",
    "test_framework": "defects4j",
    "test_line": "            final TarArchiveEntry entry = is.getNextTarEntry();",
    "test_name": "survivesBlankLinesInPaxHeader",
    "test_suite": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest",
    "time_buggy": "2016-05-16 15:44:32 +0100",
    "time_fixed": "2016-05-20 18:18:05 +0200",
    "bug_description": "Bug Description:\n\nID: 37\nProject Name: Compress\nBug Type: Static and Syntax \n\nProcedure:\n\n1. The bug in question is located within the \u201cCompress\u201d project and pertains to the scenario where the system throws a 'java.lang.NegativeArraySizeException' error message during runtime. The specific error category is Static and Syntax (SH SF).\n\n2. The error is found in the method 'parsePaxHeaders(InputStream i)' under the condition 'if (ch == ' ')'. This condition triggers the creation of a ByteArrayOutputStream called 'coll' and a subsequent loop which reads characters from an InputStream 'i'.\n\n3. Within this loop, if the character 'ch' equals '=', the function reads the rest of the entry till the designated length 'restLen', stores it within a byte array 'rest', and then reads the data from the InputStream 'i' to the byte array 'rest' till a specific number of bytes 'got' are read.\n\n4. Following this, an IOException is thrown if the number of bytes read 'got' is not equal to the specified length 'restLen'. \n\n5. After this, a string 'value' is created taking into consideration the trailing NL and subsequently puts it into a previously created HashMap called 'headers'.\n\n6. The faulty line in the code gives rise to a NegativeArraySizeException because the size of the byte array 'rest' is negative. This is due to the value of 'restLen' being less than the read size, which is set to 1.\n\nResolution: \n\n1. The fixed code adds an additional condition, checking if the character 'ch' equals '\\n', in which case the loop breaks. This condition is inserted with the assumption that if a newline character is encountered, it is indicative of a blank line in the header, implying the end of header information. \n\n2. Following this, if the character 'ch' equals ' ', the loop behaviors follow the same logic as in the buggy code.\n\n3. This change prevents the program from attempting to read the InputStream 'i' beyond the designated length, hence avoiding the java.lang.NegativeArraySizeException originally thrown during the execution of the buggy code."
}