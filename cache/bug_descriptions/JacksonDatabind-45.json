{
    "bug_id": 45,
    "bug_type": "SH SF",
    "buggy_lines": "                if (format.getShape() == JsonFormat.Shape.STRING) {",
    "code": "    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property != null) {\n            JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n            if (format != null) {\n\n            \t// Simple case first: serialize as numeric timestamp?\n                JsonFormat.Shape shape = format.getShape();\n                if (shape.isNumeric()) {\n                    return withFormat(Boolean.TRUE, null);\n                }\n\n                if (format.getShape() == JsonFormat.Shape.STRING) {\n                    TimeZone tz = format.getTimeZone();\n                    final String pattern = format.hasPattern()\n                                    ? format.getPattern()\n                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                    final Locale loc = format.hasLocale()\n                                    ? format.getLocale()\n                                    : serializers.getLocale();\n                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                    if (tz == null) {\n                        tz = serializers.getTimeZone();\n                    }\n                    df.setTimeZone(tz);\n                    return withFormat(Boolean.FALSE, df);\n                }\n            }\n        }\n        return this;\n    }",
    "fixed_code": "    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property != null) {\n            JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n            if (format != null) {\n\n            \t// Simple case first: serialize as numeric timestamp?\n                JsonFormat.Shape shape = format.getShape();\n                if (shape.isNumeric()) {\n                    return withFormat(Boolean.TRUE, null);\n                }\n\n                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n                                || format.hasLocale() || format.hasTimeZone()) {\n                    TimeZone tz = format.getTimeZone();\n                    final String pattern = format.hasPattern()\n                                    ? format.getPattern()\n                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                    final Locale loc = format.hasLocale()\n                                    ? format.getLocale()\n                                    : serializers.getLocale();\n                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                    if (tz == null) {\n                        tz = serializers.getTimeZone();\n                    }\n                    df.setTimeZone(tz);\n                    return withFormat(Boolean.FALSE, df);\n                }\n            }\n        }\n        return this;\n    }",
    "fixed_lines": "                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n                                || format.hasLocale() || format.hasTimeZone()) {",
    "masked_code": "    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property != null) {\n            JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n            if (format != null) {\n\n            \t// Simple case first: serialize as numeric timestamp?\n                JsonFormat.Shape shape = format.getShape();\n                if (shape.isNumeric()) {\n                    return withFormat(Boolean.TRUE, null);\n                }\n\n>>> [ INFILL ] <<<\n                    TimeZone tz = format.getTimeZone();\n                    final String pattern = format.hasPattern()\n                                    ? format.getPattern()\n                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                    final Locale loc = format.hasLocale()\n                                    ? format.getLocale()\n                                    : serializers.getLocale();\n                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                    if (tz == null) {\n                        tz = serializers.getTimeZone();\n                    }\n                    df.setTimeZone(tz);\n                    return withFormat(Boolean.FALSE, df);\n                }\n            }\n        }\n        return this;\n    }",
    "project": "JacksonDatabind",
    "test_error_message": "junit.framework.ComparisonFailure: expected:<{\"date\":[\"1970-01-01\"]}> but was:<{\"date\":[0]}>",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(aposToQuotes(\"{'date':'1970-01-01'}\"), json);",
    "test_name": "testDateDefaultShape",
    "test_suite": "com.fasterxml.jackson.databind.ser.DateSerializationTest",
    "time_buggy": "2016-03-09 15:30:34 -0800",
    "time_fixed": "2016-03-12 14:24:47 -0800",
    "bug_description": "Bug Description:\n\nBug ID: 45\nProject: JacksonDatabind\nBug Type: SH SF\nTest Error Message: junit.framework.ComparisonFailure: expected:<{\"date\":[\"1970-01-01\"]}> but was:<{\"date\":[0]}>\nBuggy Line: \"if (format.getShape() == JsonFormat.Shape.STRING) {\"\n\nProblem Description: In the JacksonDatabind project, a bug of type SH SF (Severity High, Side Effect) was found. There appeared to be an issue with the serialization of date objects within the code block to convert a specific 'Format Shape' to a serialized string. It manifested in the form of a JUnit framework comparison failure, particularly while comparing the serialization output of a date object.\n\nFaulty Code Behavior: The issue stemmed from the condition where the format shape of the date object had to be equal to \"String\". The function was only taking 'String' Format Shape into account and subsequently ignoring other format conditions like 'Pattern', 'Locale', and 'Timezone'. Therefore, rather than correctly serializing the date object as \"1970-01-01\", it was incorrectly being serialized as \"0\".\n\nSolution: The condition used to determine the format shape was modified. The updated code not only checks if the format shape form is considered a String but also whether the format elements such as 'Pattern', 'Locale', or 'TimeZone' are present. These additional checks make sure that the serializer gives the correct output for date objects irrespective of the unique formatting options associated with each date instance. Therefore, instead of returning \"0\" for the date \"1970-01-01\", it now correctly returns the date in its serialized form.\n\nThe buggy line \"if (format.getShape() == JsonFormat.Shape.STRING) {\" has been replaced with a more comprehensive condition: \"if ((shape == JsonFormat.Shape.STRING) || format.hasPattern() || format.hasLocale() || format.hasTimeZone()) {\". This change remedies the bug by correctly accounting for the various format attributes like 'Pattern', 'Locale', and 'TimeZone'.\n\nSuggestions for Artificial Bug Generation:\n\n1. Start with the fixed code and alter the conditional statement which checks the 'format shape' and other format parameters like 'Pattern', 'Locale', and 'TimeZone'. Simulate different format shapes and observe results.\n2. Modify the SimpleDateFormat and see how it affects date serialization.\n3. Try different types of objects for serialization, including other types than date.\n4. Play around with Locale or TimeZone settings in the code and analyze their impact on the date serialization output."
}