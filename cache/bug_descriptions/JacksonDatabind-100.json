{
    "bug_id": 100,
    "bug_type": "SF",
    "buggy_lines": "            byte[] data = n.binaryValue();\n            if (data != null) {\n                return data;\n            }\n            if (n.isPojo()) {\n                Object ob = ((POJONode) n).getPojo();\n                if (ob instanceof byte[]) {\n                    return (byte[]) ob;\n                }",
    "code": "    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n    {\n        // Multiple possibilities...\n        JsonNode n = currentNode();\n        if (n != null) {\n            // [databind#2096]: although `binaryValue()` works for real binary node\n            // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n            byte[] data = n.binaryValue();\n            if (data != null) {\n                return data;\n            }\n            if (n.isPojo()) {\n                Object ob = ((POJONode) n).getPojo();\n                if (ob instanceof byte[]) {\n                    return (byte[]) ob;\n                }\n            }\n        }\n        // otherwise return null to mark we have no binary content\n        return null;\n    }",
    "fixed_code": "    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n    {\n        // Multiple possibilities...\n        JsonNode n = currentNode();\n        if (n != null) {\n            // [databind#2096]: although `binaryValue()` works for real binary node\n            // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n            if (n instanceof TextNode) {\n                return ((TextNode) n).getBinaryValue(b64variant);\n            }\n            return n.binaryValue();\n        }\n        // otherwise return null to mark we have no binary content\n        return null;\n    }",
    "fixed_lines": "            if (n instanceof TextNode) {\n                return ((TextNode) n).getBinaryValue(b64variant);\n            return n.binaryValue();",
    "masked_code": "    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n    {\n        // Multiple possibilities...\n        JsonNode n = currentNode();\n        if (n != null) {\n            // [databind#2096]: although `binaryValue()` works for real binary node\n            // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n            }\n>>> [ INFILL ] <<<\n        }\n        // otherwise return null to mark we have no binary content\n        return null;\n    }",
    "project": "JacksonDatabind",
    "test_error_message": "junit.framework.AssertionFailedError: expected not same",
    "test_framework": "defects4j",
    "test_line": "        assertNotSame(w, newW);",
    "test_name": "testViewSettings",
    "test_suite": "com.fasterxml.jackson.databind.ObjectWriterTest",
    "time_buggy": "2018-08-15 07:15:33 -0700",
    "time_fixed": "2018-08-15 16:56:18 -0700",
    "bug_description": "Bug Description:\n\n1. Bug ID: \nThe bug has been assigned an ID of 100 for tracking and reference purposes.\n\n2. Project: \nThe identified bug is found in the 'JacksonDatabind' project, which is a popular JSON-processing library for Java.\n\n3. Bug Type:\nThe bug type is stated as 'SF', commonly indicating a Software Fault or Failure.\n\n4. Overview: \nThe bug resides in the method 'getBinaryValue(Base64Variant b64variant)' within the project. This bug leads to a test error that gives a 'junit.framework.AssertionFailedError: expected not same' message. The error occurs because the code doesn't handle TextNode type nodes and return their binary value.\n\n5. Buggy Code: \nIn the original code, after checking whether 'n', which is of 'JsonNode' type, is not null, it attempts to get the binary value of 'n' and return it if it's not null. Then, it checks if 'n' is a POJO and if it is and its datatype is byte[], it would return the data too. This logic has a loophole as it doesn't account for a scenario where 'n' could be a 'TextNode'.\n\n6. Effect of Bug: \nThe effect of this software bug is that it fails in the event 'n' is an instance of 'TextNode'. The function getBinaryValue(Base64Variant b64variant) would return null although 'n' contains a legitimate binary value but of TextNode type which the original code never processes.\n\n7. Code Fix: \nThe fix updates the getBinaryValue method with a condition to check if 'n' is an instance of 'TextNode'. If so, it now correctly returns the binary value of 'n' using the getBinaryValue method specific to TextNode type nodes.\n\nThis bug description should serve as a step-by-step guide to understanding the bug, its implications on the application, and how it has been fixed. Any new artificial bugs developed for testing or other purposes should follow similar descriptions to maintain consistency and ease of understanding for all developers involved."
}