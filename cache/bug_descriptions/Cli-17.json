{
    "bug_id": 17,
    "bug_type": "SL SH SF",
    "buggy_lines": "",
    "code": "    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }",
    "fixed_code": "    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n                break;\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }",
    "fixed_lines": "                break;",
    "masked_code": "    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n>>> [ INFILL ] <<<\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }",
    "project": "Cli",
    "test_error_message": "junit.framework.AssertionFailedError: Confirm 1 extra arg: 2",
    "test_framework": "defects4j",
    "test_line": "        assertTrue( \"Confirm  1 extra arg: \" + cl.getArgList().size(), cl.getArgList().size() == 1);",
    "test_name": "testStopBursting",
    "test_suite": "org.apache.commons.cli.PosixParserTest",
    "time_buggy": "2008-07-25 16:23:38 +0000",
    "time_fixed": "2008-07-27 23:38:21 +0000",
    "bug_description": "Bug Title: Invalid Handling of Extra Argument in Cli Project\n\nBug ID: 17\n\nProject: Cli\n\nBug Type: Semantic (SL), Syntactic (SH), Semantic Formatting (SF)\n\nDetected by: JUnit Test\n\nError Message: junit.framework.AssertionFailedError: Confirm 1 extra arg: 2\n\nDescription:\n\nThe issue was found in the method \"burstToken\" of the Cli project. This method is designed to break apart the given token and add segments based on certain conditions. However, in the code block where it checks if the current option has an argument and if the length of the token is not equal to (i+1), it adds the substring of the token starting from index (i+1) to tokens without validation. Later, this condition was not being properly handled, causing an AssertionFailedError during testing implying that an extra argument was found.\n\nSteps to Reproduce:\n\nThe issue originates from the block of code:\n\n```\nif (options.hasOption(ch))\n{\n    tokens.add(\"-\" + ch);\n    currentOption = options.getOption(ch);\n\n    if (currentOption.hasArg() && (token.length() != (i + 1)))\n    {\n        tokens.add(token.substring(i + 1));\n\n        break;\n    }\n}\n```\n\nIt can be reproduced by executing a 'burstToken' method with a token that will meet the conditions within the \"if\" loop.\n\nProblematic Behavior:\n\nGiven the right conditions, the program reads one argument more than it should.\n\nExpected Behavior:\n\nWhen the conditions for entering the 'if' loop are met, the input should be validated before adding as a token.\n\nSolution:\n\nThe developer fixed this bug by introducing a break statement inside the conditional blocks which stops the execution of the loop when the stopAtNonOption is true or when the token doesn't have an option. This prevents the code from adding token directly to the tokens which was causing the assertion error.\n\nFixed Code:\n\n```\nif (options.hasOption(ch))\n{\n    tokens.add(\"-\" + ch);\n    currentOption = options.getOption(ch);\n\n    if (currentOption.hasArg() && (token.length() != (i + 1)))\n    {\n        tokens.add(token.substring(i + 1));\n\n        break;\n    }\n}\nelse if (stopAtNonOption)\n{\n    process(token.substring(i));\n    break;\n}\nelse\n{\n    tokens.add(token);\n    break;\n}\n```"
}