{
    "bug_id": 1,
    "bug_type": "SL SH SF",
    "buggy_lines": "        if (current == '\\n') {",
    "code": "    public int read() throws IOException {\n        int current = super.read();\n        if (current == '\\n') {\n            lineCounter++;\n        }\n        lastChar = current;\n        return lastChar;\n    }",
    "fixed_code": "    public int read() throws IOException {\n        int current = super.read();\n        if (current == '\\r' || (current == '\\n' && lastChar != '\\r')) {\n            lineCounter++;\n        }\n        lastChar = current;\n        return lastChar;\n    }",
    "fixed_lines": "        if (current == '\\r' || (current == '\\n' && lastChar != '\\r')) {",
    "masked_code": "    public int read() throws IOException {\n        int current = super.read();\n>>> [ INFILL ] <<<\n            lineCounter++;\n        }\n        lastChar = current;\n        return lastChar;\n    }",
    "project": "Csv",
    "test_error_message": "junit.framework.AssertionFailedError: expected:<1> but was:<0>",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(1, parser.getLineNumber());",
    "test_name": "testGetLineNumberWithCR",
    "test_suite": "org.apache.commons.csv.CSVParserTest",
    "time_buggy": "2012-03-27 00:42:22 +0000",
    "time_fixed": "2012-03-27 00:49:17 +0000",
    "bug_description": "Bug ID: 1\nProject: Csv\nBug Type: SL (Statement-related) SH (Syntax and Human Error) SF (Software Flow)\n\nTest Error Message: junit.framework.AssertionFailedError: expected:<1> but was:<0>\n\nBug Description:\nThe issue is found within the Csv codebase where the read() method does not correctly increment the lineCounter as expected. The read() method in the Csv codebase is supposed to read characters and identify line terminations appropriately, recognized by the newline ('\\n') characters. For every line read, it should increase the lineCounter.\n\nThe bug involves the condition that checks whether the read character is a newline '\\n'. The bug is classified as a statement-related and software flow bug because it concerns a conditional statement that controls the flow of the execution. It might also be due to a human error, as an important scenario related to carriage return character ('\\r') has been overlooked. \n\nStep-by-step Replication of the Bug:\n\n1. The read() method is called to read a line from a CSV.\n2. A character is read using the super.read() and assigned to the 'current' variable.\n3. The if condition checks if the 'current' character equals the newline character '\\n'.\n4. If the character is a newline '\\n', the lineCounter variable increments.\n5. The 'lastChar' variable is set to the 'current' character.\n\nThis logic can fail in the cases where the lines are terminated with a carriage return '\\r' or a combination of carriage return and newline '\\r\\n'. For '\\r\\n' case, lineCounter would be incremented twice - one for '\\r' and another for '\\n' - while it should be incremented only once as both represent the end of the same line.\n\nBug Fix:\nThe fix introduced a scenario to deal with the carriage return character '\\r' and the combination '\\r\\n'. Now, the lineCounter increments when the 'current' either equals the carriage return character '\\r' or when 'current equals the newline character '\\n' but the 'lastChar' does not equal '\\r'. This prevents the double increment of lineCounter for '\\r\\n' case. \n\nThis bug fix handles all scenarios correctly and increments the lineCounter as expected for each line termination thereby eliminating the assertion error."
}