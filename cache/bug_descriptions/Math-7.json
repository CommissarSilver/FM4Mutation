{
    "bug_id": 7,
    "bug_type": "SF",
    "buggy_lines": "                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                boolean needReset = currentEvent.reset(eventT, eventY);\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }",
    "code": "                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(state);\n                }\n            }\n\n            while (!occuringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n\n                // advance all event states to current time\n                currentEvent.stepAccepted(eventT, eventY);\n                isLastStep = currentEvent.stop();\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }",
    "fixed_code": "                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(state);\n                }\n            }\n\n            while (!occuringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventY);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }",
    "fixed_lines": "                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventY);\n                }",
    "masked_code": "                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(state);\n                }\n            }\n\n            while (!occuringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n\n                // advance all event states to current time\n>>> [ INFILL ] <<<\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }",
    "project": "Math",
    "test_error_message": "junit.framework.AssertionFailedError",
    "test_framework": "defects4j",
    "test_line": "          Assert.assertTrue(t >= tMin);",
    "test_name": "testEventsScheduling",
    "test_suite": "org.apache.commons.math3.ode.nonstiff.DormandPrince853IntegratorTest",
    "time_buggy": "2013-03-17 17:15:31 +0000",
    "time_fixed": "2013-03-19 14:09:08 +0000",
    "bug_description": "Bug ID: 7\nProject: Math\nBug Type: Software Failure (SF)\nTest Error Message: junit.framework.AssertionFailedError \n\nBug Description:\n\nThis bug occurs in the section of the code which handles event states during a mathematical computation. It uses a 'for' loop to iterate over different 'EventState' objects stored in the list 'occuringEvents'. The issue specifically comes from the usage of `remaining.stepAccepted(eventT, eventY)` where `eventT` is the event time and `eventY` is the interpolated state, and `remaining` is each `EventState` object being iterated.\n\nThe problematic lines are:\n\n                        for (final EventState remaining : occuringEvents) {\n                            remaining.stepAccepted(eventT, eventY);\n                        }\n                boolean needReset = currentEvent.reset(eventT, eventY);\n                    for (final EventState remaining : occuringEvents) {\n                            remaining.stepAccepted(eventT, eventY);\n                        }\n    \nThe broken code consists of two itemized loops and a 'reset' element which may not be functioning as expected. The `AssertionFailedError` generated by the junit testing framework indicates that one of the assertions in the test case evaluating this logic did not pass, pointing towards a probable cause within this piece of code. \n\nHow it's fixed:\n\nThe corrected code replaces the first problematic for loop with a loop that iterates over all the general 'eventStates', not just the 'occuringEvents'. The fixed code snippet is as follows:\n\n                for (final EventState state : eventsStates) {\n                     state.stepAccepted(eventT, eventY);\n                     isLastStep = isLastStep || state.stop();\n                 }\nThis switches the iterators in `stepAccepted` and `stop` from `remaining` to `state`. This adjustment ensures that it's not considering only the 'occuringEvents' but all 'eventStates' while performing the stepAccepted calculations. Not making this consideration would cause the `.stepAccepted` method to not be called on all 'eventStates' and therefore, causing an inappropriate state of events. \n\nIt also modifies how `isLastStep` is defined, changing it to be `true` if any of the 'eventStates' indicate that they are the last step, preserving more state than the original code would have."
}