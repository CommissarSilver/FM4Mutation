{
    "bug_id": 33,
    "bug_type": "SH SF",
    "buggy_lines": "",
    "code": "  public void matchConstraint(ObjectType constraintObj) {\n    // We only want to match contraints on anonymous types.\n\n    // Handle the case where the constraint object is a record type.\n    //\n    // param constraintObj {{prop: (number|undefined)}}\n    // function f(constraintObj) {}\n    // f({});\n    //\n    // We want to modify the object literal to match the constraint, by\n    // taking any each property on the record and trying to match\n    // properties on this object.\n    if (constraintObj.isRecordType()) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!hasProperty(prop)) {\n            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                .getLeastSupertype(propType);\n          }\n          defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }",
    "fixed_code": "  public void matchConstraint(ObjectType constraintObj) {\n    // We only want to match contraints on anonymous types.\n    if (hasReferenceName()) {\n      return;\n    }\n\n    // Handle the case where the constraint object is a record type.\n    //\n    // param constraintObj {{prop: (number|undefined)}}\n    // function f(constraintObj) {}\n    // f({});\n    //\n    // We want to modify the object literal to match the constraint, by\n    // taking any each property on the record and trying to match\n    // properties on this object.\n    if (constraintObj.isRecordType()) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!hasProperty(prop)) {\n            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                .getLeastSupertype(propType);\n          }\n          defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }",
    "fixed_lines": "    if (hasReferenceName()) {\n      return;\n    }",
    "masked_code": "  public void matchConstraint(ObjectType constraintObj) {\n    // We only want to match contraints on anonymous types.\n>>> [ INFILL ] <<<\n\n    // Handle the case where the constraint object is a record type.\n    //\n    // param constraintObj {{prop: (number|undefined)}}\n    // function f(constraintObj) {}\n    // f({});\n    //\n    // We want to modify the object literal to match the constraint, by\n    // taking any each property on the record and trying to match\n    // properties on this object.\n    if (constraintObj.isRecordType()) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!hasProperty(prop)) {\n            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                .getLeastSupertype(propType);\n          }\n          defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }",
    "project": "Closure",
    "test_error_message": "junit.framework.AssertionFailedError: unexpected warnings(s):",
    "test_framework": "defects4j",
    "test_line": "      fail(\"unexpected warnings(s):\\n\" + Joiner.on(\"\\n\").join(warnings));",
    "test_name": "testIssue700",
    "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
    "time_buggy": "2012-04-02 16:10:04 +0000",
    "time_fixed": "2012-04-02 21:17:00 +0000",
    "bug_description": "Bug ID: 33\n\nTitle: AssertionFailureError due to Unexpected Warning(s) in SH SF Type Bug in Closure Project\n\nInitial Code:\nThe impacted code is associated with a function `matchConstraint(ObjectType constraintObj)`. This function is designed to match constraints on anonymous types, addressing cases where the object is a record type. It modifies the object literal to match the constraint by taking each property on the record and attempting to match properties on the target object.\n\nBug Description:\nDuring testing, this section of code generated a `junit.framework.AssertionFailedError` with the error message indicating \"unexpected warning(s)\". It suggests that there might be an underlying issue that is perturbing the runtime execution.\n\nThe code runs through properties of a constraint object and performs two main checks. If a property type is not declared, it attempts to infer the type, and if the object doesn't have the property, it attempts to define it. However, no safeguard is there for named references that could potentially avoid unnecessary operations and risk of errors.\n\nError category: SH SF (Unexpected state change or state failure)\n\nFixed Code:\nThe provided solution adds a condition at the beginning of the function, which returns if the object has a reference name. This fix ensures that the function only operates on anonymous types, adhering to the initial comment's statement.\n\nThis implies that the function can circumvent unnecessary checks and operations ensuring smooth execution.\n\nSteps for Artificial Bug generation:\n1. Start with creating a function that works on objects of a specific type (in this case anonymous types).\n2. Introduce operations that modify the object or identify missing properties.\n3. Ignore validating the cases where the modifications or operations should not happen or have no effect (for instance, working on named references when the function is only for anonymous types).\n4. This will lead to erroneous operations on incompatible cases, thereby generating bugs related to unexpected state changes or state failures."
}