{
    "bug_id": 72,
    "bug_type": "SH SF",
    "buggy_lines": "",
    "code": "    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }",
    "fixed_code": "    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }",
    "fixed_lines": "        if (count < 1)\n            return \"\";",
    "masked_code": "    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n>>> [ INFILL ] <<<\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }",
    "project": "Jsoup",
    "test_error_message": "java.lang.StringIndexOutOfBoundsException: String index out of range: -1",
    "test_framework": "defects4j",
    "test_line": "        String after = r.consumeTo('>');",
    "test_name": "consumeToNonexistentEndWhenAtAnd",
    "test_suite": "org.jsoup.parser.CharacterReaderTest",
    "time_buggy": "2017-11-13 09:24:36 -0800",
    "time_fixed": "2017-11-14 11:34:20 -0800",
    "bug_description": "Bug Description:\n\nBug ID: 72\nProject: Jsoup\nBug Type: SH SF (Shift Signed-Left)\n\nError Message:\nThe application throws java.lang.StringIndexOutOfBoundsException with the message \"String index out of range: -1\". This exception typically arises when an attempt is made to access an index that is not within the limit of the given string or array.\n\nProblem:\nThe problem lies in the code block where the application attempts to create a hash of the character buffer (charBuf). If the count (number of elements to create hash) is less than or equal to zero, the offset in the for loop goes beyond the permissible range. Thus, it tries to access an index of charBuf[] array that does not exist, throwing StringIndexOutOfBoundsException.\n\nFaulty Code:\nThe error happens in the function cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count). The block causing the error is:\n\n    int hash = 0;\n    int offset = start;\n    for (int i = 0; i < count; i++) {\n        hash = 31 * hash + charBuf[offset++];\n    }\n\nResolution:\nTo correct this, a condition is included to check if the count is less than 1. If so, the function returns an empty string.\n\nFixed Code:\n\n    if (count > maxStringCacheLen)\n        return new String(charBuf, start, count);\n    if (count < 1)\n        return \"\";\n\nSteps to reproduce the bug (for creating artificial bugs):\n\n1. Consider an input where count <= 0 for the function cacheString().\n2. With such an input, the for loop tries to access the character buffer 'charBuf' at a location outside its range.\n3. Executing the buggy code block will result in java.lang.StringIndexOutOfBoundsException being thrown.\n\nTo validate the fix, repeat these steps with the modified code and verify whether the exception is thrown or not."
}