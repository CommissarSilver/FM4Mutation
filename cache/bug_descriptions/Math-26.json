{
    "bug_id": 26,
    "bug_type": "SF",
    "buggy_lines": "            if ((p2 > overflow) || (q2 > overflow)) {",
    "code": "    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n        throws FractionConversionException\n    {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long)FastMath.floor(r0);\n        if (a0 > overflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        // check for (almost) integer arguments, which should not go\n        // to iterations.\n        if (FastMath.abs(a0 - value) < epsilon) {\n            this.numerator = (int) a0;\n            this.denominator = 1;\n            return;\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        long p2 = 0;\n        long q2 = 1;\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            double r1 = 1.0 / (r0 - a0);\n            long a1 = (long)FastMath.floor(r1);\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n            if ((p2 > overflow) || (q2 > overflow)) {\n                throw new FractionConversionException(value, p2, q2);\n            }\n\n            double convergent = (double)p2 / (double)q2;\n            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                stop = true;\n            }\n        } while (!stop);\n\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        if (q2 < maxDenominator) {\n            this.numerator = (int) p2;\n            this.denominator = (int) q2;\n        } else {\n            this.numerator = (int) p1;\n            this.denominator = (int) q1;\n        }\n\n    }",
    "fixed_code": "    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n        throws FractionConversionException\n    {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long)FastMath.floor(r0);\n        if (FastMath.abs(a0) > overflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        // check for (almost) integer arguments, which should not go\n        // to iterations.\n        if (FastMath.abs(a0 - value) < epsilon) {\n            this.numerator = (int) a0;\n            this.denominator = 1;\n            return;\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        long p2 = 0;\n        long q2 = 1;\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            double r1 = 1.0 / (r0 - a0);\n            long a1 = (long)FastMath.floor(r1);\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n                throw new FractionConversionException(value, p2, q2);\n            }\n\n            double convergent = (double)p2 / (double)q2;\n            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                stop = true;\n            }\n        } while (!stop);\n\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        if (q2 < maxDenominator) {\n            this.numerator = (int) p2;\n            this.denominator = (int) q2;\n        } else {\n            this.numerator = (int) p1;\n            this.denominator = (int) q1;\n        }\n\n    }",
    "fixed_lines": "            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {",
    "masked_code": "    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n        throws FractionConversionException\n    {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long)FastMath.floor(r0);\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        // check for (almost) integer arguments, which should not go\n        // to iterations.\n        if (FastMath.abs(a0 - value) < epsilon) {\n            this.numerator = (int) a0;\n            this.denominator = 1;\n            return;\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        long p2 = 0;\n        long q2 = 1;\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            double r1 = 1.0 / (r0 - a0);\n            long a1 = (long)FastMath.floor(r1);\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n>>> [ INFILL ] <<<\n                throw new FractionConversionException(value, p2, q2);\n            }\n\n            double convergent = (double)p2 / (double)q2;\n            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                stop = true;\n            }\n        } while (!stop);\n\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        if (q2 < maxDenominator) {\n            this.numerator = (int) p2;\n            this.denominator = (int) q2;\n        } else {\n            this.numerator = (int) p1;\n            this.denominator = (int) q1;\n        }\n\n    }",
    "project": "Math",
    "test_error_message": "junit.framework.AssertionFailedError: an exception should have been thrown",
    "test_framework": "defects4j",
    "test_line": "            Assert.fail(\"an exception should have been thrown\");",
    "test_name": "testIntegerOverflow",
    "test_suite": "org.apache.commons.math3.fraction.FractionTest",
    "time_buggy": "2012-07-31 14:58:01 +0000",
    "time_fixed": "2012-08-01 21:24:27 +0000",
    "bug_description": "Bug Description:\n\nIn the Math project, a test error \"junit.framework.AssertionFailedError: an exception should have been thrown\" is showing, indicating a failure in the scenario where an exception was expected but was not thrown.\n\nBug ID: 26\nBug Type: Semantic Fault (SF)\n\nObserved Behavior:\nThe method \"private Fraction()\" in the Math project was expected to throw an exception when the absolute value of the variables \"p2\" or \"q2\" exceeds the defined maximum integer value \"Integer.MAX_VALUE\". However, the bug is that the exception was not thrown because the code only checked if \"p2\" or \"q2\" is greater than the overflow value, neglecting the scenario where \"p2\" or \"q2\" could be negative and less than the negative of the overflow value.\n\nBuggy Code Snippet:\n```\nif ((p2 > overflow) || (q2 > overflow)) {\n    throw new FractionConversionException(value, p2, q2);\n}\n```\n\nFix:\nIn the fixed code, it checks if the absolute value of \"p2\" or \"q2\" exceeds the overflow value, correctly covering the negative values scenario as well.\n\nFixed Code Snippet:\n```\nif ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n    throw new FractionConversionException(value, p2, q2);\n}\n```\n\nInstructions to Generate Similar Bugs:\n\n1. Write a method that calculates the value of a numeric variable based on some calculations.\n2. Define a limit for the acceptable value of the calculated variable.\n3. Throw an exception if the value of the calculated variable exceeds the defined limit.\n4. In the condition for throwing an exception, check only if the calculated variable is greater than the limit, neglecting the scenario where it could be less than the negative of that limit.\n5. Now run a test case where the value of the calculated variable becomes negative and less than the negative of the limit.\n6. Observe that the expected exception is not thrown, even though the absolute value of the calculated variable exceeds the limit. This indicates a semantic fault."
}