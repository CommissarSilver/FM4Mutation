{
    "bug_id": 23,
    "bug_type": "SL SH SF",
    "buggy_lines": "                dictSize |= (coder.properties[i + 1] << (8 * i));",
    "code": "    static class LZMADecoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            byte propsByte = coder.properties[0];\n            long dictSize = coder.properties[1];\n            for (int i = 1; i < 4; i++) {\n                dictSize |= (coder.properties[i + 1] << (8 * i));\n            }\n            if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n                throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n            }\n            return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n        }\n    }",
    "fixed_code": "    static class LZMADecoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            byte propsByte = coder.properties[0];\n            long dictSize = coder.properties[1];\n            for (int i = 1; i < 4; i++) {\n                dictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i);\n            }\n            if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n                throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n            }\n            return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n        }\n    }",
    "fixed_lines": "                dictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i);",
    "masked_code": "    static class LZMADecoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            byte propsByte = coder.properties[0];\n            long dictSize = coder.properties[1];\n            for (int i = 1; i < 4; i++) {\n>>> [ INFILL ] <<<\n            }\n            if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n                throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n            }\n            return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n        }\n    }",
    "project": "Compress",
    "test_error_message": "org.tukaani.xz.UnsupportedOptionsException: LZMA dictionary is too big for this implementation",
    "test_framework": "defects4j",
    "test_line": "        SevenZFile sevenZFile = new SevenZFile(getFile(\"COMPRESS-256.7z\"));",
    "test_name": "testCompressedHeaderWithNonDefaultDictionarySize",
    "test_suite": "org.apache.commons.compress.archivers.sevenz.SevenZFileTest",
    "time_buggy": "2014-01-20 13:26:08 +0000",
    "time_fixed": "2014-01-22 05:13:34 +0000",
    "bug_description": "Bug Description:\n\nProject: This bug is contained within the 'Compress' project.\n\nBug ID: The Bug ID is 23.\n\nBug Type: The bug type is specified as SL (Single Line bug), SH (Statement Hiding), and SF (Statement Fault).\n\nError Message: The test error message encountered outlining the problem is \"org.tukaani.xz.UnsupportedOptionsException: LZMA dictionary is too big for this implementation\". This indicates that the size of the LZMA dictionary exceeds what is supported by the program's current setup.\n\nBug Location: This bug is located within the 'LZMADecoder' static class, specifically in the 'decode' method. The exact line affected is \"dictSize |= (coder.properties[i + 1] << (8 * i))\", which represents a single line of buggy code, as classified by the bug type (SL).\n\nProblem Outline: The issue seems to arise when the program tries to define the size of the dictionary (dictSize), and specifically when assigning additional bits to this variable via bitwise OR assignment operator with left shift in the loop. If the result of this operation surpasses LZMAInputStream.DICT_SIZE_MAX constant, the program throws an IOException.\n\nCode Solution: The fixed version of this code performs a bitwise AND operation on the property being shifted left, with a hex value of 0xffl (representing 255 in decimal), before performing the bitwise OR assignment. This caps the additional contribution to the dictionary size to no more than 255 at each iteration, preventing 'dictSize' from exceeding the maximum allowed dictionary size.\n\nSteps for Developers to Replicate: Developers looking to replicate this issue should ensure they have an implementation that allows for dictionary sizes larger than 4GiB. They can then use data that requires a dictionary of this size. The size of the dictionary would then be auto-calculated and surpass LZMAInputStream.DICT_SIZE_MAX, triggering the org.tukaani.xz.UnsupportedOptionsException error. To fix such an issue, developers would need to cap the additional contribution to the dictionary size as the fixed code does."
}