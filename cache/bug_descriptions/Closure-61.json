{
    "bug_id": 61,
    "bug_type": "SH SF",
    "buggy_lines": "",
    "code": "  static boolean functionCallHasSideEffects(\n      Node callNode, @Nullable AbstractCompiler compiler) {\n    if (callNode.getType() != Token.CALL) {\n      throw new IllegalStateException(\n          \"Expected CALL node, got \" + Token.name(callNode.getType()));\n    }\n\n    if (callNode.isNoSideEffectsCall()) {\n      return false;\n    }\n\n    Node nameNode = callNode.getFirstChild();\n\n    // Built-in functions with no side effects.\n    if (nameNode.getType() == Token.NAME) {\n      String name = nameNode.getString();\n      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n        return false;\n      }\n    } else if (nameNode.getType() == Token.GETPROP) {\n      if (callNode.hasOneChild()\n          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(\n                nameNode.getLastChild().getString())) {\n        return false;\n      }\n\n      if (callNode.isOnlyModifiesThisCall()\n          && evaluatesToLocalValue(nameNode.getFirstChild())) {\n        return false;\n      }\n\n      // Functions in the \"Math\" namespace have no side effects.\n\n      if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n        if (nameNode.getFirstChild().getType() == Token.REGEXP\n            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n          return false;\n        } else if (nameNode.getFirstChild().getType() == Token.STRING\n            && STRING_REGEXP_METHODS.contains(\n                nameNode.getLastChild().getString())) {\n          Node param = nameNode.getNext();\n          if (param != null &&\n              (param.getType() == Token.STRING\n                  || param.getType() == Token.REGEXP))\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }",
    "fixed_code": "  static boolean functionCallHasSideEffects(\n      Node callNode, @Nullable AbstractCompiler compiler) {\n    if (callNode.getType() != Token.CALL) {\n      throw new IllegalStateException(\n          \"Expected CALL node, got \" + Token.name(callNode.getType()));\n    }\n\n    if (callNode.isNoSideEffectsCall()) {\n      return false;\n    }\n\n    Node nameNode = callNode.getFirstChild();\n\n    // Built-in functions with no side effects.\n    if (nameNode.getType() == Token.NAME) {\n      String name = nameNode.getString();\n      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n        return false;\n      }\n    } else if (nameNode.getType() == Token.GETPROP) {\n      if (callNode.hasOneChild()\n          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(\n                nameNode.getLastChild().getString())) {\n        return false;\n      }\n\n      if (callNode.isOnlyModifiesThisCall()\n          && evaluatesToLocalValue(nameNode.getFirstChild())) {\n        return false;\n      }\n\n      // Functions in the \"Math\" namespace have no side effects.\n      if (nameNode.getFirstChild().getType() == Token.NAME) {\n        String namespaceName = nameNode.getFirstChild().getString();\n        if (namespaceName.equals(\"Math\")) {\n          return false;\n        }\n      }\n\n      if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n        if (nameNode.getFirstChild().getType() == Token.REGEXP\n            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n          return false;\n        } else if (nameNode.getFirstChild().getType() == Token.STRING\n            && STRING_REGEXP_METHODS.contains(\n                nameNode.getLastChild().getString())) {\n          Node param = nameNode.getNext();\n          if (param != null &&\n              (param.getType() == Token.STRING\n                  || param.getType() == Token.REGEXP))\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }",
    "fixed_lines": "      if (nameNode.getFirstChild().getType() == Token.NAME) {\n        String namespaceName = nameNode.getFirstChild().getString();\n        if (namespaceName.equals(\"Math\")) {\n          return false;\n        }\n      }",
    "masked_code": "  static boolean functionCallHasSideEffects(\n      Node callNode, @Nullable AbstractCompiler compiler) {\n    if (callNode.getType() != Token.CALL) {\n      throw new IllegalStateException(\n          \"Expected CALL node, got \" + Token.name(callNode.getType()));\n    }\n\n    if (callNode.isNoSideEffectsCall()) {\n      return false;\n    }\n\n    Node nameNode = callNode.getFirstChild();\n\n    // Built-in functions with no side effects.\n    if (nameNode.getType() == Token.NAME) {\n      String name = nameNode.getString();\n      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n        return false;\n      }\n    } else if (nameNode.getType() == Token.GETPROP) {\n      if (callNode.hasOneChild()\n          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(\n                nameNode.getLastChild().getString())) {\n        return false;\n      }\n\n      if (callNode.isOnlyModifiesThisCall()\n          && evaluatesToLocalValue(nameNode.getFirstChild())) {\n        return false;\n      }\n\n      // Functions in the \"Math\" namespace have no side effects.\n>>> [ INFILL ] <<<\n\n      if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n        if (nameNode.getFirstChild().getType() == Token.REGEXP\n            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n          return false;\n        } else if (nameNode.getFirstChild().getType() == Token.STRING\n            && STRING_REGEXP_METHODS.contains(\n                nameNode.getLastChild().getString())) {\n          Node param = nameNode.getNext();\n          if (param != null &&\n              (param.getType() == Token.STRING\n                  || param.getType() == Token.REGEXP))\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }",
    "project": "Closure",
    "test_error_message": "junit.framework.AssertionFailedError:",
    "test_framework": "defects4j",
    "test_line": "    test(\"Math.sin(0);\", \"\");",
    "test_name": "testCall1",
    "test_suite": "com.google.javascript.jscomp.PeepholeRemoveDeadCodeTest",
    "time_buggy": "2011-06-28 21:46:43 +0000",
    "time_fixed": "2011-06-29 01:34:27 +0000",
    "bug_description": "Bug ID: 61\nProject: Closure\nBug Type: SH SF\nTest Error Message: junit.framework.AssertionFailedError:\n\nBug Description:\nThe bug is located in the function named 'functionCallHasSideEffects'. The function's intent is to determine if a function call has side effects. The code has a structure where it systematically checks certain conditions and returns false if conditions are met, signaling that the respective call has no side effects.\n\nThis function initially checks whether the type of the node is not a 'CALL' and then checks whether the call has no side effects. If both conditions are met, it returns false.\n\nThe function then examines the first child of the callnode. If it is a 'NAME' type, it verifies its string value against a built-in list of functions that do not have side effects. If a match exists, the code should return false as these functions are known not to have side effects.\n\nThe function then checks if the node is a 'GETPROP' type. If it is, it first checks if the 'callNode' only has one child and if this child's string value is contained in a list of object methods without side effects. If it is, the function returns false. Then, if the 'callNode' modifies only 'this' reference, and its first child evaluates to a local value, the code again returns false.\n\nThe problem lies in the segment of code afterward. Some methods from the \"Math\" namespace are intended to be without side effects, but the code does not check the \"Math\" namespace.\n\nFix Description:\nThe fixed code introduces a block that checks if the 'nameNode's first child is of the 'NAME' type. It then retrieves the string value of the first child, which should provide the namespace name. If this namespace equals \"Math\", it returns false as the \"Math\" namespace does not have any side effects.\n\nIn the artificial bug creation, developers should omit or alter parts of the program where failed assertions or incorrect function outputs can occur. The context of the bug suggests intentionality in forgetting to add in the check for the \"Math\" namespace, which can confuse bug detection due to the nature of the function's multiple return points. The bug here can be classified under Implementation bugs where the semantics of the requirements are incorrectly implemented."
}