{
    "bug_id": 62,
    "bug_type": "SH SF",
    "buggy_lines": "",
    "code": "    public CollectionDeserializer createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        // May need to resolve types for delegate-based creators:\n        JsonDeserializer<Object> delegateDeser = null;\n        if (_valueInstantiator != null) {\n            if (_valueInstantiator.canCreateUsingDelegate()) {\n                JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                if (delegateType == null) {\n                    throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType\n                            +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                            +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n                }\n                delegateDeser = findDeserializer(ctxt, delegateType, property);\n            }\n        }\n        // [databind#1043]: allow per-property allow-wrapping of single overrides:\n        // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n        //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n        // also, often value deserializer is resolved here:\n        JsonDeserializer<?> valueDeser = _valueDeserializer;\n        \n        // May have a content converter\n        valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n        final JavaType vt = _collectionType.getContentType();\n        if (valueDeser == null) {\n            valueDeser = ctxt.findContextualValueDeserializer(vt, property);\n        } else { // if directly assigned, probably not yet contextual, so:\n            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, vt);\n        }\n        // and finally, type deserializer needs context as well\n        TypeDeserializer valueTypeDeser = _valueTypeDeserializer;\n        if (valueTypeDeser != null) {\n            valueTypeDeser = valueTypeDeser.forProperty(property);\n        }\n        return withResolved(delegateDeser, valueDeser, valueTypeDeser, unwrapSingle);\n    }",
    "fixed_code": "    public CollectionDeserializer createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        // May need to resolve types for delegate-based creators:\n        JsonDeserializer<Object> delegateDeser = null;\n        if (_valueInstantiator != null) {\n            if (_valueInstantiator.canCreateUsingDelegate()) {\n                JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                if (delegateType == null) {\n                    throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType\n                            +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                            +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n                }\n                delegateDeser = findDeserializer(ctxt, delegateType, property);\n            } else if (_valueInstantiator.canCreateUsingArrayDelegate()) {\n                JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n                if (delegateType == null) {\n                    throw new IllegalArgumentException(\"Invalid array-delegate-creator definition for \"+_collectionType\n                            +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                            +\") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'\");\n                }\n                delegateDeser = findDeserializer(ctxt, delegateType, property);\n            }\n        }\n        // [databind#1043]: allow per-property allow-wrapping of single overrides:\n        // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n        //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n        // also, often value deserializer is resolved here:\n        JsonDeserializer<?> valueDeser = _valueDeserializer;\n        \n        // May have a content converter\n        valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n        final JavaType vt = _collectionType.getContentType();\n        if (valueDeser == null) {\n            valueDeser = ctxt.findContextualValueDeserializer(vt, property);\n        } else { // if directly assigned, probably not yet contextual, so:\n            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, vt);\n        }\n        // and finally, type deserializer needs context as well\n        TypeDeserializer valueTypeDeser = _valueTypeDeserializer;\n        if (valueTypeDeser != null) {\n            valueTypeDeser = valueTypeDeser.forProperty(property);\n        }\n        return withResolved(delegateDeser, valueDeser, valueTypeDeser, unwrapSingle);\n    }",
    "fixed_lines": "            } else if (_valueInstantiator.canCreateUsingArrayDelegate()) {\n                JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n                if (delegateType == null) {\n                    throw new IllegalArgumentException(\"Invalid array-delegate-creator definition for \"+_collectionType\n                            +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                            +\") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'\");\n                }\n                delegateDeser = findDeserializer(ctxt, delegateType, property);",
    "masked_code": "    public CollectionDeserializer createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        // May need to resolve types for delegate-based creators:\n        JsonDeserializer<Object> delegateDeser = null;\n        if (_valueInstantiator != null) {\n            if (_valueInstantiator.canCreateUsingDelegate()) {\n                JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                if (delegateType == null) {\n                    throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType\n                            +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                            +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n                }\n                delegateDeser = findDeserializer(ctxt, delegateType, property);\n>>> [ INFILL ] <<<\n            }\n        }\n        // [databind#1043]: allow per-property allow-wrapping of single overrides:\n        // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n        //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n        // also, often value deserializer is resolved here:\n        JsonDeserializer<?> valueDeser = _valueDeserializer;\n        \n        // May have a content converter\n        valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n        final JavaType vt = _collectionType.getContentType();\n        if (valueDeser == null) {\n            valueDeser = ctxt.findContextualValueDeserializer(vt, property);\n        } else { // if directly assigned, probably not yet contextual, so:\n            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, vt);\n        }\n        // and finally, type deserializer needs context as well\n        TypeDeserializer valueTypeDeser = _valueTypeDeserializer;\n        if (valueTypeDeser != null) {\n            valueTypeDeser = valueTypeDeser.forProperty(property);\n        }\n        return withResolved(delegateDeser, valueDeser, valueTypeDeser, unwrapSingle);\n    }",
    "project": "JacksonDatabind",
    "test_error_message": "java.lang.IllegalStateException: No default constructor for [collection type; class java.util.Collections$UnmodifiableSet, contains [simple type, class java.lang.Object]]",
    "test_framework": "defects4j",
    "test_line": "        Set<?> foo = mapper.readValue(EXPECTED_JSON, Set.class);",
    "test_name": "testUnmodifiable",
    "test_suite": "com.fasterxml.jackson.databind.creators.ArrayDelegatorCreatorForCollectionTest",
    "time_buggy": "2016-10-03 22:18:25 -0700",
    "time_fixed": "2016-10-04 16:07:13 -0700",
    "bug_description": "Bug Description:\n\n1. Bug ID: The unique identifier for this bug is 62.\n\n2. Project: This bug was encountered in the JacksonDatabind project.\n\n3. Bug Type: The type of bug has been categorized as SH SF (Syntax and Semantic Failure).\n\n4. Test Error Message: The underlying error message derived from the test was `java.lang.IllegalStateException: No default constructor for [collection type; class java.util.Collections$UnmodifiableSet, contains [simple type, class java.lang.Object]]`. This often implies that the program attempted to access or instantiate a class that doesn't have a default constructor available.\n\n5. Buggy Code: In the code snippet, it's evident that there is a method named `createContextual` in the `CollectionDeserializer` class. Inside this method, if the condition `_valueInstantiator.canCreateUsingDelegate()` is true, an object of type `JsonDeserializer<Object>` is created but failing as there is no default constructor available for the `UnmodifiableSet` class as noted in the error message.\n\n6. Root Cause: Looking at the error message closely, the java.lang.IllegalStateException occurs when encountering an immutable `UnmodifiableSet` as no default constructor is available for the collection type. This issue arises when the system attempts to deserialize an instance of `UnmodifiableSet` class.\n\n7. Fix: The fix involves an additional condition to check if `_valueInstantiator.canCreateUsingArrayDelegate()` is true. If this is also true, `JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());` is called. Then, it checks if this `delegateType` is null. If it is null, it throws an IllegalArgumentException else it gets deserialized by the `findDeserializer` method. \n\n8. Final Comment: The error derived from the immutable property of `UnmodifiableSet` and was resolved by checking if it can create using array delegate and therefore deserializing it accordingly."
}