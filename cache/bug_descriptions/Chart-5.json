{
    "bug_id": 5,
    "bug_type": "SF",
    "buggy_lines": "        if (index >= 0 && !this.allowDuplicateXValues) {",
    "code": "    public XYDataItem addOrUpdate(Number x, Number y) {\n        if (x == null) {\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(x);\n        if (index >= 0 && !this.allowDuplicateXValues) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            try {\n                overwritten = (XYDataItem) existing.clone();\n            }\n            catch (CloneNotSupportedException e) {\n                throw new SeriesException(\"Couldn't clone XYDataItem!\");\n            }\n            existing.setY(y);\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            if (this.autoSort) {\n                this.data.add(-index - 1, new XYDataItem(x, y));\n            }\n            else {\n                this.data.add(new XYDataItem(x, y));\n            }\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
    "fixed_code": "    public XYDataItem addOrUpdate(Number x, Number y) {\n        if (x == null) {\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(x, y);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(x);\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            try {\n                overwritten = (XYDataItem) existing.clone();\n            }\n            catch (CloneNotSupportedException e) {\n                throw new SeriesException(\"Couldn't clone XYDataItem!\");\n            }\n            existing.setY(y);\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            if (this.autoSort) {\n                this.data.add(-index - 1, new XYDataItem(x, y));\n            }\n            else {\n                this.data.add(new XYDataItem(x, y));\n            }\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
    "fixed_lines": "        if (this.allowDuplicateXValues) {\n            add(x, y);\n            return null;\n        }\n        if (index >= 0) {",
    "masked_code": "    public XYDataItem addOrUpdate(Number x, Number y) {\n        if (x == null) {\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(x);\n>>> [ INFILL ] <<<\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            try {\n                overwritten = (XYDataItem) existing.clone();\n            }\n            catch (CloneNotSupportedException e) {\n                throw new SeriesException(\"Couldn't clone XYDataItem!\");\n            }\n            existing.setY(y);\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            if (this.autoSort) {\n                this.data.add(-index - 1, new XYDataItem(x, y));\n            }\n            else {\n                this.data.add(new XYDataItem(x, y));\n            }\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
    "project": "Chart",
    "test_error_message": "java.lang.IndexOutOfBoundsException: Index: -1, Size: 1",
    "test_framework": "defects4j",
    "test_line": "        series.addOrUpdate(1.0, 2.0);",
    "test_name": "testBug1955483",
    "test_suite": "org.jfree.data.xy.junit.XYSeriesTests",
    "time_buggy": "2008-11-24 01:15:32 -0800 ",
    "time_fixed": "2008-11-24 01:19:36 -0800 ",
    "bug_description": "Bug Title: IndexOutOfBoundsException error in Chart project\n\nBug ID: 5\nProject: Chart\nBug Type: Software Failure (SF)\nTest Error Message: java.lang.IndexOutOfBoundsException: Index: -1, Size: 1\n\nDescription:\n\nThe 'addOrUpdate' method in the Chart project is throwing the OutOfBoundsException when attempting to add or update an item to the XYDataItem list. This error is suggesting that we try to access or remove an element beyond the actual size of the list or using a negative index.\n\nSteps to Replicate:\n1. A data item (XYDataItem) is being added or updated in the 'addOrUpdate' method.\n2. Initially, the 'x' parameter (which is the index) is checked to see if it is null. If true, an IllegalArgumentException is thrown.\n3. The next step is where the issue occurs. There is a conditional check (`if (index >= 0 && !this.allowDuplicateXValues)`) where the 'index' is checked to see if it is greater or equal to 0 and duplicate X Values are not allowed. If both hold true, it tries to get an element from the list using this index.\n4. However, if `indexOf(x)` has returned -1 (meaning, the element does not exist), we are effectively checking if -1 is greater or equal to 0 which is false, hence it skips this block.\n5. Now, in the else block, there's an attempt to add an element at a location derived from this index (`this.data.add(-index - 1, new XYDataItem(x, y))`). When 'autoSort' is true, we end up trying to add an element at `-(index) - 1 = -(-1) - 1 = 0 - 1 = -1` resulting in IndexOutOfBoundsException error since in Java, it is not allowed to use a negative index while accessing or removing an element from the list.\n\nFix:\nIn the Fixed code, before reaching to the point of checking the index, it first checks `this.allowDuplicateXValues`. If duplicates are allowed, it adds the x,y pair directly and returns with null (for XYDataItem overwritten). Otherwise, it proceeds to the existing logic without checking `!this.allowDuplicateXValues` alongside `index >= 0` in the same condition. This addition of the new check helps in preventing the problematic scenario from occurring again."
}