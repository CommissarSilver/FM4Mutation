{
    "bug_id": 40,
    "bug_type": "SF",
    "buggy_lines": "          JsName name = getName(ns.name, false);\n          if (name != null) {\n          }",
    "code": "    public void visit(NodeTraversal t, Node n, Node parent) {\n\n      // Record global variable and function declarations\n      if (t.inGlobalScope()) {\n        if (NodeUtil.isVarDeclaration(n)) {\n          NameInformation ns = createNameInformation(t, n, parent);\n          Preconditions.checkNotNull(ns);\n          recordSet(ns.name, n);\n        } else if (NodeUtil.isFunctionDeclaration(n)) {\n          Node nameNode = n.getFirstChild();\n          NameInformation ns = createNameInformation(t, nameNode, n);\n          if (ns != null) {\n            JsName nameInfo = getName(nameNode.getString(), true);\n            recordSet(nameInfo.name, nameNode);\n          }\n        } else if (NodeUtil.isObjectLitKey(n, parent)) {\n          NameInformation ns = createNameInformation(t, n, parent);\n          if (ns != null) {\n            recordSet(ns.name, n);\n          }\n        }\n      }\n\n      // Record assignments and call sites\n      if (n.isAssign()) {\n        Node nameNode = n.getFirstChild();\n\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        if (ns != null) {\n          if (ns.isPrototype) {\n            recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n          } else {\n            recordSet(ns.name, nameNode);\n          }\n        }\n      } else if (n.isCall()) {\n        Node nameNode = n.getFirstChild();\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        if (ns != null && ns.onlyAffectsClassDef) {\n          JsName name = getName(ns.name, false);\n          if (name != null) {\n          refNodes.add(new ClassDefiningFunctionNode(\n              name, n, parent, parent.getParent()));\n          }\n        }\n      }\n    }",
    "fixed_code": "    public void visit(NodeTraversal t, Node n, Node parent) {\n\n      // Record global variable and function declarations\n      if (t.inGlobalScope()) {\n        if (NodeUtil.isVarDeclaration(n)) {\n          NameInformation ns = createNameInformation(t, n, parent);\n          Preconditions.checkNotNull(ns);\n          recordSet(ns.name, n);\n        } else if (NodeUtil.isFunctionDeclaration(n)) {\n          Node nameNode = n.getFirstChild();\n          NameInformation ns = createNameInformation(t, nameNode, n);\n          if (ns != null) {\n            JsName nameInfo = getName(nameNode.getString(), true);\n            recordSet(nameInfo.name, nameNode);\n          }\n        } else if (NodeUtil.isObjectLitKey(n, parent)) {\n          NameInformation ns = createNameInformation(t, n, parent);\n          if (ns != null) {\n            recordSet(ns.name, n);\n          }\n        }\n      }\n\n      // Record assignments and call sites\n      if (n.isAssign()) {\n        Node nameNode = n.getFirstChild();\n\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        if (ns != null) {\n          if (ns.isPrototype) {\n            recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n          } else {\n            recordSet(ns.name, nameNode);\n          }\n        }\n      } else if (n.isCall()) {\n        Node nameNode = n.getFirstChild();\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        if (ns != null && ns.onlyAffectsClassDef) {\n          JsName name = getName(ns.name, true);\n          refNodes.add(new ClassDefiningFunctionNode(\n              name, n, parent, parent.getParent()));\n        }\n      }\n    }",
    "fixed_lines": "          JsName name = getName(ns.name, true);",
    "masked_code": "    public void visit(NodeTraversal t, Node n, Node parent) {\n\n      // Record global variable and function declarations\n      if (t.inGlobalScope()) {\n        if (NodeUtil.isVarDeclaration(n)) {\n          NameInformation ns = createNameInformation(t, n, parent);\n          Preconditions.checkNotNull(ns);\n          recordSet(ns.name, n);\n        } else if (NodeUtil.isFunctionDeclaration(n)) {\n          Node nameNode = n.getFirstChild();\n          NameInformation ns = createNameInformation(t, nameNode, n);\n          if (ns != null) {\n            JsName nameInfo = getName(nameNode.getString(), true);\n            recordSet(nameInfo.name, nameNode);\n          }\n        } else if (NodeUtil.isObjectLitKey(n, parent)) {\n          NameInformation ns = createNameInformation(t, n, parent);\n          if (ns != null) {\n            recordSet(ns.name, n);\n          }\n        }\n      }\n\n      // Record assignments and call sites\n      if (n.isAssign()) {\n        Node nameNode = n.getFirstChild();\n\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        if (ns != null) {\n          if (ns.isPrototype) {\n            recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n          } else {\n            recordSet(ns.name, nameNode);\n          }\n        }\n      } else if (n.isCall()) {\n        Node nameNode = n.getFirstChild();\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        if (ns != null && ns.onlyAffectsClassDef) {\n          refNodes.add(new ClassDefiningFunctionNode(\n              name, n, parent, parent.getParent()));\n>>> [ INFILL ] <<<\n        }\n      }\n    }",
    "project": "Closure",
    "test_error_message": "java.lang.RuntimeException: java.lang.RuntimeException: INTERNAL COMPILER ERROR.",
    "test_framework": "defects4j",
    "test_line": "    compiler.compile(",
    "test_name": "testIssue284",
    "test_suite": "com.google.javascript.jscomp.IntegrationTest",
    "time_buggy": "2012-02-01 23:11:47 +0000",
    "time_fixed": "2012-02-02 16:47:26 +0000",
    "bug_description": "Bug ID: 40\nProject: Closure\nBug Type: SF (Statement Fault)\n\nStep 1: Context \nThe bug is located in the Closure project, specifically within the 'public void visit(NodeTraversal t, Node n, Node parent)' function. This function seems to be the part of a visitor pattern, which is used to perform operations over nodes of a certain datatype, in this case JavaScript name nodes. \n\nStep 2: Description of Test Error Message \nThe Test Error Message reports an 'INTERNAL COMPILER ERROR'. This suggests a problem with the compiler as it fails to execute without breaking.\n\nStep 3: Code Spotting\nThe issue comes from these two lines:\n\n    JsName name = getName(ns.name, false);\n    if (name != null) { }\n\nHere, the program retrieves a name from a provided namespace and makes a check whether the name exists. However, the compiler error is generated in the process.\n\nStep 4: Understanding Problem in Context\nLooking at the rest of the system, there seems to be a misunderstanding of the function 'getName()'. Going by the bug-fix, the boolean flag passed to the 'getName()' function seems to respond differently based on whether it is 'true' or 'false'. 'True' allows the code to execute normally, while 'false' triggers the compiler error.\n\nStep 5: The Fix\nIn the fixed code, the 'false' flag in the 'getName()' function has been replaced with 'true':\n\n    JsName name = getName(ns.name, true);\n\nInstead of causing the compiler error, this line retrieves a name based on 'ns.name' and does not cause the error as it is setup to handle this condition correctly.\n\nStep 6: Conclusion\nIn conclusion, this minor change in the boolean flag from 'false' to 'true' being passed to 'getName()', along with the corresponding code changes, addresses Bug #40. This issue is classified as an SF (Statement Fault), as it involves a false statement or incorrect function call that led to the 'INTERNAL COMPILER ERROR'."
}