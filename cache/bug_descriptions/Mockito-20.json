{
    "bug_id": 20,
    "bug_type": "SF",
    "buggy_lines": "                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),",
    "code": "    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n            throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n        }\n        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n                settings.getTypeToMock(),\n                settings.getExtraInterfaces()\n        );\n        T mockInstance = null;\n        try {\n            mockInstance = classInstantiator.instantiate(mockedProxyType);\n            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n\n            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n        } catch (ClassCastException cce) {\n            throw new MockitoException(join(\n                    \"ClassCastException occurred while creating the mockito mock :\",\n                    \"  class to mock : \" + describeClass(mockedProxyType),\n                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n                    \"  proxy instance class : \" + describeClass(mockInstance),\n                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n                    \"\",\n                    \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                    \"\"\n            ),cce);\n        } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n            throw new MockitoException(\"Unable to create mock instance of type '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n        }\n    }",
    "fixed_code": "    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n            throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n        }\n        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n                settings.getTypeToMock(),\n                settings.getExtraInterfaces()\n        );\n        Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings);\n        T mockInstance = null;\n        try {\n            mockInstance = instantiator.newInstance(mockedProxyType);\n            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n\n            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n        } catch (ClassCastException cce) {\n            throw new MockitoException(join(\n                    \"ClassCastException occurred while creating the mockito mock :\",\n                    \"  class to mock : \" + describeClass(mockedProxyType),\n                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n                    \"  proxy instance class : \" + describeClass(mockInstance),\n                    \"  instance creation by : \" + instantiator.getClass().getSimpleName(),\n                    \"\",\n                    \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                    \"\"\n            ),cce);\n        } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n            throw new MockitoException(\"Unable to create mock instance of type '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n        }\n    }",
    "fixed_lines": "                    \"  instance creation by : \" + instantiator.getClass().getSimpleName(),",
    "masked_code": "    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n            throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n        }\n        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n                settings.getTypeToMock(),\n                settings.getExtraInterfaces()\n        );\n        T mockInstance = null;\n        try {\n            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n\n            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n        } catch (ClassCastException cce) {\n            throw new MockitoException(join(\n                    \"ClassCastException occurred while creating the mockito mock :\",\n                    \"  class to mock : \" + describeClass(mockedProxyType),\n                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n                    \"  proxy instance class : \" + describeClass(mockInstance),\n>>> [ INFILL ] <<<\n                    \"\",\n                    \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                    \"\"\n            ),cce);\n        } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n            throw new MockitoException(\"Unable to create mock instance of type '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n        }\n    }",
    "project": "Mockito",
    "test_error_message": "junit.framework.ComparisonFailure: expected:<[inner] strength> but was:<[null] strength>",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(\"inner strength\", outer.strength.fullStrength());",
    "test_name": "should_spy_inner_class",
    "test_suite": "org.mockitousage.annotation.SpyAnnotationTest",
    "time_buggy": "2015-02-16 00:10:52 +0100",
    "time_fixed": "2015-02-16 00:10:52 +0100",
    "bug_description": "Bug ID: 20\n\nProject: Mockito\n\nBug Type: SF (Software Fault)\n\n1. Bug Overview:\nThe bug is present in the 'createMock' method of the Mockito project. In the context of this bug, the term 'mock' refers to an object that has the same interface as a 'real' object but which you can manipulate to behave as you wish. It seems that Mockito, which is a mocking framework, is unable to create mock instances correctly due to a faulty implementation of instance creation.\n\n2. Bug Detail:\nThe test error message \"junit.framework.ComparisonFailure: expected:<[inner] strength> but was:<[null] strength>\" suggests that the test encountered a problem where it expected to receive an instantiated object (inner strength), but received a null object (null strength) instead. \n\nThe bug occurs in the 'try' clause of the 'createMock' method where a mock instance is attempted to be created by calling the 'instantiate' method with 'mockedProxyType' as the parameter on the 'classInstantiator' object (refer to the buggy line). However, this 'classInstantiator' object is not successfully creating the mock instances, which causes a null object to be returned, leading to unexpected program behavior. \n\n3. Steps to Reproduce:\n   - Call `createMock` method with appropriate settings and handler parameters.\n   - Inside this method, the code will try to use `classInstantiator.instantiate(mockedProxyType)` to create an instance for the mockedProxyType.\n   - The above step produces a null object instead of a properly instantiated one.\n\n4. Root Cause:\nThe root cause of the error is the improper instantiation of the mockedProxyType object inside the createMock method. This failure leads to the creation of null objects instead of properly instantiated ones.\n\n5. Resolution:\nThe fix involves using the corrected method of instance creation. The Mockito code was refactored to now use `Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings)` to get an inherent `Instantiator` object. Then, the newly created `Instantiator` instance is used to create a mock instance by calling `instantiator.newInstance(mockedProxyType)`. This crucial change from using `classInstantiator.instantiate(mockedProxyType)` to use `instantiator.newInstance(mockedProxyType)` resolves the bug and ensures correct and successful instantiation of the mockedProxyType objects."
}