{
    "bug_id": 13,
    "bug_type": "SF",
    "buggy_lines": "        Node next = c.getNext();",
    "code": "  private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      Node c = node.getFirstChild();\n      while(c != null) {\n        traverse(c);\n        Node next = c.getNext();\n        c = next;\n      }\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n  }",
    "fixed_code": "  private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      Node c = node.getFirstChild();\n      while(c != null) {\n        Node next = c.getNext();\n        traverse(c);\n        c = next;\n      }\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n  }",
    "fixed_lines": "        Node next = c.getNext();",
    "masked_code": "  private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      Node c = node.getFirstChild();\n      while(c != null) {\n        traverse(c);\n>>> [ INFILL ] <<<\n        c = next;\n      }\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n  }",
    "project": "Closure",
    "test_error_message": "junit.framework.AssertionFailedError:",
    "test_framework": "defects4j",
    "test_line": "    assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +",
    "test_name": "testIssue787",
    "test_suite": "com.google.javascript.jscomp.IntegrationTest",
    "time_buggy": "2012-08-02 11:13:41 +0000",
    "time_fixed": "2012-08-02 17:53:06 +0000",
    "bug_description": "Bug Description:\n\nBug ID: 13 belongs to the Closure project.\n\nThe bug type is specified as SF.\n\nThe Error Message that is returned by the JUnit testing tool for this bug is a failure in an assertion statement. The specific error is a junit.framework.AssertionFailedError, which typically arises when a junit assert statement fails to validate.\n\nThe source of this error lies in the following line: \n\n              Node next = c.getNext();\n              \nThis line is within a loop that traverses, what seems like, a tree data structure. The goal of this tree traversal is stated to avoid retaversing the entire AST (Abstract Syntax Tree) to catch newly created opportunities. Node 'c' is assigned the first child of the node, and then the code proceeds in a loop to traverse each node and move to the next node.\n\nThe bug arises because the traverse(c) function is called before the next node is retrieved. This disrupts the traversal process because the traverse function could potentially modify the structure of the tree, making the next node retrieval inappropriate.\n\nIn the fixed code, the faulty line is moved above the traverse line. This ensures that we first keep a reference to the next node before traversing the current one, ensuring the ACCURACY and COMPLETENESS of the traversal process by allowing the code to correctly proceed to the next node in the original structure, even if the traverse function modifies it.\n\nThe traversal function is a critical function given its purpose, and fixing this bug ensures that the system code that relies on the traverse function behaves correctly, thus IMPROVING the OVERALL RELIABILITY and STABILITY of new operations on the AST structure.\n\nThis bug can be artificially reproduced by shifting the traverse(c) function call before the next node in a tree or linked list is retrieved which is critical for the ongoing traversal process."
}