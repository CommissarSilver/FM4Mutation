{
    "bug_id": 42,
    "bug_type": "SF",
    "buggy_lines": "          if (basicRows.contains(basicRow)) {",
    "code": "    protected RealPointValuePair getSolution() {\n      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n\n      Set<Integer> basicRows = new HashSet<Integer>();\n      double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      for (int i = 0; i < coefficients.length; i++) {\n          int colIndex = columnLabels.indexOf(\"x\" + i);\n          if (colIndex < 0) {\n            coefficients[i] = 0;\n            continue;\n          }\n          Integer basicRow = getBasicRow(colIndex);\n              // if the basic row is found to be the objective function row\n              // set the coefficient to 0 -> this case handles unconstrained \n              // variables that are still part of the objective function\n          if (basicRows.contains(basicRow)) {\n              // if multiple variables can take a given value\n              // then we choose the first and set the rest equal to 0\n              coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n          } else {\n              basicRows.add(basicRow);\n              coefficients[i] =\n                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                  (restrictToNonNegative ? 0 : mostNegative);\n          }\n      }\n      return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }",
    "fixed_code": "    protected RealPointValuePair getSolution() {\n      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n\n      Set<Integer> basicRows = new HashSet<Integer>();\n      double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      for (int i = 0; i < coefficients.length; i++) {\n          int colIndex = columnLabels.indexOf(\"x\" + i);\n          if (colIndex < 0) {\n            coefficients[i] = 0;\n            continue;\n          }\n          Integer basicRow = getBasicRow(colIndex);\n          if (basicRow != null && basicRow == 0) {\n              // if the basic row is found to be the objective function row\n              // set the coefficient to 0 -> this case handles unconstrained \n              // variables that are still part of the objective function\n              coefficients[i] = 0;\n          } else if (basicRows.contains(basicRow)) {\n              // if multiple variables can take a given value\n              // then we choose the first and set the rest equal to 0\n              coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n          } else {\n              basicRows.add(basicRow);\n              coefficients[i] =\n                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                  (restrictToNonNegative ? 0 : mostNegative);\n          }\n      }\n      return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }",
    "fixed_lines": "          if (basicRow != null && basicRow == 0) {\n              coefficients[i] = 0;\n          } else if (basicRows.contains(basicRow)) {",
    "masked_code": "    protected RealPointValuePair getSolution() {\n      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n\n      Set<Integer> basicRows = new HashSet<Integer>();\n      double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      for (int i = 0; i < coefficients.length; i++) {\n          int colIndex = columnLabels.indexOf(\"x\" + i);\n          if (colIndex < 0) {\n            coefficients[i] = 0;\n            continue;\n          }\n          Integer basicRow = getBasicRow(colIndex);\n              // if the basic row is found to be the objective function row\n              // set the coefficient to 0 -> this case handles unconstrained \n              // variables that are still part of the objective function\n>>> [ INFILL ] <<<\n              // if multiple variables can take a given value\n              // then we choose the first and set the rest equal to 0\n              coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n          } else {\n              basicRows.add(basicRow);\n              coefficients[i] =\n                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                  (restrictToNonNegative ? 0 : mostNegative);\n          }\n      }\n      return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }",
    "project": "Math",
    "test_error_message": "junit.framework.AssertionFailedError",
    "test_framework": "defects4j",
    "test_line": "        Assert.assertTrue(Precision.compareTo(solution.getPoint()[1], 0.0d, epsilon) >= 0);",
    "test_name": "testMath713NegativeVariable",
    "test_suite": "org.apache.commons.math.optimization.linear.SimplexSolverTest",
    "time_buggy": "2011-11-28 20:00:14 +0000",
    "time_fixed": "2011-11-28 20:16:28 +0000",
    "bug_description": "Bug ID: 42\nProject: Math\nBug Type: SF (Simple Fix)\n\nBug Description:\n\n1. The issue was detected within the 'getSolution()' method of the Math project.\n\n2. The root issue that led to the bug was that the 'basicRow' variable which received its value from 'getBasicRow(colIndex)' function was not properly checked for null or zero values before these were used in subsequent lines of code, 'if (basicRows.contains(basicRow))' in particular.\n\n3. Because of this lack of check, the code could not behave appropriately in situations where 'basicRow' resulted in null or zero. \n\n4. This issue triggered the 'junit.framework.AssertionFailedError' as the test case expected a non-null or non-zero 'basicRow'.\n\n5. Additionally, tests failed to go through as expected when 'basicRow' was not amongst the 'basicRows' collection but the code continued to assign a value to the 'coefficients' array on the same index.\n\n6. These issues together led to the occurrence of the bug, making the 'getSolution()' method malfunction under these conditions.\n\nFix Description:\n\n1. The developer resolved the issue by incorporating a precise check for 'basicRow' where it would not be null and would not contain a zero value i.e., 'if (basicRow != null && basicRow == 0)'.\n\n2. With this additional condition in place, the code can now handle the situation much more efficiently, avoiding the triggering of 'junit.framework.AssertionFailedError'.\n\n3. The developer also added the condition 'else if (basicRows.contains(basicRow))' to correctly handle cases where 'basicRow' is in the 'basicRows' set.\n\n4. The code can now correctly implement its logic, ending the resulting value of the 'coefficients' array in each cycle of the loop.\n\n5. With these changes incorporated, the program does not encounter the Bug ID: 42 issue anymore, and the 'getSolution()' function now works as expected."
}