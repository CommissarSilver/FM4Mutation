{
    "bug_id": 25,
    "bug_type": "SL SH SF",
    "buggy_lines": "            if (i <= maxCode) {",
    "code": "    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }",
    "fixed_code": "    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }",
    "fixed_lines": "            if (i < maxCode) {",
    "masked_code": "    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n>>> [ INFILL ] <<<\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }",
    "project": "JacksonCore",
    "test_error_message": "java.lang.ArrayIndexOutOfBoundsException: 256",
    "test_framework": "defects4j",
    "test_line": "            p.nextToken();",
    "test_name": "testUnquotedIssue510",
    "test_suite": "com.fasterxml.jackson.core.read.NonStandardUnquotedNamesTest",
    "time_buggy": "2019-01-16 22:50:30 -0800",
    "time_fixed": "2019-01-16 23:06:00 -0800",
    "bug_description": "Bug Description:\n\n1. Bug ID: The specific bug in question has been assigned an ID of 25 for identification and tracking purposes.\n\n2. Project: The faulty code belonged to the project named 'JacksonCore'.\n\n3. Bug Type: The bug is categorized under the code 'SL SH SF' which might refer to specific bug types in the maintainers' bug taxonomy.\n\n4. Test Error Message: The test case for the associated code snippet throws an 'ArrayIndexOutOfBoundsException' with the out of bound index at 256. This exception usually gets thrown when an array is accessed with an illegal index. The index is either negative or greater than or equal to the size of the array.\n\n5. Code: The buggy line is specifically \"if (i <= maxCode)\". 'i' is the integer representation of a character from an input buffer. 'maxCode' is the length of the 'codes' array which is passed as a parameter. The codes array's indices might span from 0 to maxCode-1. Thus, allowing 'i' to be equal to 'maxCode' might be the cause of the 'ArrayIndexOutOfBoundsException'.\n\n6. Buggy Lines: The buggy line \"if (i <= maxCode)\" can result in an attempt to access an index of the 'codes' array that is not within the valid range, thus throwing the 'ArrayIndexOutOfBoundsException'.\n\n7. Fixed Code: In the corrected version of the code, the bug is fixed by changing the condition from \"if (i <= maxCode)\" to \"if (i < maxCode)\". This correction ensures that 'i' can now only fetch indices that exist within the 'codes' array, thus, preventing the 'ArrayIndexOutOfBoundsException'.\n\n8. Expected behavior for fixed code: After the correction, for any character in the input buffer, its integer representation 'i' will only be allowed to index into the 'codes' array if 'i' is less than the array's length. Thus, it will avoid the previously encountered 'ArrayIndexOutOfBoundsException'."
}