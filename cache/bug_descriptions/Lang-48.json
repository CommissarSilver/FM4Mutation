{
    "bug_id": 48,
    "bug_type": "SF",
    "buggy_lines": "",
    "code": "    public EqualsBuilder append(Object lhs, Object rhs) {\n        if (isEquals == false) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null || rhs == null) {\n            this.setEquals(false);\n            return this;\n        }\n        Class lhsClass = lhs.getClass();\n        if (!lhsClass.isArray()) {\n                // The simple case, not an array, just test the element\n                isEquals = lhs.equals(rhs);\n        } else if (lhs.getClass() != rhs.getClass()) {\n            // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] \n            this.setEquals(false);\n        }\n        // 'Switch' on type of array, to dispatch to the correct handler\n        // This handles multi dimensional arrays of the same depth\n        else if (lhs instanceof long[]) {\n            append((long[]) lhs, (long[]) rhs);\n        } else if (lhs instanceof int[]) {\n            append((int[]) lhs, (int[]) rhs);\n        } else if (lhs instanceof short[]) {\n            append((short[]) lhs, (short[]) rhs);\n        } else if (lhs instanceof char[]) {\n            append((char[]) lhs, (char[]) rhs);\n        } else if (lhs instanceof byte[]) {\n            append((byte[]) lhs, (byte[]) rhs);\n        } else if (lhs instanceof double[]) {\n            append((double[]) lhs, (double[]) rhs);\n        } else if (lhs instanceof float[]) {\n            append((float[]) lhs, (float[]) rhs);\n        } else if (lhs instanceof boolean[]) {\n            append((boolean[]) lhs, (boolean[]) rhs);\n        } else {\n            // Not an array of primitives\n            append((Object[]) lhs, (Object[]) rhs);\n        }\n        return this;\n    }",
    "fixed_code": "    public EqualsBuilder append(Object lhs, Object rhs) {\n        if (isEquals == false) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null || rhs == null) {\n            this.setEquals(false);\n            return this;\n        }\n        Class lhsClass = lhs.getClass();\n        if (!lhsClass.isArray()) {\n            if (lhs instanceof java.math.BigDecimal) {\n                isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0);\n            } else {\n                // The simple case, not an array, just test the element\n                isEquals = lhs.equals(rhs);\n            }\n        } else if (lhs.getClass() != rhs.getClass()) {\n            // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] \n            this.setEquals(false);\n        }\n        // 'Switch' on type of array, to dispatch to the correct handler\n        // This handles multi dimensional arrays of the same depth\n        else if (lhs instanceof long[]) {\n            append((long[]) lhs, (long[]) rhs);\n        } else if (lhs instanceof int[]) {\n            append((int[]) lhs, (int[]) rhs);\n        } else if (lhs instanceof short[]) {\n            append((short[]) lhs, (short[]) rhs);\n        } else if (lhs instanceof char[]) {\n            append((char[]) lhs, (char[]) rhs);\n        } else if (lhs instanceof byte[]) {\n            append((byte[]) lhs, (byte[]) rhs);\n        } else if (lhs instanceof double[]) {\n            append((double[]) lhs, (double[]) rhs);\n        } else if (lhs instanceof float[]) {\n            append((float[]) lhs, (float[]) rhs);\n        } else if (lhs instanceof boolean[]) {\n            append((boolean[]) lhs, (boolean[]) rhs);\n        } else {\n            // Not an array of primitives\n            append((Object[]) lhs, (Object[]) rhs);\n        }\n        return this;\n    }",
    "fixed_lines": "            if (lhs instanceof java.math.BigDecimal) {\n                isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0);\n            } else {\n            }",
    "masked_code": "    public EqualsBuilder append(Object lhs, Object rhs) {\n        if (isEquals == false) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null || rhs == null) {\n            this.setEquals(false);\n            return this;\n        }\n        Class lhsClass = lhs.getClass();\n        if (!lhsClass.isArray()) {\n                // The simple case, not an array, just test the element\n                isEquals = lhs.equals(rhs);\n>>> [ INFILL ] <<<\n        } else if (lhs.getClass() != rhs.getClass()) {\n            // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] \n            this.setEquals(false);\n        }\n        // 'Switch' on type of array, to dispatch to the correct handler\n        // This handles multi dimensional arrays of the same depth\n        else if (lhs instanceof long[]) {\n            append((long[]) lhs, (long[]) rhs);\n        } else if (lhs instanceof int[]) {\n            append((int[]) lhs, (int[]) rhs);\n        } else if (lhs instanceof short[]) {\n            append((short[]) lhs, (short[]) rhs);\n        } else if (lhs instanceof char[]) {\n            append((char[]) lhs, (char[]) rhs);\n        } else if (lhs instanceof byte[]) {\n            append((byte[]) lhs, (byte[]) rhs);\n        } else if (lhs instanceof double[]) {\n            append((double[]) lhs, (double[]) rhs);\n        } else if (lhs instanceof float[]) {\n            append((float[]) lhs, (float[]) rhs);\n        } else if (lhs instanceof boolean[]) {\n            append((boolean[]) lhs, (boolean[]) rhs);\n        } else {\n            // Not an array of primitives\n            append((Object[]) lhs, (Object[]) rhs);\n        }\n        return this;\n    }",
    "project": "Lang",
    "test_error_message": "junit.framework.AssertionFailedError",
    "test_framework": "defects4j",
    "test_line": "        assertTrue(new EqualsBuilder().append(o1, o2).isEquals());",
    "test_name": "testBigDecimal",
    "test_suite": "org.apache.commons.lang.builder.EqualsBuilderTest",
    "time_buggy": "2008-01-13 03:46:28 +0000",
    "time_fixed": "2008-01-13 07:00:22 +0000",
    "bug_description": "Bug ID: 48\n\nProject Name: Lang\n\nBug Type: SF (Software Fault)\n\nTest Error Message: junit.framework.AssertionFailedError\n\nBuggy Lines: The error lies within the \"append(Object lhs, Object rhs)\" method of the class.\n\nIssue Detected: The method is trying to compare two objects to check if they are equivalent. However, if the Object being compared is of type 'java.math.BigDecimal', the method fails because it directly uses the equals() method for comparison. The equals() method checks for object equivalency which is not practical for 'java.math.BigDecimal' type since two big decimal objects could be numerically equal but have different scales, resulting in the equals method identifying them as different.\n\nSteps:\n1. In your application, try to compare two 'java.math.BigDecimal' objects with the same numeric value but different scales using the \"append(Object lhs, Object rhs)\" method.\n2. The comparison will fail and return the wrong result stating they are different.\n3. Note that the junit.framework.AssertionFailedError error message will be displayed.\n\nSolution:\nThe solution to the bug involves adding a check for the 'java.math.BigDecimal' object type before performing the equivalence operation. The BigDecimal class comprises a specific method (compareTo) used to compare BigDecimal instances accurately while considering their scale. \n\nModified/Fixed Code:\nIn the fixed code, a condition is now checked:\n```java\nif (lhs instanceof java.math.BigDecimal) {\n    isEquals = ((java.math.BigDecimal)lhs).compareTo(rhs) == 0; // It should return true if the 'Numeric value' of lhs and rhs is equal.\n} \n```\nThis adjustment resolves the bug by accurately comparingBigDecimal type objects. This solution won't return a false positive for BigDecimal objects with the same value but different scales. \n\nNote: It's vital to cast your object to 'java.math.BigDecimal' before using its compareTo method."
}