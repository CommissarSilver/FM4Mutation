{
    "bug_id": 7,
    "bug_type": "SF",
    "buggy_lines": "        int defaultYear = chrono.year().get(instantLocal);",
    "code": "    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        int defaultYear = chrono.year().get(instantLocal);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }",
    "fixed_code": "    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }",
    "fixed_lines": "        int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);",
    "masked_code": "    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n>>> [ INFILL ] <<<\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }",
    "project": "Time",
    "test_error_message": "org.joda.time.IllegalFieldValueException: Cannot parse \"2 29\": Value 29 for dayOfMonth must be in the range [1,28]",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(4, f.parseInto(result, \"2 29\", 0));",
    "test_name": "testParseInto_monthDay_feb29_newYork_startOfYear",
    "test_suite": "org.joda.time.format.TestDateTimeFormatter",
    "time_buggy": "2013-07-20 13:48:36 +0100",
    "time_fixed": "2013-07-21 01:12:57 +0100",
    "bug_description": "Bug ID: 7\nProject: Time\nBug Type: Semantic Failure (SF)\nTest Error Message: org.joda.time.IllegalFieldValueException: Cannot parse \"2 29\": Value 29 for dayOfMonth must be in the range [1,28]\n\nStep-by-step Bug Description:\n\n1. The exception indicates that there is an issue with parsing a date value. Specifically, the value \"2 29\" cannot be parsed because the day of the month, being 29, exceeds the maximum limit for the month, which is 28.\n\n2. The exception arose as a result of the execution of the integer 'defaultYear' parameter in the Buggy Line: 'int defaultYear = chrono.year().get(instantLocal);'. This part of the code is trying to get the year from the current instant in time.\n\n3. Looking at the Code block provided, this error stems from runnable code within the 'parseInto' method. The 'parseInto' method is within a class that deals with date and time functionality. \n\n4. The exception may have been triggered by an attempt to parse data that includes a leap day (i.e., February 29) for a non-leap year because for a standard year, February only has 28 days.\n\n5. In order to fix the bug, the developer has used the 'DateTimeUtils.getChronology(chrono).year().get(instantMillis);' expression instead of 'chrono.year().get(instantLocal);' to calculate the 'defaultYear.'. The 'getChronology' utility method is used to ensure that the correct chronology - or date-time calculation method - is applied to the 'chrono' object. \n\n6. The developer has also moved the 'defaultYear' calculation before the calculation of 'instantLocal,' which could have potentially acted as a factor in triggering the exception. \n\n7. The Fixed Code reintegrates the modified 'parseInto' method, presumably back into the class it was initially part of. The 'parseInto' method now handles both standard and leap years correctly, preventing the 'IllegalFieldValueException' from being thrown. \n\n8. This fix should now result in the relevant date parsing operating correctly across leap years and standard years without generating exceptions. \n\nCreation of Artificial Java Bugs for Learning:\n\nThis issue can be recreated for learning purposes by creating a similar method. The new method would involve date parsing operations using an instance of 'Chronology' and input of a date string with 29 days in February of a non-leap year. This can educate developers on the importance of correctly using and composing time and date functionality within Java."
}