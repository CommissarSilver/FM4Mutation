{
    "bug_id": 16,
    "bug_type": "SL SH SF",
    "buggy_lines": "            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);",
    "code": "    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }",
    "fixed_code": "    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }",
    "fixed_lines": "            instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));",
    "masked_code": "    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n>>> [ INFILL ] <<<\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }",
    "project": "Time",
    "test_error_message": "junit.framework.AssertionFailedError: expected:<2004-05-01T12:20:30.000+09:00> but was:<2000-05-01T12:20:30.000+09:00>",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(new MutableDateTime(2004, 5, 1, 12, 20, 30, 0, TOKYO), result);",
    "test_name": "testParseInto_monthOnly_baseStartYear",
    "test_suite": "org.joda.time.format.TestDateTimeFormatter",
    "time_buggy": "2012-03-30 23:33:38 +0100",
    "time_fixed": "2012-04-30 12:14:37 +0100",
    "bug_description": "Bug ID: 16  \nProject: Time  \nBug Type: Software Log Issue, Syntax Error, Semantic Fault \n\nDescription:\nThe error occurred in the 'parseInto' public function of the 'Time' project. The function is responsible for parsing a date string into a readable date format and assigning it to an instant (a point in time). It takes a ReadWritableInstant object (the date/time to be parsed), a string (the date/time string), and an integer (position where parsing should start in the string) as input. \n\nDetailed Flow:\n\n- After the declaration and initialization of variables and objects, it uses the DateTimeParserBucket to instantiate the 'bucket' object that calculates and stores various states during parsing.\n- The problematic line is the one creating new `DateTimeParserBucket`, particularly this part `iDefaultYear`.\n- An AssertionError was thrown from a JUnit test which spotted that the year 2004 was expected, but the year 2000 was returned.\n- This discrepancy points towards the potential issue that the `Instant` object is not correctly parsed into the DateTimeParserBucket because the `iDefaultYear` was used instead of the actual year from the chrono object. \n- The parsed `Instant` object then had the incorrect date-time information, which caused the test case to fail.\n\nBug Fix:\nThe bug was fixed by replacing `iDefaultYear` with `chrono.year().get(instantLocal)`. So the appropriate date from `instantLocal` is being parsed into the `DateTimeParserBucket` object instead of the `iDefaultYear`. The rest of the code remains unchanged.\n\nIn terms of generating artificial bugs for this scenario, it is recommended to:\n\n1. Use incorrect parameters in function calls: For example, use an incorrect timezone, date format, or language that the system may not recognize while parsing.\n2. Exclude crucial check points: For example, remove the null check for `instant`, so the next line of code throws a `NullPointerException`.\n3. Unsync the actual and expected test case results: For example, simulate an incorrect expected result in the test cases as in the above error scenario. \n"
}