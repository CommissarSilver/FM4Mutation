{
    "bug_id": 114,
    "bug_type": "SL SH SF",
    "buggy_lines": "        } else {",
    "code": "    private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n      Node nameNode = n.getFirstChild();\n      Node parent = n.getParent();\n      NameInformation ns = createNameInformation(t, nameNode);\n      if (ns != null) {\n        if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n          // Patch for assignments that appear in the init,\n          // condition or iteration part of a FOR loop.  Without\n          // this change, all 3 of those parts try to claim the for\n          // loop as their dependency scope.  The last assignment in\n          // those three fields wins, which can result in incorrect\n          // reference edges between referenced and assigned variables.\n          //\n          // TODO(user) revisit the dependency scope calculation\n          // logic.\n          if (parent.getFirstChild().getNext() != n) {\n            recordDepScope(recordNode, ns);\n          } else {\n            recordDepScope(nameNode, ns);\n          }\n        } else {\n          // The rhs of the assignment is the caller, so it's used by the\n          // context. Don't associate it w/ the lhs.\n          // FYI: this fixes only the specific case where the assignment is the\n          // caller expression, but it could be nested deeper in the caller and\n          // we would still get a bug.\n          // See testAssignWithCall2 for an example of this.\n          recordDepScope(recordNode, ns);\n        }\n      }\n    }",
    "fixed_code": "    private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n      Node nameNode = n.getFirstChild();\n      Node parent = n.getParent();\n      NameInformation ns = createNameInformation(t, nameNode);\n      if (ns != null) {\n        if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n          // Patch for assignments that appear in the init,\n          // condition or iteration part of a FOR loop.  Without\n          // this change, all 3 of those parts try to claim the for\n          // loop as their dependency scope.  The last assignment in\n          // those three fields wins, which can result in incorrect\n          // reference edges between referenced and assigned variables.\n          //\n          // TODO(user) revisit the dependency scope calculation\n          // logic.\n          if (parent.getFirstChild().getNext() != n) {\n            recordDepScope(recordNode, ns);\n          } else {\n            recordDepScope(nameNode, ns);\n          }\n        } else if (!(parent.isCall() && parent.getFirstChild() == n)) {\n          // The rhs of the assignment is the caller, so it's used by the\n          // context. Don't associate it w/ the lhs.\n          // FYI: this fixes only the specific case where the assignment is the\n          // caller expression, but it could be nested deeper in the caller and\n          // we would still get a bug.\n          // See testAssignWithCall2 for an example of this.\n          recordDepScope(recordNode, ns);\n        }\n      }\n    }",
    "fixed_lines": "        } else if (!(parent.isCall() && parent.getFirstChild() == n)) {",
    "masked_code": "    private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n      Node nameNode = n.getFirstChild();\n      Node parent = n.getParent();\n      NameInformation ns = createNameInformation(t, nameNode);\n      if (ns != null) {\n        if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n          // Patch for assignments that appear in the init,\n          // condition or iteration part of a FOR loop.  Without\n          // this change, all 3 of those parts try to claim the for\n          // loop as their dependency scope.  The last assignment in\n          // those three fields wins, which can result in incorrect\n          // reference edges between referenced and assigned variables.\n          //\n          // TODO(user) revisit the dependency scope calculation\n          // logic.\n          if (parent.getFirstChild().getNext() != n) {\n            recordDepScope(recordNode, ns);\n          } else {\n            recordDepScope(nameNode, ns);\n          }\n>>> [ INFILL ] <<<\n          // The rhs of the assignment is the caller, so it's used by the\n          // context. Don't associate it w/ the lhs.\n          // FYI: this fixes only the specific case where the assignment is the\n          // caller expression, but it could be nested deeper in the caller and\n          // we would still get a bug.\n          // See testAssignWithCall2 for an example of this.\n          recordDepScope(recordNode, ns);\n        }\n      }\n    }",
    "project": "Closure",
    "test_error_message": "junit.framework.AssertionFailedError:",
    "test_framework": "defects4j",
    "test_line": "    test(\"var fun, x; (fun = function(){ x; })();\",",
    "test_name": "testAssignWithCall",
    "test_suite": "com.google.javascript.jscomp.NameAnalyzerTest",
    "time_buggy": "2013-10-03 18:21:13 -0700",
    "time_fixed": "2013-10-03 18:21:15 -0700",
    "bug_description": "Bug Description:\n\n1. Bug ID: The bug ID assigned to this bug is 114.\n\n2. Project: The bug is found in the project named 'Closure'.\n\n3. Bug Type: The bug type is denoted as 'SL SH SF', which could be specific codes denoting the type or impact of the bug. This might require project specific knowledge to interpret.\n\n4. Error Message: The error message provided during the test when the bug was encountered was 'junit.framework.AssertionFailedError:'. This is a general error thrown when a Junit test assertion fails. However, the specific message or conditions for the failure are not provided in this data.\n\n5. Buggy Lines: According to the provided data, the lines of code creating the bug are indicated by the comment: '} else {'. The comment is not an identifiable or executable piece of code, it appears to be indicating that the error arises in the subsequent 'else' block of code.\n\n6. Buggy Code: The provided code is a method named 'recordAssignment' in which the bug is residing. It contains a nested if-else control flow loop which seems to handle certain dependencies and assignments within a NodeTraversal. The problematic else block is associated with a comment discussing the assignment's context and how it's not supposed to be associated with the left-hand side (lhs). \n\n7. Fixed Code: The bug is fixed in this version of the code by introducing an else if clause, instead of the else clause in the code. This else if clause checks whether the 'parent' node is a 'call', and that it's first child is 'n'. If these conditions are not satisfied, it will then execute the block of codes involving 'recordDepScope'. \n\nIn conclusion, the bug arises from an incorrect block of logic in case of handling the context in which an assignment is made. The problematic else statement was executing 'recordDepScope(recordNode, ns)', when the conditions mentioned above weren't met, causing the assertion error. The fix introduces these more specific conditions with an elseif statement, preventing the erroneous execution of code."
}