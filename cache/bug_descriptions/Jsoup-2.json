{
    "bug_id": 2,
    "bug_type": "SL SH SF",
    "buggy_lines": "",
    "code": "    private void parseStartTag() {\n        tq.consume(\"<\");\n        String tagName = tq.consumeWord();\n\n        if (tagName.length() == 0) { // doesn't look like a start tag after all; put < back on stack and handle as text\n            tq.addFirst(\"&lt;\");\n            parseTextNode();\n            return;\n        }\n\n        Attributes attributes = new Attributes();\n        while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) {\n            Attribute attribute = parseAttribute();\n            if (attribute != null)\n                attributes.put(attribute);\n        }\n\n        Tag tag = Tag.valueOf(tagName);\n        Element child = new Element(tag, baseUri, attributes);\n\n        boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>\n        if (tq.matchChomp(\"/>\")) { // close empty element or tag\n            isEmptyElement = true;\n        } else {\n            tq.matchChomp(\">\");\n        }\n        addChildToParent(child, isEmptyElement);\n\n        // pc data only tags (textarea, script): chomp to end tag, add content as text node\n        if (tag.isData()) {\n            String data = tq.chompTo(\"</\" + tagName);\n            tq.chompTo(\">\");\n            \n            Node dataNode;\n            if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)\n                dataNode = TextNode.createFromEncoded(data, baseUri);\n            else\n                dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script)\n            child.appendChild(dataNode);   \n        }\n\n        // <base href>: update the base uri\n        if (child.tagName().equals(\"base\")) {\n            String href = child.absUrl(\"href\");\n            if (href.length() != 0) { // ignore <base target> etc\n                baseUri = href;\n                doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base\n            }\n        }\n    }",
    "fixed_code": "    private void parseStartTag() {\n        tq.consume(\"<\");\n        String tagName = tq.consumeWord();\n\n        if (tagName.length() == 0) { // doesn't look like a start tag after all; put < back on stack and handle as text\n            tq.addFirst(\"&lt;\");\n            parseTextNode();\n            return;\n        }\n\n        Attributes attributes = new Attributes();\n        while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) {\n            Attribute attribute = parseAttribute();\n            if (attribute != null)\n                attributes.put(attribute);\n        }\n\n        Tag tag = Tag.valueOf(tagName);\n        Element child = new Element(tag, baseUri, attributes);\n\n        boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>\n        if (tq.matchChomp(\"/>\")) { // close empty element or tag\n            isEmptyElement = true;\n        } else {\n            tq.matchChomp(\">\");\n        }\n        addChildToParent(child, isEmptyElement);\n\n        // pc data only tags (textarea, script): chomp to end tag, add content as text node\n        if (tag.isData()) {\n            String data = tq.chompTo(\"</\" + tagName);\n            tq.chompTo(\">\");\n            popStackToClose(tag);\n            \n            Node dataNode;\n            if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)\n                dataNode = TextNode.createFromEncoded(data, baseUri);\n            else\n                dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script)\n            child.appendChild(dataNode);   \n        }\n\n        // <base href>: update the base uri\n        if (child.tagName().equals(\"base\")) {\n            String href = child.absUrl(\"href\");\n            if (href.length() != 0) { // ignore <base target> etc\n                baseUri = href;\n                doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base\n            }\n        }\n    }",
    "fixed_lines": "            popStackToClose(tag);",
    "masked_code": "    private void parseStartTag() {\n        tq.consume(\"<\");\n        String tagName = tq.consumeWord();\n\n        if (tagName.length() == 0) { // doesn't look like a start tag after all; put < back on stack and handle as text\n            tq.addFirst(\"&lt;\");\n            parseTextNode();\n            return;\n        }\n\n        Attributes attributes = new Attributes();\n        while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) {\n            Attribute attribute = parseAttribute();\n            if (attribute != null)\n                attributes.put(attribute);\n        }\n\n        Tag tag = Tag.valueOf(tagName);\n        Element child = new Element(tag, baseUri, attributes);\n\n        boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>\n        if (tq.matchChomp(\"/>\")) { // close empty element or tag\n            isEmptyElement = true;\n        } else {\n            tq.matchChomp(\">\");\n        }\n        addChildToParent(child, isEmptyElement);\n\n        // pc data only tags (textarea, script): chomp to end tag, add content as text node\n        if (tag.isData()) {\n            String data = tq.chompTo(\"</\" + tagName);\n            tq.chompTo(\">\");\n>>> [ INFILL ] <<<\n            \n            Node dataNode;\n            if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)\n                dataNode = TextNode.createFromEncoded(data, baseUri);\n            else\n                dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script)\n            child.appendChild(dataNode);   \n        }\n\n        // <base href>: update the base uri\n        if (child.tagName().equals(\"base\")) {\n            String href = child.absUrl(\"href\");\n            if (href.length() != 0) { // ignore <base target> etc\n                baseUri = href;\n                doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base\n            }\n        }\n    }",
    "project": "Jsoup",
    "test_error_message": "junit.framework.AssertionFailedError: expected:<...dy>pre <script>inner[</script> aft]</body></html>> but was:<...dy>pre <script>inner[ aft</script>]</body></html>>",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(\"<html><head></head><body>pre <script>inner</script> aft</body></html>\", TextUtil.stripNewlines(doc.html()));",
    "test_name": "handlesTextAfterData",
    "test_suite": "org.jsoup.parser.ParserTest",
    "time_buggy": "2011-07-02 21:11:53 +1000",
    "time_fixed": "2011-07-02 21:11:53 +1000",
    "bug_description": "Bug Description:\n\nBug ID: 2\nProject: Jsoup\nBug Type: Syntax, Logic, Semantic Failure (SL SH SF)\n\nError Message: junit.framework.AssertionFailedError: expected:<...dy>pre <script>inner[</script> aft]</body></html>> but was:<...dy>pre <script>inner[ aft</script>]</body></html>>\n\nDescription:\n\nThe bug occurs in the 'parseStartTag()' method of Jsoup project. This method is primarily used to parse start tags in the Html/js. From the error message, it's clear that the issue revolves around the parsing logic of the Script tag. The expected output indicates that the expected closing of the nest tag (\"<script>\") is not being correctly parsed. Before we refer the fix, it is important to understand the purpose of this method.\n\nThe 'parseStartTag()' method's main task is to read the Html/Js source and correctly identify and parse tags depending on attributes, and based on if the tag is empty or not empty.\n\nOn consuming the \"<\", it reads a tagName. If the tagName length is 0 - indicating no tagName after \"<\" - it will assume it as text and move it off the tag processing stack, else it moves forward to identify and assign attributes. There is an additional step if the tag is of type 'Data' including 'textarea' and 'script', whereupon the method will read until the end tag and assigns the enclosed content as a TextNode or a DataNode respectively. After adding attributes to the tag, it creates child elements accordingly and consumes the \">\" indicating the end of a tag start.\n\nThe problem seems to arise when it finds a data tag - especially Script/Subscript tag. An additional token is being read even after chomping to \">\" which is resulting in a misplacement of closing and opening of nest tags.\n\nFix:\n\nIn the fixed code, a new line of code is introduced after the line 'tq.chompTo(\">\");' i.e 'popStackToClose(tag);'. This line is the main fix to the bug as it ensures any opening tag that was potentially not closed properly is closed before continuing forward. This ensures the parsed output does not contain any misplaced or unopened nesting tags, which is the issue in this specific bug.\n\nThe rest of the code is left unchanged, as parsing of non-data tags does not seem to be affected.\n\nThis detailed step-by-step bug description is expected to help developers generate artificial Java bugs to further enhance bug detection algorithms and technologies."
}