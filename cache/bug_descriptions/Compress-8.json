{
    "bug_id": 8,
    "bug_type": "SF",
    "buggy_lines": "        boolean stillPadding = true;\n            final byte currentByte = buffer[i];\n            if (currentByte == 0) {\n            if (currentByte == (byte) ' ' || currentByte == '0') {\n                if (stillPadding) {\n                   continue;\n            }\n                if (currentByte == (byte) ' ') {\n                }\n            stillPadding = false;",
    "code": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        boolean stillPadding = true;\n        int     end = offset + length;\n        int     start = offset;\n\n        for (int i = start; i < end; i++){\n            final byte currentByte = buffer[i];\n            if (currentByte == 0) {\n                break;\n            }\n\n        // Skip leading spaces\n            if (currentByte == (byte) ' ' || currentByte == '0') {\n                if (stillPadding) {\n                   continue;\n            }\n                if (currentByte == (byte) ' ') {\n                break;\n                }\n            }\n\n        // Must have trailing NUL or space\n        // May have additional NUL or space\n\n            stillPadding = false;\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }",
    "fixed_code": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        boolean allNUL = true;\n        for (int i = start; i < end; i++){\n            if (buffer[i] != 0){\n                allNUL = false;\n                break;\n            }\n        }\n        if (allNUL) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Must have trailing NUL or space\n        byte trailer;\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        // May have additional NUL or space\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }",
    "fixed_lines": "        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        boolean allNUL = true;\n            if (buffer[i] != 0){\n                allNUL = false;\n        }\n        if (allNUL) {\n            return 0L;\n        }\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n        }\n        byte trailer;\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        }\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];",
    "masked_code": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        for (int i = start; i < end; i++){\n                break;\n            }\n\n        // Skip leading spaces\n                break;\n            }\n\n        // Must have trailing NUL or space\n        // May have additional NUL or space\n\n>>> [ INFILL ] <<<\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }",
    "project": "Compress",
    "test_error_message": "junit.framework.AssertionFailedError: Expected IllegalArgumentException - should be at least 2 bytes long",
    "test_framework": "defects4j",
    "test_line": "            fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");",
    "test_name": "testParseOctalInvalid",
    "test_suite": "org.apache.commons.compress.archivers.tar.TarUtilsTest",
    "time_buggy": "2010-06-01 16:58:22 +0000",
    "time_fixed": "2010-06-02 11:00:25 +0000",
    "bug_description": "Bug ID: 8\n\nTitle: Inappropriate management of buffer length and invalid parsing of leading spaces, NULL, and trailing.\n\nComponent: Compress Project\n\nBug Type: Code/System Failure (SF)\n\nInitial Code Explanation:\n\nThe initial code aims to convert an input array of bytes into a decimal number representation, using the octal system. The array of bytes is expected to be a sequence of ASCII codes starting from '0' to '7', which represents octal digits. Any leading spaces and NULL values are ignored, and the function will keep reading bytes until it encounters a non-numeric byte.\n\nBug Description:\n\nThe code fails to handle two situations correctly:\n\n1. The code does not check if the input buffer has at least two bytes before proceeding with the conversion, which the test cases seem to require. There isn't any validation to assure if the buffer length is less than 2, an IllegalArgumentException should be thrown.\n\n2. The code incorrectly handles leading white spaces and NULL characters and does not enforce the presence of a trailing NUL or space. According to the error message, the code should skip leading spaces and NULL characters, continue parsing until it encounters a non-numeric character, and expects a trailing NUL or space after the numbers, which it does not fulfil. An exception is supposed to be thrown if a non-numeric character or a character that is not a NULL character or space is found in the buffer.\n\nCorrective Actions:\n\nAfter identifying the buggy lines and understanding the requirement, the developer has taken the following steps to correct the code.\n\n1. Initially, the corrected code checks if the length of the input buffer is at least 2. If not, it throws an IllegalArgumentException, thus satisfying the first failed condition of the test case.\n\n2. The developer then checks if all characters in the buffer are NULL. If yes, the function returns 0L immediately, saving computation time.\n\n3. The code now correctly handles leading spaces by incrementing the start index.\n\n4. The corrected code makes sure it has a trailing NUL or space. If not present, it raises an IllegalArgumentException.\n\n5. The new code processes only those characters in the buffer that are within the ASCII range for octal numbers ('0' to '7'). If any other character is encountered, it throws an IllegalArgumentException. The converted number is then returned as a result. \n\nPost Correction:\n\nAfter these corrections, the code should work as expected and prevent future assertion errors related to these issues. The provided solution throws exceptions at appropriate conditions of error and effectively handles edge cases. The code now should pass all failing and previously passing test cases."
}