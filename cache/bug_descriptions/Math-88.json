{
    "bug_id": 88,
    "bug_type": "SF",
    "buggy_lines": "            if (basicRow != null) {\n                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }",
    "code": "    protected RealPointValuePair getSolution() {\n        double[] coefficients = new double[getOriginalNumDecisionVariables()];\n        Integer basicRow =\n            getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n        double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n        for (int i = 0; i < coefficients.length; i++) {\n            basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n                // if multiple variables can take a given value \n                // then we choose the first and set the rest equal to 0\n                coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);\n            if (basicRow != null) {\n                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }\n            }\n        }\n        return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }",
    "fixed_code": "    protected RealPointValuePair getSolution() {\n        double[] coefficients = new double[getOriginalNumDecisionVariables()];\n        Integer basicRow =\n            getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n        double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n        Set<Integer> basicRows = new HashSet<Integer>();\n        for (int i = 0; i < coefficients.length; i++) {\n            basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n            if (basicRows.contains(basicRow)) {\n                // if multiple variables can take a given value \n                // then we choose the first and set the rest equal to 0\n                coefficients[i] = 0;\n            } else {\n                basicRows.add(basicRow);\n                coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);\n            }\n        }\n        return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }",
    "fixed_lines": "        Set<Integer> basicRows = new HashSet<Integer>();\n            if (basicRows.contains(basicRow)) {\n                coefficients[i] = 0;\n            } else {\n                basicRows.add(basicRow);",
    "masked_code": "    protected RealPointValuePair getSolution() {\n        double[] coefficients = new double[getOriginalNumDecisionVariables()];\n        Integer basicRow =\n            getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n        double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n        for (int i = 0; i < coefficients.length; i++) {\n            basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n                // if multiple variables can take a given value \n                // then we choose the first and set the rest equal to 0\n                coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);\n>>> [ INFILL ] <<<\n            }\n        }\n        return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }",
    "project": "Math",
    "test_error_message": "junit.framework.AssertionFailedError: expected:<1.0> but was:<0.0>",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(1.0, solution.getPoint()[2], .0000001);",
    "test_name": "testMath272",
    "test_suite": "org.apache.commons.math.optimization.linear.SimplexSolverTest",
    "time_buggy": "2009-06-02 18:53:23 +0000",
    "time_fixed": "2009-06-02 19:37:30 +0000",
    "bug_description": "Bug ID: 88\nProject: Math\nBug Type: Semantic Fault (SF)\n\nDescription:\n\n1. Module Description: This bug is occurring in the function `getSolution()` in which the coefficients of decision variables are calculated.\n\n2. Error description: The expected result was a result value of `1.0` through a JUnit test, but the received result was `0.0`.\n\n3. Root Cause Analysis: In this code snippet, the decision variable coefficients are being set to `0` if the element at the `j`th index of a specific row (`basicRow`) in `tableau` (presumably a matrix) equals `1`. However, this condition seems to cause erroneous zeros in the coefficient computation. \n\n4. Probable incorrect computation: The current implementation is causing `coefficients[i]` to be `0`, even though it should have other values. According to the comment in the code, if multiple variables can take a given value, then the first is chosen and the rest is set to `0`. However, the current implementation does not correctly reflect this comment - instead, it sets the coefficient to `0` whenever it finds a `1` in the `tableau` for the same `basicRow`.\n\n5. Fix: In the fixed code, a `HashSet` '''basicRows''' is instantiated to keep track of already utilized rows (`basicRow`). Upon each iteration of `i`, if `basicRow` is already present in '''basicRows''', meaning the variable has already taken a given value previously, `coefficients[i]` is set to `0`. Otherwise, it adds `basicRow` to '''basicRows''', and calculates `coefficients[i]` as normal. This setup abides by the stipulated rule from the code comment and fixes the bug.\n\nThis bug teaches developers that semantics are important \u2013 algorithms and conditions must align with the intended functionality and accurately reflect any accompanying comments. It also demonstrates the importance of maintaining a proper tracking method when applying rules across multiple variables, in this case using a HashSet to track which variable has taken which value."
}