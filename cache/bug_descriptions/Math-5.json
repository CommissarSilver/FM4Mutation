{
    "bug_id": 5,
    "bug_type": "SL SH SF",
    "buggy_lines": "            return NaN;",
    "code": "    public Complex reciprocal() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n            return NaN;\n        }\n\n        if (isInfinite) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            double q = real / imaginary;\n            double scale = 1. / (real * q + imaginary);\n            return createComplex(scale * q, -scale);\n        } else {\n            double q = imaginary / real;\n            double scale = 1. / (imaginary * q + real);\n            return createComplex(scale, -scale * q);\n        }\n    }",
    "fixed_code": "    public Complex reciprocal() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n            return INF;\n        }\n\n        if (isInfinite) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            double q = real / imaginary;\n            double scale = 1. / (real * q + imaginary);\n            return createComplex(scale * q, -scale);\n        } else {\n            double q = imaginary / real;\n            double scale = 1. / (imaginary * q + real);\n            return createComplex(scale, -scale * q);\n        }\n    }",
    "fixed_lines": "            return INF;",
    "masked_code": "    public Complex reciprocal() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n>>> [ INFILL ] <<<\n        }\n\n        if (isInfinite) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            double q = real / imaginary;\n            double scale = 1. / (real * q + imaginary);\n            return createComplex(scale * q, -scale);\n        } else {\n            double q = imaginary / real;\n            double scale = 1. / (imaginary * q + real);\n            return createComplex(scale, -scale * q);\n        }\n    }",
    "project": "Math",
    "test_error_message": "junit.framework.AssertionFailedError: expected:<(NaN, NaN)> but was:<(Infinity, Infinity)>",
    "test_framework": "defects4j",
    "test_line": "        Assert.assertEquals(Complex.ZERO.reciprocal(), Complex.INF);",
    "test_name": "testReciprocalZero",
    "test_suite": "org.apache.commons.math3.complex.ComplexTest",
    "time_buggy": "2013-03-22 17:49:27 +0000",
    "time_fixed": "2013-03-22 18:55:58 +0000",
    "bug_description": "Bug Title: Incorrect handling of reciprocal operation with certain Complex numbers in Math Project\n\nBug ID: 5\n\nComponent: Math\n\nDescription:\n\nThis bug exists in the method that handles the reciprocal of a complex number in the Math project. The incorrect handling of certain scenarios leads to a failed test case where the return value was not as expected.\n\nBug Type: SL SH SF\n\nSteps to Reproduce: \n\nThis bug can be reproduced by invoking the reciprocal() method on a complex number where both the real and imaginary components are zero.\n    \nCurrent Behavior:\n\nWhen calling the reciprocal() method on a complex number with both real and imaginary parts as zero, the program wrongly returns NaN (Not a Number).\n\nExpected Behavior:\n\nThe method should return Infinity when a reciprocal operation is applied on a complex number where both the real and the imaginary parts are zero.\n\nError Message:\n\nThe test case failing due to this bug throws the following error message: junit.framework.AssertionFailedError: expected:<NaN, NaN> but was:<Infinity, Infinity>\n\nBuggy Code:\n\nWithin the reciprocal() method, the following line doesn't properly handle the case where both the real and imaginary parts of the complex number are zero.\n\nif (real == 0.0 && imaginary == 0.0) {\n    return NaN;\n}\n\nFixed Code:\n\nThe correct behavior is to return Infinity in these cases. Here is the fixed code:\n\nif (real == 0.0 && imaginary == 0.0) {\n    return INF;\n}\n\nThis changes fixes the problematic behavior and makes the reciprocal() method return the correct result under these circumstances. Further testing needs to be carried out to ensure this change doesn't introduce any regression."
}