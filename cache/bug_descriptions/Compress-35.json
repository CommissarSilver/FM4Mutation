{
    "bug_id": 35,
    "bug_type": "SF",
    "buggy_lines": "                if ('0' <= b && b <= '7' && digits++ < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                } else if (digits > 0) {\n                    digits = 6;\n                }",
    "code": "    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits++ < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                } else if (digits > 0) {\n                    digits = 6;\n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n        return storedSum == unsignedSum || storedSum == signedSum;\n    }",
    "fixed_code": "    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = parseOctal(header, CHKSUM_OFFSET, CHKSUMLEN);\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n        return storedSum == unsignedSum || storedSum == signedSum;\n    }",
    "fixed_lines": "",
    "masked_code": "    public static boolean verifyCheckSum(byte[] header) {\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n>>> [ INFILL ] <<<\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n        return storedSum == unsignedSum || storedSum == signedSum;\n    }",
    "project": "Compress",
    "test_error_message": "org.apache.commons.compress.archivers.ArchiveException: No Archiver found for the stream signature",
    "test_framework": "defects4j",
    "test_line": "        return factory.createArchiveInputStream(",
    "test_name": "testCOMPRESS335",
    "test_suite": "org.apache.commons.compress.DetectArchiverTestCase",
    "time_buggy": "2016-02-05 20:42:31 +0100",
    "time_fixed": "2016-02-05 21:20:19 +0100",
    "bug_description": "Bug Description:\n\nThe detected bug in ID 35 for the Compress project is of Synchronisation Failure (SF) type. In the provided code section, the application is throwing the error message: org.apache.commons.compress.archivers.ArchiveException: No Archiver found for the stream signature. \n\nWhat seems to be happening is a failure in the verifyCheckSum function where the header\u2019s checksum is verified. This function reads the header and checks if the checksum read is equal to the calculated unsigned or signed checksum. A checksum is a data transferred with the data block, and it checks if the data is not corrupted during the transfer. In this case, it fails to do so and therefore the ArchiveException is thrown. \n\nIn the evaluate part of the function, we have the following code:\n\n    if ('0' <= b && b <= '7' && digits++ < 6) {\n        storedSum = storedSum * 8 + b - '0';\n    } else if (digits > 0) {\n        digits = 6;\n    }\n\nWhere 'b' is the header byte being processed. What seems to happen here is that it processes only the digits from '0' to '7', and by 'digits++ < 6', we can infer that it should only count to a maximum of six figures to store into 'storedSum'. In the else part, if the counter already contains more than six counts, it assigns the six counts to the digits. This restriction or count is appearing to be the source for the error message. \n\nThe fixed version replaces the problematic fragment with:\n\n    long storedSum = parseOctal(header, CHKSUM_OFFSET, CHKSUMLEN);\n\nThis therefore simplifies the parsing and eliminates the restriction on the maximum digit count, directly resolving the issue. \n\nTo generate artificial Java bugs for training developers in bug detection or resolution, you could perform the following steps:\n\n1. Create a simulation environment where the developers can input and manipulate the code.\n2. Go through the function and identify areas where data input can be manipulated to create undefined behaviors.\n3. Introduce anomalies. In this case, using digits or headers that would not fit into the 'if ('0' <= b && b <= '7' && digits++ < 6)' condition.\n4. Have the developers detect and resolve these code anomalies and compare their solutions with the fixed code."
}