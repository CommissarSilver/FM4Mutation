{
    "bug_id": 7,
    "bug_type": "SF",
    "buggy_lines": "",
    "code": "    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n            copyCurrentStructure(jp);\n        /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n         *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n         *    to assume one did exist.\n         */\n        return this;\n    }",
    "fixed_code": "    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        if (jp.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) {\n            copyCurrentStructure(jp);\n            return this;\n        }\n        /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n         *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n         *    to assume one did exist.\n         */\n        JsonToken t;\n        writeStartObject();\n        do {\n            copyCurrentStructure(jp);\n        } while ((t = jp.nextToken()) == JsonToken.FIELD_NAME);\n        if (t != JsonToken.END_OBJECT) {\n            throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t);\n        }\n        writeEndObject();\n        return this;\n    }",
    "fixed_lines": "        if (jp.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) {\n            return this;\n        }\n        JsonToken t;\n        writeStartObject();\n        do {\n            copyCurrentStructure(jp);\n        } while ((t = jp.nextToken()) == JsonToken.FIELD_NAME);\n        if (t != JsonToken.END_OBJECT) {\n            throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t);\n        }\n        writeEndObject();",
    "masked_code": "    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n            copyCurrentStructure(jp);\n        /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n         *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n         *    to assume one did exist.\n         */\n>>> [ INFILL ] <<<\n        return this;\n    }",
    "project": "JacksonDatabind",
    "test_error_message": "junit.framework.AssertionFailedError: Expected token START_OBJECT, current token FIELD_NAME",
    "test_framework": "defects4j",
    "test_line": "        assertToken(JsonToken.START_OBJECT, jp.nextToken());",
    "test_name": "testDelegateWithTokenBuffer",
    "test_suite": "com.fasterxml.jackson.databind.creators.TestCreatorsDelegating",
    "time_buggy": "2014-10-21 10:38:04 -0700",
    "time_fixed": "2014-10-28 20:32:47 -0700",
    "bug_description": "Bug Description:\n\nStep 1: Launch the software application JacksonDatabind. This bug is present in the \"deserialize\" method of this program. \n\nStep 2: Use the \"deserialize\" method by passing two arguments, `JsonParser jp` and `DeserializationContext ctxt`.\n\nStep 3: During normal execution, the `deserialize` function uses the `copyCurrentStructure(jp)` method to process the passed `JsonParser jp`.\n\nStep 4: This is where the serialization failure (SF) occurs. The program is expecting to start with a START_OBJECT token, but instead, it finds a FIELD_NAME token.\n\nStep 5: The test error message \"junit.framework.AssertionFailedError: Expected token START_OBJECT, current token FIELD_NAME\" signifies that an assertion has failed within the JUnit Framework. This message points out that the program is expecting a START_OBJECT token but instead finds a FIELD_NAME token.\n\nStep 6: This bug results in the failure of normal functioning within the `deserialize` method, resulting in the associated disruptions.\n\nStep 7: The fixed code adds a check for `jp.getCurrentTokenId()` not equaling `JsonToken.FIELD_NAME.id()`. This ensures that the `copyCurrentStructure(jp)` is only executed when the current token isn't FIELD_NAME. \n\nStep 8: If FIELD_NAME is indeed the current token, the code proceeds to write a START_OBJECT and enters a loop to continue copying structures from the `JsonParser jp` until it encounters a different token.\n\nStep 9: It also checks for the END_OBJECT token to make sure the JSON input stream is properly closed. If it doesn't find this, it throws a `mappingException` specifying the problem.\n\nIn summary, the bug occurs in the `deserialize` function due to the lack of protection for the case where the token is FIELD_NAME instead of START_OBJECT. The fixed code adds this protection by imposing a comprehensive check before copying structure from `JsonParser jp`, and ensuring the proper closing of the JSON input stream."
}