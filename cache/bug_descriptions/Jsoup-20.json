{
    "bug_id": 20,
    "bug_type": "SH SF",
    "buggy_lines": "",
    "code": "    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        if (charsetName == null) { // determine from meta. safe parse as UTF-8\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) { // if not found, will keep utf-8 as best attempt\n                String foundCharset = meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                    charsetName = foundCharset;\n                    byteData.rewind();\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null;\n                }\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        if (doc == null) {\n            // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n            // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n            // into head mode\n\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n    }",
    "fixed_code": "    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        if (charsetName == null) { // determine from meta. safe parse as UTF-8\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) { // if not found, will keep utf-8 as best attempt\n                String foundCharset = meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                    charsetName = foundCharset;\n                    byteData.rewind();\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null;\n                }\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        if (doc == null) {\n            // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n            // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n            // into head mode\n            if (docData.charAt(0) == 65279)\n                docData = docData.substring(1);\n\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n    }",
    "fixed_lines": "            if (docData.charAt(0) == 65279)\n                docData = docData.substring(1);",
    "masked_code": "    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        if (charsetName == null) { // determine from meta. safe parse as UTF-8\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) { // if not found, will keep utf-8 as best attempt\n                String foundCharset = meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                    charsetName = foundCharset;\n                    byteData.rewind();\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null;\n                }\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        if (doc == null) {\n            // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n            // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n            // into head mode\n>>> [ INFILL ] <<<\n\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n    }",
    "project": "Jsoup",
    "test_error_message": "junit.framework.AssertionFailedError: expected:<[One]> but was:<[]>",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(\"One\", doc.head().text());",
    "test_name": "discardsSpuriousByteOrderMark",
    "test_suite": "org.jsoup.helper.DataUtilTest",
    "time_buggy": "2012-03-24 22:26:28 -0700",
    "time_fixed": "2012-03-25 21:57:36 -0700",
    "bug_description": "Bug Description:\n\nBug ID: 20\nProject: Jsoup\nBug Type: SH SF\n\nShort Summary: \n\nThe function \"parseByteData\" within Jsoup project generates AssertionFailedError when failing to handle certain Byte-Order Mark (BOM) at the start of the text during parsing. \n\nDescription:\n\nDuring parsing the byte data into a document in the function \"parseByteData\", the code fails to handle a case where there might be a spurious byte-order-mark (BOM) at the start of text. If after decoding, there is a BOM present, the parser erroneously goes straight into head mode.\n\nThis issue leads to the error of failed assertion wherein the expected value populated in the document's list doesn't match the actual outcome. The code expects <[One]> but results in <[]>.\n\nBuggy Steps:\n\n1. Invoking the function parseByteData with byteData, charsetName, baseUri, and parser as arguments.\n2. The function attempts to decode the byteData according to the charsetName provided.\n3. If the charsetName is not specified, the function tries to find it from the meta attribute in the HTML.\n4. Once the byteData is decoded into a string, the result might have a spurious byte-order-mark (BOM) in the start.\n5. This presence of BOM isn't handled correctly in the buggy code and leads to an incorrect parsing process.\n6. The document created due to this faulty parsing process generates different output than expected and causes the assertion error during the test.\n\nResolution:\n\nThe author fixed the code by adding a check for the character value of the first character of the decoded string, representing the BOM. If present, the author removes this character from the string before feeding it into the parser for document creation. \n\nThis solution ensures the parser correctly parses the input from the beginning, leading to the expected document generation and the test passing without any AssertionFailedError."
}