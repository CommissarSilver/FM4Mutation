{
    "bug_id": 125,
    "bug_type": "SL SH SF",
    "buggy_lines": "      if (fnType != null) {",
    "code": "  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n      FunctionType fnType = type.toMaybeFunctionType();\n      if (fnType != null) {\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        ensureTyped(t, n);\n      }\n    } else {\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }",
    "fixed_code": "  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n      FunctionType fnType = type.toMaybeFunctionType();\n      if (fnType != null && fnType.hasInstanceType()) {\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        ensureTyped(t, n);\n      }\n    } else {\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }",
    "fixed_lines": "      if (fnType != null && fnType.hasInstanceType()) {",
    "masked_code": "  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n      FunctionType fnType = type.toMaybeFunctionType();\n>>> [ INFILL ] <<<\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        ensureTyped(t, n);\n      }\n    } else {\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }",
    "project": "Closure",
    "test_error_message": "java.lang.IllegalStateException",
    "test_framework": "defects4j",
    "test_line": "    Scope s = makeTypeCheck().processForTesting(externsNode, n);",
    "test_name": "testIssue1002",
    "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
    "time_buggy": "2013-05-23 18:49:47 -0700",
    "time_fixed": "2013-05-23 18:49:49 -0700",
    "bug_description": "Bug Description:\n\nBug ID: 125\nProject: Closure\nBug Type: SL (Single Line bug), SH (Single Hunk bug), SF (Same File bug)\n\nError: java.lang.IllegalStateException\n\nIn the Closure project, there is an instance of an IllegalStateException in the function \"visitNew\". The error typically refers to a case where that method, in this case \"visitNew\", has been invoked at an inappropriate time, indicating that an application is not in an appropriate state for the requested operation. \n\nThe bug is localized in the conditional statement within the function visitNew. More precisely, the problematic line is:\n\n    if (fnType != null)\n\nThis line checks whether fnType has been initialized but does not ensure that it is a correct and valid instance type. The problem here is that even if fnType is not null, fnType may not have an instance type yet, implied by using the function getInstanceType() later on, which eventually leads to the java.lang.IllegalStateException.\n\nThe solution is to add an additional condition fnType.hasInstanceType(), in the if statement to account for the functionality in the possibility where fnType might be initialized but doesn't have an instance type. The amended if statement will look like:\n\n    if (fnType != null && fnType.hasInstanceType())\n\nThis added condition ensures that fnType is not only not null, but it verifies if it indeed has a valid instance type before proceeding to use its instance type in the next steps (i.e., visitParameterList(t, n, fnType); and ensureTyped(t, n, fnType.getInstanceType()).\n\nThis is a SL (Single Line bug), SH (Single Hunk bug), SF (Same File bug) since the bug corresponds to a single line of problematic code, exists within a single code hunk, and the fix is also in the same file.\n\nDevelopers generating artificial bugs for Java projects can use this example when needing to create bugs pertaining to checking the appropriateness of method invocation or checking the state of objects before invoking methods on them."
}