{
    "bug_id": 101,
    "bug_type": "SH SF",
    "buggy_lines": "        if (",
    "code": "    public Complex parse(String source, ParsePosition pos) {\n        int initialIndex = pos.getIndex();\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse real\n        Number re = parseNumber(source, getRealFormat(), pos);\n        if (re == null) {\n            // invalid real number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse sign\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        int sign = 0;\n        switch (c) {\n        case 0 :\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-' :\n            sign = -1;\n            break;\n        case '+' :\n            sign = 1;\n            break;\n        default :\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse imaginary\n        Number im = parseNumber(source, getRealFormat(), pos);\n        if (im == null) {\n            // invalid imaginary number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse imaginary character\n        int n = getImaginaryCharacter().length();\n        startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n        if (\n            source.substring(startIndex, endIndex).compareTo(\n            getImaginaryCharacter()) != 0) {\n            // set index back to initial, error index should be the start index\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        pos.setIndex(endIndex);\n\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }",
    "fixed_code": "    public Complex parse(String source, ParsePosition pos) {\n        int initialIndex = pos.getIndex();\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse real\n        Number re = parseNumber(source, getRealFormat(), pos);\n        if (re == null) {\n            // invalid real number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse sign\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        int sign = 0;\n        switch (c) {\n        case 0 :\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-' :\n            sign = -1;\n            break;\n        case '+' :\n            sign = 1;\n            break;\n        default :\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse imaginary\n        Number im = parseNumber(source, getRealFormat(), pos);\n        if (im == null) {\n            // invalid imaginary number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse imaginary character\n        int n = getImaginaryCharacter().length();\n        startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n        if ((startIndex >= source.length()) ||\n            (endIndex > source.length()) ||\n            source.substring(startIndex, endIndex).compareTo(\n            getImaginaryCharacter()) != 0) {\n            // set index back to initial, error index should be the start index\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        pos.setIndex(endIndex);\n\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }",
    "fixed_lines": "        if ((startIndex >= source.length()) ||\n            (endIndex > source.length()) ||",
    "masked_code": "    public Complex parse(String source, ParsePosition pos) {\n        int initialIndex = pos.getIndex();\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse real\n        Number re = parseNumber(source, getRealFormat(), pos);\n        if (re == null) {\n            // invalid real number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse sign\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        int sign = 0;\n        switch (c) {\n        case 0 :\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-' :\n            sign = -1;\n            break;\n        case '+' :\n            sign = 1;\n            break;\n        default :\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse imaginary\n        Number im = parseNumber(source, getRealFormat(), pos);\n        if (im == null) {\n            // invalid imaginary number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse imaginary character\n        int n = getImaginaryCharacter().length();\n        startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n>>> [ INFILL ] <<<\n            source.substring(startIndex, endIndex).compareTo(\n            getImaginaryCharacter()) != 0) {\n            // set index back to initial, error index should be the start index\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        pos.setIndex(endIndex);\n\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }",
    "project": "Math",
    "test_error_message": "java.lang.StringIndexOutOfBoundsException: String index out of range: 6",
    "test_framework": "defects4j",
    "test_line": "        if (",
    "test_name": "testForgottenImaginaryCharacter",
    "test_suite": "org.apache.commons.math.complex.ComplexFormatTest",
    "time_buggy": "2008-03-14 06:41:17 +0000",
    "time_fixed": "2008-03-23 12:22:59 +0000",
    "bug_description": "Bug ID: 101\nProject: Math\nBug Type: SH SF (Syntax Highlighting / Syntax Formatting)\n\nDescription:\n\nThe bug occurrence is within a 'Math' project involving a complex number system. In its parse function, a 'StringIndexOutOfBoundsException' exception is being thrown, indicating that an attempt was made to access a position in the string beyond its range.\n\nStep-wise details:\n\n1. This Math project has a method 'parse' that seems to be designed to parse a complex number from a string.\n\n2. Initially, the method reads the index position of the ParsePosition object, discard any whitespace in the source string, and then tries to parse a real number.\n\n3. If the real number is null, the function sets the ParsePosition index back to the initial index and returns null.\n\n4. Next, it reads a character and interprets it as a sign (positive or negative). If the character isn\u2019t a sign, it sets the index back to the initial position it was, set the ParsePosition error index to the start index, and returns null.\n\n5. It then discards any whitespace and tries to parse an imaginary number. Similar to the real number, if the imaginary number is null, it sets the index back to the initial index and returns null.\n\n6. To extract the imaginary character, it calculates the length of the imaginary character and adds it to the start index to form an end index. \n\n7. At this stage, the bug occurs. The program doesn't confirm whether these indices are valid for the source string. If the source string is shorter than expected, the specified range (startIndex, endIndex) may go beyond the length of the source string. A substring method call on the source string in this scenario will throw a StringIndexOutOfBoundsException.\n\n8. The fixed code adds checks to ensure that startIndex isn't greater than the source length and endIndex doesn't exceed the source length. If these conditions are not met, the function sets the index and error index and returns null as before.\n\n9. After validating the checks, a new Complex number is returned with the real and imaginary numbers parsed. If the sign was '-', it multiplies the imaginary number by the sign before returning the complex number.\n\nThe bug is essentially stemming from the absence of checks to ensure index positions remain within the bounds of the source string length before performing a substring operation. The fix addressed this by adding necessary conditions to verify these indices are within the bounds of the source string."
}