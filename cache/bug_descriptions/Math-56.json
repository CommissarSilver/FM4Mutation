{
    "bug_id": 56,
    "bug_type": "SH SF",
    "buggy_lines": "        int idx = 1;\n        while (count < index) {\n            count += idx;\n            ++idx;\n        }\n        --idx;\n        indices[last] = idx;",
    "code": "    public int[] getCounts(int index) {\n        if (index < 0 ||\n            index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize);\n        }\n\n        final int[] indices = new int[dimension];\n\n        int count = 0;\n        for (int i = 0; i < last; i++) {\n            int idx = 0;\n            final int offset = uniCounterOffset[i];\n            while (count <= index) {\n                count += offset;\n                ++idx;\n            }\n            --idx;\n            count -= offset;\n            indices[i] = idx;\n        }\n\n        int idx = 1;\n        while (count < index) {\n            count += idx;\n            ++idx;\n        }\n        --idx;\n        indices[last] = idx;\n\n        return indices;\n    }",
    "fixed_code": "    public int[] getCounts(int index) {\n        if (index < 0 ||\n            index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize);\n        }\n\n        final int[] indices = new int[dimension];\n\n        int count = 0;\n        for (int i = 0; i < last; i++) {\n            int idx = 0;\n            final int offset = uniCounterOffset[i];\n            while (count <= index) {\n                count += offset;\n                ++idx;\n            }\n            --idx;\n            count -= offset;\n            indices[i] = idx;\n        }\n\n        indices[last] = index - count;\n\n        return indices;\n    }",
    "fixed_lines": "        indices[last] = index - count;",
    "masked_code": "    public int[] getCounts(int index) {\n        if (index < 0 ||\n            index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize);\n        }\n\n        final int[] indices = new int[dimension];\n\n        int count = 0;\n        for (int i = 0; i < last; i++) {\n            int idx = 0;\n            final int offset = uniCounterOffset[i];\n            while (count <= index) {\n                count += offset;\n                ++idx;\n            }\n            --idx;\n            count -= offset;\n            indices[i] = idx;\n        }\n\n>>> [ INFILL ] <<<\n\n        return indices;\n    }",
    "project": "Math",
    "test_error_message": "junit.framework.AssertionFailedError: Wrong multidimensional index for [3][2] expected:<3> but was:<2>",
    "test_framework": "defects4j",
    "test_line": "                Assert.assertEquals(\"Wrong multidimensional index for [\" + i + \"][\" + dimIndex + \"]\",",
    "test_name": "testIterationConsistency",
    "test_suite": "org.apache.commons.math.util.MultidimensionalCounterTest",
    "time_buggy": "2011-04-01 09:24:53 +0000",
    "time_fixed": "2011-04-01 10:10:18 +0000",
    "bug_description": "Bug Description:\n\nBug ID: 56\nBug in Project: Math\nBug Type: SH SF (Semantic with Simple Fix)\n\nBrief Description: The bug is due to incorrect multidimensional index calculation in the \"getCounts\" function in the Math project.\n\nDetailed Description:\n\nIn the Math project, the function getcounts is used to calculate the multidimensional index. This function fails to perform the correct calculation, resulting in the junit.framework.AssertionFailedError when the test case expects the value <3> for the multidimensional index [3][2], but the output was <2>. It seems to be a semantic bug where the logic written in the code doesn't conform to the expected functionality in the given context.\n\nThe problem lies in the logic for index calculation:\n        int idx = 1;\n        while (count < index) {\n            count += idx;\n            ++idx;\n        }\n        --idx;\n        indices[last] = idx;\nThe loop continues while 'count' is lesser than 'index', incrementing 'idx' on each iteration. After exiting the loop, 'idx' is decremented before being assigned to 'indices[last]'. The problem lies here as it may result in incorrect calculations.\n\nFix:\n\nA simple fix to this problem is doing a subtraction of 'count' from 'index' and assigning it to 'indices[last]' directly:\n                indices[last] = index - count;\nInstead of running through an inaccurate loop-reliant method for value assignment, this straightforward subtraction method solves the problem the code initially intended to tackle. This change fixes the bug 56, and thus junit.framework.AssertionFailedError will no longer occur. \n\n    Revised Code:\n\n    public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    final int[] indices = new int[dimension];\n\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n\n    indices[last] = index - count;\n\n    return indices;\n}\n    \nRecommended action is to consider this fix and apply it to this function."
}