{
    "bug_id": 8,
    "bug_type": "SF",
    "buggy_lines": "            if (oldOne.getClass() == newOne.getClass()) {",
    "code": "    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true;\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n        // already had an explicitly marked one?\n        if (oldOne != null) {\n\n            if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is\n                // but skip, if new one not annotated\n                if (!explicit) {\n                    return;\n                }\n                // both explicit: verify\n                // otherwise only verify if neither explicitly annotated.\n            }\n\n            // one more thing: ok to override in sub-class\n            if (oldOne.getClass() == newOne.getClass()) {\n                // [databind#667]: avoid one particular class of bogus problems\n\n                    throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                            +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                // otherwise, which one to choose?\n                    // new type more generic, use old\n                // new type more specific, use it\n            }\n        }\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }",
    "fixed_code": "    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true;\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n        // already had an explicitly marked one?\n        if (oldOne != null) {\n            boolean verify;\n\n            if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is\n                // but skip, if new one not annotated\n                if (!explicit) {\n                    return;\n                }\n                // both explicit: verify\n                verify = true;\n            } else {\n                // otherwise only verify if neither explicitly annotated.\n                verify = !explicit;\n            }\n\n            // one more thing: ok to override in sub-class\n            if (verify && (oldOne.getClass() == newOne.getClass())) {\n                // [databind#667]: avoid one particular class of bogus problems\n                Class<?> oldType = oldOne.getRawParameterType(0);\n                Class<?> newType = newOne.getRawParameterType(0);\n\n                if (oldType == newType) {\n                    throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                            +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                }\n                // otherwise, which one to choose?\n                if (newType.isAssignableFrom(oldType)) {\n                    // new type more generic, use old\n                    return;\n                }\n                // new type more specific, use it\n            }\n        }\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }",
    "fixed_lines": "                verify = true;\n            } else {\n                verify = !explicit;\n            if (verify && (oldOne.getClass() == newOne.getClass())) {\n                Class<?> oldType = oldOne.getRawParameterType(0);\n                Class<?> newType = newOne.getRawParameterType(0);\n                if (oldType == newType) {\n                }\n                if (newType.isAssignableFrom(oldType)) {\n                    return;\n                }",
    "masked_code": "    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true;\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n        // already had an explicitly marked one?\n        if (oldOne != null) {\n\n            if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is\n                // but skip, if new one not annotated\n                if (!explicit) {\n                    return;\n                }\n                // both explicit: verify\n                // otherwise only verify if neither explicitly annotated.\n            }\n\n            // one more thing: ok to override in sub-class\n                // [databind#667]: avoid one particular class of bogus problems\n\n                    throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                            +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                // otherwise, which one to choose?\n                    // new type more generic, use old\n>>> [ INFILL ] <<<\n                // new type more specific, use it\n            }\n        }\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }",
    "project": "JacksonDatabind",
    "test_error_message": "com.fasterxml.jackson.databind.JsonMappingException: Conflicting String creators: already had explicitly marked [constructor for java.lang.StringBuilder, annotations: [null]], encountered [constructor for java.lang.StringBuilder, annotations: [null]]",
    "test_framework": "defects4j",
    "test_line": "",
    "test_name": "testStringBuilder",
    "test_suite": "com.fasterxml.jackson.databind.deser.TestJdkTypes",
    "time_buggy": "2015-01-01 17:44:10 -0800",
    "time_fixed": "2015-01-02 15:38:56 -0800",
    "bug_description": "Bug ID: 8\nProject: JacksonDatabind\nBug Type: SF (State Failure)\n\nDescription:\n\nThis bug corresponds to an IllegalArgumentException that was thrown when there are conflicting String creators already explicitly marked. The error occurs when it is trying to map a JSON object to a Java object using the Jackson Databind library but the library encounters two constructors for StringBuilder with similar annotations. This results in JsonMappingException indicating conflicting String creators which cause State Failure in the application's execution. \n\nThe erroneous code lies in the \"verifyNonDup()\" method. The if condition \"if (oldOne.getClass() == newOne.getClass())\" raises an exception saying there are conflicting creators and the code is unable to decide which one to use. This decision seems to be based on whether the old and new creators are derived from the same class or not. \n\nDetailed Steps: \n\n1. The error occurs within the verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit) method, which appears to be a utility for checking non-duplicated creators.\n2. The oldOne and newOne objects are instances of AnnotatedWithParams, and their classes are being compared in the if condition \"if (oldOne.getClass() == newOne.getClass())\".\n3. When the oldOne and newOne are of the same class, an IllegalArgumentException is thrown with the message indicating conflicting creators, i.e., two constructors for the same class have been marked explicitly.\n\nSolution:\n\nThe fix was to revisit the if condition that is throwing the exception. Instead of comparing whether the objects are generally of the same class, it now explicitly checks whether they have the same raw parameter type. It then checks if the types are assignable from each other and decides which object to use based on which one is more specific or generic. It only throws the IllegalArgumentException now if both types are identical, indicating a genuine conflict. \n\nThis solution ensures that the IllegalArgumentException is thrown only when there is a genuine conflict, reducing unnecessary exceptions that might have been thrown because of the incorrect comparison in the if condition."
}