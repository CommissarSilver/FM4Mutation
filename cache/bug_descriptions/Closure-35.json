{
    "bug_id": 35,
    "bug_type": "SH SF",
    "buggy_lines": "    if (constraintObj != null && constraintObj.isRecordType()) {\n      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n      if (objType != null) {\n        for (String prop : constraintObj.getOwnPropertyNames()) {\n          JSType propType = constraintObj.getPropertyType(prop);\n          if (!objType.isPropertyTypeDeclared(prop)) {\n            JSType typeToInfer = propType;\n            if (!objType.hasProperty(prop)) {\n              typeToInfer =\n                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n            }\n            objType.defineInferredProperty(prop, typeToInfer, null);\n          }\n        }\n      }",
    "code": "      JSType type, JSType constraint) {\n    if (type == null || constraint == null) {\n      return;\n    }\n\n    ObjectType constraintObj =\n        ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n    if (constraintObj != null && constraintObj.isRecordType()) {\n      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n      if (objType != null) {\n        for (String prop : constraintObj.getOwnPropertyNames()) {\n          JSType propType = constraintObj.getPropertyType(prop);\n          if (!objType.isPropertyTypeDeclared(prop)) {\n            JSType typeToInfer = propType;\n            if (!objType.hasProperty(prop)) {\n              typeToInfer =\n                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n            }\n            objType.defineInferredProperty(prop, typeToInfer, null);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * If we access a property of a symbol, then that symbol is not\n   * null or undefined.\n   */\n  private FlowScope dereferencePointer(Node n, FlowScope scope) {\n    if (n.isQualifiedName()) {\n      JSType type = getJSType(n);\n      JSType narrowed = type.restrictByNotNullOrUndefined();\n      if (type != narrowed) {\n        scope = narrowScope(scope, n, narrowed);\n      }",
    "fixed_code": "      JSType type, JSType constraint) {\n    if (type == null || constraint == null) {\n      return;\n    }\n\n    ObjectType constraintObj =\n        ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n    if (constraintObj != null) {\n      type.matchConstraint(constraintObj);\n    }\n  }\n\n  /**\n   * If we access a property of a symbol, then that symbol is not\n   * null or undefined.\n   */\n  private FlowScope dereferencePointer(Node n, FlowScope scope) {\n    if (n.isQualifiedName()) {\n      JSType type = getJSType(n);\n      JSType narrowed = type.restrictByNotNullOrUndefined();\n      if (type != narrowed) {\n        scope = narrowScope(scope, n, narrowed);\n      }",
    "fixed_lines": "    if (constraintObj != null) {\n      type.matchConstraint(constraintObj);",
    "masked_code": "      JSType type, JSType constraint) {\n    if (type == null || constraint == null) {\n      return;\n    }\n\n    ObjectType constraintObj =\n        ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n>>> [ INFILL ] <<<\n    }\n  }\n\n  /**\n   * If we access a property of a symbol, then that symbol is not\n   * null or undefined.\n   */\n  private FlowScope dereferencePointer(Node n, FlowScope scope) {\n    if (n.isQualifiedName()) {\n      JSType type = getJSType(n);\n      JSType narrowed = type.restrictByNotNullOrUndefined();\n      if (type != narrowed) {\n        scope = narrowScope(scope, n, narrowed);\n      }",
    "project": "Closure",
    "test_error_message": "junit.framework.AssertionFailedError: unexpected warnings(s):",
    "test_framework": "defects4j",
    "test_line": "      fail(\"unexpected warnings(s):\\n\" + Joiner.on(\"\\n\").join(warnings));",
    "test_name": "testIssue669",
    "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
    "time_buggy": "2012-02-29 15:38:48 +0000",
    "time_fixed": "2012-03-01 16:46:24 +0000",
    "bug_description": "Bug ID: 35\nProject: Closure\nBug Type: SH SF (Static Hostile Semantic Faulty)\n\nBug Description:\n\nThe bug was involved in the method\n```\nJSType type, JSType constraint) {\n    if (type == null || constraint == null) {\n      return;\n    }\n\n    ObjectType constraintObj =\n        ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n    if (constraintObj != null && constraintObj.isRecordType()) {\n...\n```\nThe issue came up when trying to decide if an object type was a record type and then trying to operate on this assumption. However, the problem was hidden and brought up by the test error message \"junit.framework.AssertionFailedError: unexpected warnings(s),\" indicating that there might be some uncaught exception happened or inappropriate operation stating that some warnings were not expected.\n\nThe problematic code was:\n```java\nif (constraintObj != null && constraintObj.isRecordType()) {\n      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n      if (objType != null) {\n        for (String prop : constraintObj.getOwnPropertyNames()) {\n          JSType propType = constraintObj.getPropertyType(prop);\n          if (!objType.isPropertyTypeDeclared(prop)) {\n            JSType typeToInfer = propType;\n            if (!objType.hasProperty(prop)) {\n              typeToInfer =\n                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n            }\n            objType.defineInferredProperty(prop, typeToInfer, null);\n          }\n        }\n      }\n```\n\nIn this part of the original code, it was checking if the constraint Object is not null and if it's a record type. If both conditions were true, it would try to cast the type to an object type and restrict it by not null or undefined.\n\nIn this long condition, several properties of the objects were checked. If one certain property type was not declared or the object didn't have this property, there was an attempt to get a VOID_TYPE native type and to perform an operation to get the least supertype of the property type. The problem is likely related to this tricky operation and possibly to the VOID_TYPE.\n\nResolution: \n\nThe fixed part of the code is the following:\n```java\nJSType type, JSType constraint) {\n    if (type == null || constraint == null) {\n      return;\n    }\n\n    ObjectType constraintObj =\n        ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n    if (constraintObj != null) {\n      type.matchConstraint(constraintObj);\n    }\n  }\n```\n\nIn the revised code, the condition for the constraint object type being a record type is removed. Instead of casting to restrict by not null or undefined and checking several properties, the code has just one operation with the method matchConstraint of the type with the constraint obj as an argument. \n\nThe provided bug fix simplifies the code and avoided the error/warning message triggered by the faulty original logic. Looks like the matchConstraint() method is introduced to perform such a job in a more streamlined way."
}