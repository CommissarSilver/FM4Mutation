{
    "bug_id": 145,
    "bug_type": "SF",
    "buggy_lines": "",
    "code": "  private boolean isOneExactlyFunctionOrDo(Node n) {\n        // For labels with block children, we need to ensure that a\n        // labeled FUNCTION or DO isn't generated when extraneous BLOCKs \n        // are skipped. \n          // Either a empty statement or an block with more than one child,\n          // way it isn't a FUNCTION or DO.\n      return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n  }",
    "fixed_code": "  private boolean isOneExactlyFunctionOrDo(Node n) {\n    if (n.getType() == Token.LABEL) {\n      Node labeledStatement = n.getLastChild();\n      if (labeledStatement.getType() != Token.BLOCK) {\n        return isOneExactlyFunctionOrDo(labeledStatement);\n      } else {\n        // For labels with block children, we need to ensure that a\n        // labeled FUNCTION or DO isn't generated when extraneous BLOCKs \n        // are skipped. \n        if (getNonEmptyChildCount(n, 2) == 1) { \n          return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n));\n        } else {\n          // Either a empty statement or an block with more than one child,\n          // way it isn't a FUNCTION or DO.\n          return false;\n        }\n      }\n    } else {\n      return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n    }\n  }",
    "fixed_lines": "    if (n.getType() == Token.LABEL) {\n      Node labeledStatement = n.getLastChild();\n      if (labeledStatement.getType() != Token.BLOCK) {\n        return isOneExactlyFunctionOrDo(labeledStatement);\n      } else {\n        if (getNonEmptyChildCount(n, 2) == 1) { \n          return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n));\n        } else {\n          return false;\n        }\n      }\n    } else {\n    }",
    "masked_code": "  private boolean isOneExactlyFunctionOrDo(Node n) {\n        // For labels with block children, we need to ensure that a\n        // labeled FUNCTION or DO isn't generated when extraneous BLOCKs \n        // are skipped. \n          // Either a empty statement or an block with more than one child,\n          // way it isn't a FUNCTION or DO.\n      return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n>>> [ INFILL ] <<<\n  }",
    "project": "Closure",
    "test_error_message": "junit.framework.ComparisonFailure: expected:<if(e1)[{A:function goo(){return true}]}> but was:<if(e1)[A:function goo(){return true]}>",
    "test_framework": "defects4j",
    "test_line": "    assertEquals(expected,",
    "test_name": "testFunctionSafariCompatiblity",
    "test_suite": "com.google.javascript.jscomp.CodePrinterTest",
    "time_buggy": "2010-06-25 21:35:29 +0000",
    "time_fixed": "2010-06-25 23:56:52 +0000",
    "bug_description": "Bug ID: 145\nProject: Closure\nBug Type: Syntax Failure (SF)\n\nDetailed Description:\n\nThe bug identified for this scenario pertains to the syntax error in Closure Project. A comparison failure occurs as indicated by the test error message. In this case, the system expected an input format as <if(e1)[{A:function goo(){return true}]>} but it received a different format that is <if(e1)[A:function goo(){return true]>. This difference in formatting led to a syntax failure in the project hence leading to bug generation.\n\nHere are the steps that highlight the bug generation:\n\n1. The bug is in the private boolean function isOneExactlyFunctionOrDo where it checks whether given node n is either a function or do. For the labels with block children, this function has to ensure that function or do is not generated when extraneous blocks are skipped.\n\n2. The issue arises when either an empty statement or a block with more than one child is there. The original function was directly checking if the node was of a function or do and was returning it causing an issue when the required format was different ( there was an additional block {} in the expected format).\n\n3. The updated fixed code is given where more conditions are taken care of. Now, it also checks if the type is of label then it gets the last child from this labelled statement. If this child isn't of type block, then it calls function recursively on this child only.\n\n4. Else, it checks for the labelled functions or do within the block children and if the non empty child count is one, then it passes the first non-empty child in the recursive function. In other cases, it returns false which means it isn't a function or do.\n\nThe bug in this scenario is focused upon the specific method \"isOneExactlyFunctionOrDo()\" in the java code, which previously did not account for scenarios where if there was a label with block children and an extraneous block was skipped due to an empty statement or a block with more than one child. The fixed code includes additional conditions that handle these situations. \n\nThis illustrates the necessity of including appropriate condition checks to make sure that each possible scenario is addressed, thereby preventing the formation of such bugs."
}