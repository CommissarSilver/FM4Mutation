{
    "bug_id": 32,
    "bug_type": "SL SH SF",
    "buggy_lines": "            if ((Boolean) tree.getAttribute()) {",
    "code": "    protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n            if ((Boolean) tree.getAttribute()) {\n                // the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape\n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n\n            if (sum < 0) {\n                // the polygon as a finite outside surrounded by an infinite inside\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n\n        }\n\n    }",
    "fixed_code": "    protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n            if (tree.getCut() == null && (Boolean) tree.getAttribute()) {\n                // the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape\n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n\n            if (sum < 0) {\n                // the polygon as a finite outside surrounded by an infinite inside\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n\n        }\n\n    }",
    "fixed_lines": "            if (tree.getCut() == null && (Boolean) tree.getAttribute()) {",
    "masked_code": "    protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n>>> [ INFILL ] <<<\n                // the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape\n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n\n            if (sum < 0) {\n                // the polygon as a finite outside surrounded by an infinite inside\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n\n        }\n\n    }",
    "project": "Math",
    "test_error_message": "java.lang.ClassCastException: org.apache.commons.math3.geometry.partitioning.BoundaryAttribute cannot be cast to java.lang.Boolean",
    "test_framework": "defects4j",
    "test_line": "        Assert.assertEquals( 8.0, polyhedronsSet.getSize(), 3.0e-6);",
    "test_name": "testIssue780",
    "test_suite": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSetTest",
    "time_buggy": "2012-05-13 15:51:30 +0000",
    "time_fixed": "2012-05-13 15:51:56 +0000",
    "bug_description": "Bug Description:\n\nBug ID: 32\nBug Project: Math\nBug Type: Semantic\n\n1. Overview:\nThe bug occurred in the Math project specifically in a class that computes geometrical properties. The bug type is Semantic (SL SH SF) which implies that the bug resulted from the misuse of a system's logic.\n\n2. Error Description:\nA ClassCastException was raised with the error message \"java.lang.ClassCastException: org.apache.commons.math3.geometry.partitioning.BoundaryAttribute cannot be cast to java.lang.Boolean\". ClassCastException in Java is generally thrown to indicate that the code has attempted to cast an object to a class of which it is not an instance. In the case of this bug, it's attempting to cast an object of type BoundaryAttribute to a Boolean which is inherently not feasible.\n\n3. Buggy Code Description:\nThe erroneous line is found in the conditional check within the if statement: \n```if ((Boolean) tree.getAttribute()) {```\nThis bug is related with how tree.getAttribute() is being forcibly converted into Boolean. From the Test error message, the getAttribute() method doesn't appear to return a Boolean value, causing the ClassCastException.\n\n4. Fix Description:\nThe solution is to modify the condition under the if statement. In the fixed code, an additional condition is added to the if statement: \n```if (tree.getCut() == null && (Boolean) tree.getAttribute())```\nWith this change, the cast to Boolean only occurs if getCut() returns null.\n\nArtificial Bug Generation:\n\nTo create an artificial bug of similar nature, developers could replace some instance casting codes with infeasible classes or unrelated data types in the application. When the application tries to run those codes, it will throw a ClassCastException similar to the one examined here. For instance, if an object of class X is urged to cast to class Y's object where class Y is not a subclass of class X or vice versa, it would fail and produce a ClassCastException."
}