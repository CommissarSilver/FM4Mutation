{
    "bug_id": "beanshell-beanshell-f345606a29bd",
    "bug_type": "SH SF",
    "buggy_lines": "\n                return String.valueOf((Object) lhs)\n                     + String.valueOf((Object) rhs);",
    "code": "    public static Object arbitraryObjectsBinaryOperation(\n        Object lhs, Object rhs, int kind)\n        throws UtilEvalError\n    {\n        if ( kind == EQ )\n            return (lhs == rhs) ? Primitive.TRUE : Primitive.FALSE;\n        if ( kind == NE )\n            return (lhs != rhs) ? Primitive.TRUE : Primitive.FALSE;\n\n        if ( lhs == Primitive.VOID || rhs == Primitive.VOID )\n            throw new UtilEvalError(\n                \"illegal use of undefined variable, class, or\"\n                    + \" 'void' literal\");\n\n        if (kind == SPACESHIP) {\n            int comp = 0; // used to ensure only -1, 0, and 1 is returned.\n            if (lhs instanceof Comparable || rhs instanceof Comparable)\n                comp = Comparator.nullsFirst( // nullsFirst Comparable Comparator\n                    Comparator.<Comparable<Object>>naturalOrder())\n                        .compare((Comparable<Object>)Primitive.unwrap(lhs),\n                            (Comparable<Object>)Primitive.unwrap(rhs));\n            else\n                comp = Comparator.nullsFirst( // nullsFirst toString Comparator\n                    Comparator.comparing(Object::toString))\n                    .compare(Primitive.unwrap(lhs), Primitive.unwrap(rhs));\n            return Primitive.wrap(comp < 0 ? -1 : comp > 0 ? 1 : 0, Integer.TYPE);\n        }\n\n        if ( kind == PLUS ) {\n            // String concatenation operation\n            if ( lhs instanceof String || rhs instanceof String )\n-                return String.valueOf((Object) lhs)\n-                       String.valueOf((Object) rhs);\n            // array concatenation operation\n            if ( lhs.getClass().isArray() && rhs instanceof List )\n                rhs = ((List<?>) rhs).toArray();\n            if ( lhs.getClass().isArray()\n                    && rhs.getClass().isArray() )\n                return BshArray.concat(lhs, rhs);\n            // list concatenation operation\n            if ( lhs instanceof List && rhs.getClass().isArray() )\n                rhs = Types.castObject(rhs, List.class, Types.CAST);\n            if ( lhs instanceof List && rhs instanceof List )\n                return BshArray.concat(\n                        (List<?>) lhs, (List<?>) rhs);\n        }\n        if ( kind == STAR ) {\n            // array repeat operation\n            if ( lhs.getClass().isArray() )\n                return BshArray.repeat(lhs,\n                        (int) Primitive.unwrap(rhs));\n            if ( rhs.getClass().isArray() )\n                return BshArray.repeat(rhs,\n                        (int) Primitive.unwrap(lhs));\n            // List repeat operation\n            if ( lhs instanceof List )\n                return BshArray.repeat((List<Object>) lhs,\n                        (int) Primitive.unwrap(rhs));\n            if ( rhs instanceof List )\n                return BshArray.repeat((List<Object>) rhs,\n                        (int) Primitive.unwrap(lhs));\n        }\n\n        if ( lhs instanceof String || rhs instanceof String )\n            throw new UtilEvalError(\n                \"Use of non + operator with String\" );\n        if ( lhs.getClass().isArray() || rhs.getClass().isArray()\n               || lhs instanceof List || rhs instanceof List)\n            throw new UtilEvalError(\n                \"Use of invalid operator \" + tokenImage[kind]\n                    + \" with array or List type\" );\n        if ( lhs == Primitive.NULL || rhs == Primitive.NULL )\n            throw new UtilEvalError(\n                \"illegal use of null value or 'null' literal\");\n\n        throw new UtilEvalError(\"Operator: \" + tokenImage[kind]\n                    + \" inappropriate for objects\");\n    }",
    "fixed_code": "    public static Object arbitraryObjectsBinaryOperation(\n        Object lhs, Object rhs, int kind)\n        throws UtilEvalError\n    {\n        if ( kind == EQ )\n            return (lhs == rhs) ? Primitive.TRUE : Primitive.FALSE;\n        if ( kind == NE )\n            return (lhs != rhs) ? Primitive.TRUE : Primitive.FALSE;\n\n        if ( lhs == Primitive.VOID || rhs == Primitive.VOID )\n            throw new UtilEvalError(\n                \"illegal use of undefined variable, class, or\"\n                    + \" 'void' literal\");\n\n        if (kind == SPACESHIP) {\n            int comp = 0; // used to ensure only -1, 0, and 1 is returned.\n            if (lhs instanceof Comparable || rhs instanceof Comparable)\n                comp = Comparator.nullsFirst( // nullsFirst Comparable Comparator\n                    Comparator.<Comparable<Object>>naturalOrder())\n                        .compare((Comparable<Object>)Primitive.unwrap(lhs),\n                            (Comparable<Object>)Primitive.unwrap(rhs));\n            else\n                comp = Comparator.nullsFirst( // nullsFirst toString Comparator\n                    Comparator.comparing(Object::toString))\n                    .compare(Primitive.unwrap(lhs), Primitive.unwrap(rhs));\n            return Primitive.wrap(comp < 0 ? -1 : comp > 0 ? 1 : 0, Integer.TYPE);\n        }\n\n        if ( kind == PLUS ) {\n            // String concatenation operation\n            if ( lhs instanceof String || rhs instanceof String )\n+                return BSHLiteral.internStrings\n+                    ? (String.valueOf((Object) lhs) + String.valueOf((Object) rhs)).intern()\n+                    : String.valueOf((Object) lhs) + String.valueOf((Object) rhs);\n            // array concatenation operation\n            if ( lhs.getClass().isArray() && rhs instanceof List )\n                rhs = ((List<?>) rhs).toArray();\n            if ( lhs.getClass().isArray()\n                    && rhs.getClass().isArray() )\n                return BshArray.concat(lhs, rhs);\n            // list concatenation operation\n            if ( lhs instanceof List && rhs.getClass().isArray() )\n                rhs = Types.castObject(rhs, List.class, Types.CAST);\n            if ( lhs instanceof List && rhs instanceof List )\n                return BshArray.concat(\n                        (List<?>) lhs, (List<?>) rhs);\n        }\n        if ( kind == STAR ) {\n            // array repeat operation\n            if ( lhs.getClass().isArray() )\n                return BshArray.repeat(lhs,\n                        (int) Primitive.unwrap(rhs));\n            if ( rhs.getClass().isArray() )\n                return BshArray.repeat(rhs,\n                        (int) Primitive.unwrap(lhs));\n            // List repeat operation\n            if ( lhs instanceof List )\n                return BshArray.repeat((List<Object>) lhs,\n                        (int) Primitive.unwrap(rhs));\n            if ( rhs instanceof List )\n                return BshArray.repeat((List<Object>) rhs,\n                        (int) Primitive.unwrap(lhs));\n        }\n\n        if ( lhs instanceof String || rhs instanceof String )\n            throw new UtilEvalError(\n                \"Use of non + operator with String\" );\n        if ( lhs.getClass().isArray() || rhs.getClass().isArray()\n               || lhs instanceof List || rhs instanceof List)\n            throw new UtilEvalError(\n                \"Use of invalid operator \" + tokenImage[kind]\n                    + \" with array or List type\" );\n        if ( lhs == Primitive.NULL || rhs == Primitive.NULL )\n            throw new UtilEvalError(\n                \"illegal use of null value or 'null' literal\");\n\n        throw new UtilEvalError(\"Operator: \" + tokenImage[kind]\n                    + \" inappropriate for objects\");\n    }",
    "fixed_lines": "\n                return BSHLiteral.internStrings\n                    ? (String.valueOf((Object) lhs) + String.valueOf((Object) rhs)).intern()\n                    : String.valueOf((Object) lhs) + String.valueOf((Object) rhs);",
    "masked_code": "    public static Object arbitraryObjectsBinaryOperation(\n        Object lhs, Object rhs, int kind)\n        throws UtilEvalError\n    {\n        if ( kind == EQ )\n            return (lhs == rhs) ? Primitive.TRUE : Primitive.FALSE;\n        if ( kind == NE )\n            return (lhs != rhs) ? Primitive.TRUE : Primitive.FALSE;\n\n        if ( lhs == Primitive.VOID || rhs == Primitive.VOID )\n            throw new UtilEvalError(\n                \"illegal use of undefined variable, class, or\"\n                    + \" 'void' literal\");\n\n        if (kind == SPACESHIP) {\n            int comp = 0; // used to ensure only -1, 0, and 1 is returned.\n            if (lhs instanceof Comparable || rhs instanceof Comparable)\n                comp = Comparator.nullsFirst( // nullsFirst Comparable Comparator\n                    Comparator.<Comparable<Object>>naturalOrder())\n                        .compare((Comparable<Object>)Primitive.unwrap(lhs),\n                            (Comparable<Object>)Primitive.unwrap(rhs));\n            else\n                comp = Comparator.nullsFirst( // nullsFirst toString Comparator\n                    Comparator.comparing(Object::toString))\n                    .compare(Primitive.unwrap(lhs), Primitive.unwrap(rhs));\n            return Primitive.wrap(comp < 0 ? -1 : comp > 0 ? 1 : 0, Integer.TYPE);\n        }\n\n        if ( kind == PLUS ) {\n            // String concatenation operation\n            if ( lhs instanceof String || rhs instanceof String )\n>>> [ INFILL ] <<<\n            // array concatenation operation\n            if ( lhs.getClass().isArray() && rhs instanceof List )\n                rhs = ((List<?>) rhs).toArray();\n            if ( lhs.getClass().isArray()\n                    && rhs.getClass().isArray() )\n                return BshArray.concat(lhs, rhs);\n            // list concatenation operation\n            if ( lhs instanceof List && rhs.getClass().isArray() )\n                rhs = Types.castObject(rhs, List.class, Types.CAST);\n            if ( lhs instanceof List && rhs instanceof List )\n                return BshArray.concat(\n                        (List<?>) lhs, (List<?>) rhs);\n        }\n        if ( kind == STAR ) {\n            // array repeat operation\n            if ( lhs.getClass().isArray() )\n                return BshArray.repeat(lhs,\n                        (int) Primitive.unwrap(rhs));\n            if ( rhs.getClass().isArray() )\n                return BshArray.repeat(rhs,\n                        (int) Primitive.unwrap(lhs));\n            // List repeat operation\n            if ( lhs instanceof List )\n                return BshArray.repeat((List<Object>) lhs,\n                        (int) Primitive.unwrap(rhs));\n            if ( rhs instanceof List )\n                return BshArray.repeat((List<Object>) rhs,\n                        (int) Primitive.unwrap(lhs));\n        }\n\n        if ( lhs instanceof String || rhs instanceof String )\n            throw new UtilEvalError(\n                \"Use of non + operator with String\" );\n        if ( lhs.getClass().isArray() || rhs.getClass().isArray()\n               || lhs instanceof List || rhs instanceof List)\n            throw new UtilEvalError(\n                \"Use of invalid operator \" + tokenImage[kind]\n                    + \" with array or List type\" );\n        if ( lhs == Primitive.NULL || rhs == Primitive.NULL )\n            throw new UtilEvalError(\n                \"illegal use of null value or 'null' literal\");\n\n        throw new UtilEvalError(\"Operator: \" + tokenImage[kind]\n                    + \" inappropriate for objects\");\n    }",
    "project": "beanshell-beanshell",
    "test_error_message": "junit.framework.AssertionFailedError: \"lkj\"+\"i\" == \"lk\"+\"ji\" is true Expected <TRUE> but was <FALSE> Line: 169 : assertTrue ( '\"lkj\"+\"i\" == \"lk\"+\"ji\" is true' , \"lkj\" + \"i\" == \"lk\" + \"ji\" )  : while evaluating file: strings.bsh",
    "test_framework": "gitbugjava",
    "test_line": "",
    "test_name": "strings.bsh",
    "test_suite": "bsh.BshScriptTestCase",
    "time_buggy": "2023-01-13 18:44:53 +0200",
    "time_fixed": "2023-01-13 20:41:51 +0200"
}