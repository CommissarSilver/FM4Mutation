{
    "bug_id": "jhy-jsoup-1e69577e358c",
    "bug_type": "SF",
    "buggy_lines": "\n                decodePart(u.getPath()),\n                null, null // query and fragment appended later so as not to encode\n            String normUrl = uri.toASCIIString();\n            if (q != null || u.getRef() != null) {\n                StringBuilder sb = StringUtil.borrowBuilder().append(normUrl);\n                if (q != null) {\n                    sb.append('?');\n                    appendToAscii(StringUtil.releaseBuilder(q), true, sb);\n                }\n                if (u.getRef() != null) {\n                    sb.append('#');\n                    appendToAscii(u.getRef(), false, sb);\n                }\n                normUrl = StringUtil.releaseBuilder(sb);\n            u =  new URL(normUrl);",
    "code": "final class UrlBuilder {\n    URL u;\n    @Nullable StringBuilder q;\n\n    UrlBuilder(URL inputUrl) {\n        this.u = inputUrl;\n        if (u.getQuery() != null)\n            q = StringUtil.borrowBuilder().append(u.getQuery());\n    }\n\n    URL build() {\n        try {\n            // use the URI class to encode non-ascii in path\n            URI uri = new URI(\n                u.getProtocol(),\n                u.getUserInfo(),\n                IDN.toASCII(decodePart(u.getHost())), // puny-code\n                u.getPort(),\n-                decodePart(u.getPath()),\n-                null, null // query and fragment appended later so as not to encode\n            );\n\n-            String normUrl = uri.toASCIIString();\n-            if (q != null || u.getRef() != null) {\n-                StringBuilder sb = StringUtil.borrowBuilder().append(normUrl);\n-                if (q != null) {\n-                    sb.append('?');\n-                    appendToAscii(StringUtil.releaseBuilder(q), true, sb);\n-                }\n-                if (u.getRef() != null) {\n-                    sb.append('#');\n-                    appendToAscii(u.getRef(), false, sb);\n-                }\n-                normUrl = StringUtil.releaseBuilder(sb);\n            }\n-            u =  new URL(normUrl);\n            return u;\n        } catch (MalformedURLException | URISyntaxException | UnsupportedEncodingException e) {\n            // we assert here so that any incomplete normalization issues can be caught in devel. but in practise,\n            // the remote end will be able to handle it, so in prod we just pass the original URL.\n            // The UnsupportedEncodingException would never happen as always UTF8\n            assert Validate.assertFail(e.toString());\n            return u;\n        }\n    }\n\n    void appendKeyVal(Connection.KeyVal kv) throws UnsupportedEncodingException {\n        if (q == null)\n            q = StringUtil.borrowBuilder();\n        else\n            q.append('&');\n        q\n            .append(URLEncoder.encode(kv.key(), UTF_8.name()))\n            .append('=')\n            .append(URLEncoder.encode(kv.value(), UTF_8.name()));\n    }\n\n    private static String decodePart(String encoded) {\n        try {\n            return URLDecoder.decode(encoded, UTF_8.name());\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e); // wtf!\n        }\n    }\n\n    private static void appendToAscii(String s, boolean spaceAsPlus, StringBuilder sb) throws UnsupportedEncodingException {\n        // minimal normalization of Unicode -> Ascii, and space normal. Existing escapes are left as-is.\n        for (int i = 0; i < s.length(); i++) {\n            int c = s.codePointAt(i);\n            if (c == ' ') {\n                sb.append(spaceAsPlus ? '+' : \"%20\");\n            } else if (c > 127) { // out of ascii range\n                sb.append(URLEncoder.encode(new String(Character.toChars(c)), UTF_8.name()));\n                // ^^ is a bit heavy-handed - if perf critical, we could optimize\n            } else {\n                sb.append((char) c);\n            }\n        }\n    }\n\n\n}",
    "fixed_code": "final class UrlBuilder {\n    URL u;\n    @Nullable StringBuilder q;\n\n    UrlBuilder(URL inputUrl) {\n        this.u = inputUrl;\n        if (u.getQuery() != null)\n            q = StringUtil.borrowBuilder().append(u.getQuery());\n    }\n\n    URL build() {\n        try {\n            // use the URI class to encode non-ascii in path\n            URI uri = new URI(\n                u.getProtocol(),\n                u.getUserInfo(),\n                IDN.toASCII(decodePart(u.getHost())), // puny-code\n                u.getPort(),\n+                null, null, null // path, query and fragment appended later so as not to encode\n            );\n\n+            StringBuilder normUrl = StringUtil.borrowBuilder().append(uri.toASCIIString());\n+            appendToAscii(u.getPath(), false, normUrl);\n+            if (q != null) {\n+                normUrl.append('?');\n+                appendToAscii(StringUtil.releaseBuilder(q), true, normUrl);\n            }\n+            if (u.getRef() != null) {\n+                normUrl.append('#');\n+                appendToAscii(u.getRef(), false, normUrl);\n+            }\n+            u = new URL(StringUtil.releaseBuilder(normUrl));\n            return u;\n        } catch (MalformedURLException | URISyntaxException | UnsupportedEncodingException e) {\n            // we assert here so that any incomplete normalization issues can be caught in devel. but in practise,\n            // the remote end will be able to handle it, so in prod we just pass the original URL.\n            // The UnsupportedEncodingException would never happen as always UTF8\n            assert Validate.assertFail(e.toString());\n            return u;\n        }\n    }\n\n    void appendKeyVal(Connection.KeyVal kv) throws UnsupportedEncodingException {\n        if (q == null)\n            q = StringUtil.borrowBuilder();\n        else\n            q.append('&');\n        q\n            .append(URLEncoder.encode(kv.key(), UTF_8.name()))\n            .append('=')\n            .append(URLEncoder.encode(kv.value(), UTF_8.name()));\n    }\n\n    private static String decodePart(String encoded) {\n        try {\n            return URLDecoder.decode(encoded, UTF_8.name());\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e); // wtf!\n        }\n    }\n\n    private static void appendToAscii(String s, boolean spaceAsPlus, StringBuilder sb) throws UnsupportedEncodingException {\n        // minimal normalization of Unicode -> Ascii, and space normal. Existing escapes are left as-is.\n        for (int i = 0; i < s.length(); i++) {\n            int c = s.codePointAt(i);\n            if (c == ' ') {\n                sb.append(spaceAsPlus ? '+' : \"%20\");\n            } else if (c > 127) { // out of ascii range\n                sb.append(URLEncoder.encode(new String(Character.toChars(c)), UTF_8.name()));\n                // ^^ is a bit heavy-handed - if perf critical, we could optimize\n            } else {\n                sb.append((char) c);\n            }\n        }\n    }\n\n\n}",
    "fixed_lines": "\n                null, null, null // path, query and fragment appended later so as not to encode\n            StringBuilder normUrl = StringUtil.borrowBuilder().append(uri.toASCIIString());\n            appendToAscii(u.getPath(), false, normUrl);\n            if (q != null) {\n                normUrl.append('?');\n                appendToAscii(StringUtil.releaseBuilder(q), true, normUrl);\n            if (u.getRef() != null) {\n                normUrl.append('#');\n                appendToAscii(u.getRef(), false, normUrl);\n            }\n            u = new URL(StringUtil.releaseBuilder(normUrl));",
    "masked_code": "final class UrlBuilder {\n    URL u;\n    @Nullable StringBuilder q;\n\n    UrlBuilder(URL inputUrl) {\n        this.u = inputUrl;\n        if (u.getQuery() != null)\n            q = StringUtil.borrowBuilder().append(u.getQuery());\n    }\n\n    URL build() {\n        try {\n            // use the URI class to encode non-ascii in path\n            URI uri = new URI(\n                u.getProtocol(),\n                u.getUserInfo(),\n                IDN.toASCII(decodePart(u.getHost())), // puny-code\n                u.getPort(),\n            );\n\n            }\n>>> [ INFILL ] <<<\n            return u;\n        } catch (MalformedURLException | URISyntaxException | UnsupportedEncodingException e) {\n            // we assert here so that any incomplete normalization issues can be caught in devel. but in practise,\n            // the remote end will be able to handle it, so in prod we just pass the original URL.\n            // The UnsupportedEncodingException would never happen as always UTF8\n            assert Validate.assertFail(e.toString());\n            return u;\n        }\n    }\n\n    void appendKeyVal(Connection.KeyVal kv) throws UnsupportedEncodingException {\n        if (q == null)\n            q = StringUtil.borrowBuilder();\n        else\n            q.append('&');\n        q\n            .append(URLEncoder.encode(kv.key(), UTF_8.name()))\n            .append('=')\n            .append(URLEncoder.encode(kv.value(), UTF_8.name()));\n    }\n\n    private static String decodePart(String encoded) {\n        try {\n            return URLDecoder.decode(encoded, UTF_8.name());\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e); // wtf!\n        }\n    }\n\n    private static void appendToAscii(String s, boolean spaceAsPlus, StringBuilder sb) throws UnsupportedEncodingException {\n        // minimal normalization of Unicode -> Ascii, and space normal. Existing escapes are left as-is.\n        for (int i = 0; i < s.length(); i++) {\n            int c = s.codePointAt(i);\n            if (c == ' ') {\n                sb.append(spaceAsPlus ? '+' : \"%20\");\n            } else if (c > 127) { // out of ascii range\n                sb.append(URLEncoder.encode(new String(Character.toChars(c)), UTF_8.name()));\n                // ^^ is a bit heavy-handed - if perf critical, we could optimize\n            } else {\n                sb.append((char) c);\n            }\n        }\n    }\n\n\n}",
    "project": "jhy-jsoup",
    "test_error_message": "org.opentest4j.AssertionFailedError: expected: <https://example.com/%2B32> but was: <https://example.com/+32>",
    "test_framework": "gitbugjava",
    "test_line": "",
    "test_name": "encodedUrlPathIsPreserved",
    "test_suite": "org.jsoup.helper.HttpConnectionTest",
    "time_buggy": "2023-09-08 10:13:46 +1000",
    "time_fixed": "2023-09-08 11:00:38 +1000"
}