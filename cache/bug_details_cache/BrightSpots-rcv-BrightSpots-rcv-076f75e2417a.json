{
    "bug_id": "BrightSpots-rcv-076f75e2417a",
    "bug_type": "SF",
    "buggy_lines": "      if (winnerToRound.size() < config.getNumberOfWinners()) {\n        if (currentRoundTally.numActiveCandidates()\n            == config.getNumberOfWinners() - winnerToRound.size()) {\n      boolean useTiebreakerIfNeeded = config.isMultiSeatAllowOnlyOneWinnerPerRoundEnabled()\n          || config.isFirstRoundDeterminesThresholdEnabled();\n      if (useTiebreakerIfNeeded && selectedWinners.size() > 1) {",
    "code": "  private List<String> identifyWinners(\n      RoundTally currentRoundTally,\n      SortedMap<BigDecimal, LinkedList<String>> currentRoundTallyToCandidates)\n      throws TabulationAbortedException {\n    List<String> selectedWinners = new LinkedList<>();\n\n    if (config.isMultiSeatBottomsUpWithThresholdEnabled()) {\n      // if everyone meets the threshold, select them all as winners\n      boolean allMeet = currentRoundTally.getCandidatesWithMoreVotesThan(\n          currentRoundTally.getWinningThreshold()).size()\n          == currentRoundTally.numActiveCandidates();\n      if (allMeet) {\n        selectedWinners.addAll(currentRoundTally.getCandidates());\n      }\n    } else {\n      // We should only look for more winners if we haven't already filled all the seats.\n-      if (winnerToRound.size() < config.getNumberOfWinners()) {\n-        if (currentRoundTally.numActiveCandidates()\n-            == config.getNumberOfWinners() - winnerToRound.size()) {\n          // If the number of continuing candidates equals the number of seats to fill,\n          // everyone wins.\n          selectedWinners.addAll(currentRoundTally.getCandidates());\n        } else if (config.isFirstRoundDeterminesThresholdEnabled()\n              && currentRoundTally.numActiveCandidates() - 1 == config.getNumberOfWinners()) {\n          // Edge case: if nobody meets the threshold, but we're on the penultimate round when\n          // isFirstRoundDeterminesThresholdEnabled is true, select the max vote getters as\n          // the winners. If isFirstRoundDeterminesThresholdEnabled isn't enabled, it should be\n          // impossible for a single-winner election to end up here.\n          BigDecimal maxVotes = currentRoundTallyToCandidates.lastKey();\n          selectedWinners = currentRoundTallyToCandidates.get(maxVotes);\n        } else if (!config.isMultiSeatBottomsUpUntilNWinnersEnabled()) {\n          // Otherwise, select all winners above the threshold\n          selectWinners(currentRoundTallyToCandidates,\n              currentRoundTally.getWinningThreshold(),\n              selectedWinners);\n        }\n      }\n\n      // Edge case: if we've identified multiple winners in this round, but we're only supposed to\n      // elect one winner per round, pick the top vote-getter.\n      // * If this is a multi-winner election, defer the others to subsequent rounds.\n      // * If this is a single-winner election in which it's possible for no candidate to reach the\n      //   threshold (i.e. \"first round determines threshold\" is set), the tiebreaker will choose\n      //   the only winner.\n-      boolean useTiebreakerIfNeeded = config.isMultiSeatAllowOnlyOneWinnerPerRoundEnabled()\n-          || config.isFirstRoundDeterminesThresholdEnabled();\n-      if (useTiebreakerIfNeeded && selectedWinners.size() > 1) {\n        // currentRoundTallyToCandidates is sorted from low to high, so just look at the last key\n        BigDecimal maxVotes = currentRoundTallyToCandidates.lastKey();\n        selectedWinners = currentRoundTallyToCandidates.get(maxVotes);\n        // But if there are multiple candidates tied for the max tally, we need to break the tie.\n        if (selectedWinners.size() > 1) {\n          Tiebreak tiebreak =\n              new Tiebreak(\n                  true,\n                  selectedWinners,\n                  config.getTiebreakMode(),\n                  currentRound,\n                  maxVotes,\n                  roundTallies,\n                  config.getCandidatePermutation());\n          String winner = tiebreak.selectCandidate();\n          // replace the list of tied candidates with our single tie-break winner\n          selectedWinners = new LinkedList<>();\n          selectedWinners.add(winner);\n          Logger.info(\n              \"Candidate \\\"%s\\\" won a tie-breaker in round %d against %s. Each candidate had %s \"\n                  + \"vote(s). %s\",\n              winner,\n              currentRound,\n              tiebreak.nonSelectedCandidateDescription(),\n              maxVotes,\n              tiebreak.getExplanation());\n        }\n      }\n    }\n\n    for (String winner : selectedWinners) {\n      Logger.info(\n          \"Candidate \\\"%s\\\" was elected in round %d with %s votes.\",\n          winner, currentRound, currentRoundTally.getCandidateTally(winner));\n    }\n\n    return selectedWinners;\n  }",
    "fixed_code": "  private List<String> identifyWinners(\n      RoundTally currentRoundTally,\n      SortedMap<BigDecimal, LinkedList<String>> currentRoundTallyToCandidates)\n      throws TabulationAbortedException {\n    List<String> selectedWinners = new LinkedList<>();\n\n    if (config.isMultiSeatBottomsUpWithThresholdEnabled()) {\n      // if everyone meets the threshold, select them all as winners\n      boolean allMeet = currentRoundTally.getCandidatesWithMoreVotesThan(\n          currentRoundTally.getWinningThreshold()).size()\n          == currentRoundTally.numActiveCandidates();\n      if (allMeet) {\n        selectedWinners.addAll(currentRoundTally.getCandidates());\n      }\n    } else {\n      // We should only look for more winners if we haven't already filled all the seats.\n+      int numSeatsUnfilled = config.getNumberOfWinners()   winnerToRound.size();\n+      if (numSeatsUnfilled > 0) {\n+        if (currentRoundTally.numActiveCandidates() == numSeatsUnfilled) {\n          // If the number of continuing candidates equals the number of seats to fill,\n          // everyone wins.\n          selectedWinners.addAll(currentRoundTally.getCandidates());\n        } else if (config.isFirstRoundDeterminesThresholdEnabled()\n              && currentRoundTally.numActiveCandidates() - 1 == config.getNumberOfWinners()) {\n          // Edge case: if nobody meets the threshold, but we're on the penultimate round when\n          // isFirstRoundDeterminesThresholdEnabled is true, select the max vote getters as\n          // the winners. If isFirstRoundDeterminesThresholdEnabled isn't enabled, it should be\n          // impossible for a single-winner election to end up here.\n          BigDecimal maxVotes = currentRoundTallyToCandidates.lastKey();\n          selectedWinners = currentRoundTallyToCandidates.get(maxVotes);\n        } else if (!config.isMultiSeatBottomsUpUntilNWinnersEnabled()) {\n          // Otherwise, select all winners above the threshold\n          selectWinners(currentRoundTallyToCandidates,\n              currentRoundTally.getWinningThreshold(),\n              selectedWinners);\n        }\n      }\n\n      // Edge case: if we've identified multiple winners in this round, but we're only supposed to\n      // elect one winner per round, pick the top vote-getter.\n      // * If this is a multi-winner election, defer the others to subsequent rounds.\n      // * If this is a single-winner election in which it's possible for no candidate to reach the\n      //   threshold (i.e. \"first round determines threshold\" is set), the tiebreaker will choose\n      //   the only winner.\n+      boolean needsTiebreakMultipleWinners = selectedWinners.size() > 1\n+          && (config.isMultiSeatAllowOnlyOneWinnerPerRoundEnabled()\n+          || config.isFirstRoundDeterminesThresholdEnabled());\n+      // Edge case: there are two candidates remaining. To avoid having just one candidate in the\n+      // final round, we break the tie here. Happens when we have unfilled seats, two candidates\n+      // remaining, neither meets the threshold, and both have more than the minimum vote threshold.\n+      // Conditions:\n+      //  1. Single winner election\n+      //  2. There are two remaining candidates\n+      //  3. There is one seat unfilled (i.e. the seat hasn't already been filled in a previous\n+      //           round due to \"Continue Untli Two Remain\" config option)\n+      //  4. All candidates are over the minimum threshold (see no_one_meets_minimum test)\n+      boolean needsTiebreakNoWinners = config.getNumberOfWinners() == 1\n+          && selectedWinners.size() == 0\n+          && currentRoundTally.numActiveCandidates() == 2\n+          && numSeatsUnfilled == 1\n+          && currentRoundTallyToCandidates.keySet().stream().allMatch(\n+              x  > x.compareTo(config.getMinimumVoteThreshold()) >= 0);\n+      if (needsTiebreakMultipleWinners || needsTiebreakNoWinners) {\n        // currentRoundTallyToCandidates is sorted from low to high, so just look at the last key\n        BigDecimal maxVotes = currentRoundTallyToCandidates.lastKey();\n        selectedWinners = currentRoundTallyToCandidates.get(maxVotes);\n        // But if there are multiple candidates tied for the max tally, we need to break the tie.\n        if (selectedWinners.size() > 1) {\n          Tiebreak tiebreak =\n              new Tiebreak(\n                  true,\n                  selectedWinners,\n                  config.getTiebreakMode(),\n                  currentRound,\n                  maxVotes,\n                  roundTallies,\n                  config.getCandidatePermutation());\n          String winner = tiebreak.selectCandidate();\n          // replace the list of tied candidates with our single tie-break winner\n          selectedWinners = new LinkedList<>();\n          selectedWinners.add(winner);\n          Logger.info(\n              \"Candidate \\\"%s\\\" won a tie-breaker in round %d against %s. Each candidate had %s \"\n                  + \"vote(s). %s\",\n              winner,\n              currentRound,\n              tiebreak.nonSelectedCandidateDescription(),\n              maxVotes,\n              tiebreak.getExplanation());\n        }\n      }\n    }\n\n    for (String winner : selectedWinners) {\n      Logger.info(\n          \"Candidate \\\"%s\\\" was elected in round %d with %s votes.\",\n          winner, currentRound, currentRoundTally.getCandidateTally(winner));\n    }\n\n    return selectedWinners;\n  }",
    "fixed_lines": "      int numSeatsUnfilled = config.getNumberOfWinners() - winnerToRound.size();\n      if (numSeatsUnfilled > 0) {\n        if (currentRoundTally.numActiveCandidates() == numSeatsUnfilled) {\n      boolean needsTiebreakMultipleWinners = selectedWinners.size() > 1\n          && (config.isMultiSeatAllowOnlyOneWinnerPerRoundEnabled()\n          || config.isFirstRoundDeterminesThresholdEnabled());\n      // Edge case: there are two candidates remaining. To avoid having just one candidate in the\n      // final round, we break the tie here. Happens when we have unfilled seats, two candidates\n      // remaining, neither meets the threshold, and both have more than the minimum vote threshold.\n      // Conditions:\n      //  1. Single-winner election\n      //  2. There are two remaining candidates\n      //  3. There is one seat unfilled (i.e. the seat hasn't already been filled in a previous\n      //           round due to \"Continue Untli Two Remain\" config option)\n      //  4. All candidates are over the minimum threshold (see no_one_meets_minimum test)\n      boolean needsTiebreakNoWinners = config.getNumberOfWinners() == 1\n          && selectedWinners.size() == 0\n          && currentRoundTally.numActiveCandidates() == 2\n          && numSeatsUnfilled == 1\n          && currentRoundTallyToCandidates.keySet().stream().allMatch(\n              x -> x.compareTo(config.getMinimumVoteThreshold()) >= 0);\n      if (needsTiebreakMultipleWinners || needsTiebreakNoWinners) {",
    "masked_code": "  private List<String> identifyWinners(\n      RoundTally currentRoundTally,\n      SortedMap<BigDecimal, LinkedList<String>> currentRoundTallyToCandidates)\n      throws TabulationAbortedException {\n    List<String> selectedWinners = new LinkedList<>();\n\n    if (config.isMultiSeatBottomsUpWithThresholdEnabled()) {\n      // if everyone meets the threshold, select them all as winners\n      boolean allMeet = currentRoundTally.getCandidatesWithMoreVotesThan(\n          currentRoundTally.getWinningThreshold()).size()\n          == currentRoundTally.numActiveCandidates();\n      if (allMeet) {\n        selectedWinners.addAll(currentRoundTally.getCandidates());\n      }\n    } else {\n      // We should only look for more winners if we haven't already filled all the seats.\n          // If the number of continuing candidates equals the number of seats to fill,\n          // everyone wins.\n          selectedWinners.addAll(currentRoundTally.getCandidates());\n        } else if (config.isFirstRoundDeterminesThresholdEnabled()\n              && currentRoundTally.numActiveCandidates() - 1 == config.getNumberOfWinners()) {\n          // Edge case: if nobody meets the threshold, but we're on the penultimate round when\n          // isFirstRoundDeterminesThresholdEnabled is true, select the max vote getters as\n          // the winners. If isFirstRoundDeterminesThresholdEnabled isn't enabled, it should be\n          // impossible for a single-winner election to end up here.\n          BigDecimal maxVotes = currentRoundTallyToCandidates.lastKey();\n          selectedWinners = currentRoundTallyToCandidates.get(maxVotes);\n        } else if (!config.isMultiSeatBottomsUpUntilNWinnersEnabled()) {\n          // Otherwise, select all winners above the threshold\n          selectWinners(currentRoundTallyToCandidates,\n              currentRoundTally.getWinningThreshold(),\n              selectedWinners);\n        }\n      }\n\n      // Edge case: if we've identified multiple winners in this round, but we're only supposed to\n      // elect one winner per round, pick the top vote-getter.\n      // * If this is a multi-winner election, defer the others to subsequent rounds.\n      // * If this is a single-winner election in which it's possible for no candidate to reach the\n      //   threshold (i.e. \"first round determines threshold\" is set), the tiebreaker will choose\n      //   the only winner.\n>>> [ INFILL ] <<<\n        // currentRoundTallyToCandidates is sorted from low to high, so just look at the last key\n        BigDecimal maxVotes = currentRoundTallyToCandidates.lastKey();\n        selectedWinners = currentRoundTallyToCandidates.get(maxVotes);\n        // But if there are multiple candidates tied for the max tally, we need to break the tie.\n        if (selectedWinners.size() > 1) {\n          Tiebreak tiebreak =\n              new Tiebreak(\n                  true,\n                  selectedWinners,\n                  config.getTiebreakMode(),\n                  currentRound,\n                  maxVotes,\n                  roundTallies,\n                  config.getCandidatePermutation());\n          String winner = tiebreak.selectCandidate();\n          // replace the list of tied candidates with our single tie-break winner\n          selectedWinners = new LinkedList<>();\n          selectedWinners.add(winner);\n          Logger.info(\n              \"Candidate \\\"%s\\\" won a tie-breaker in round %d against %s. Each candidate had %s \"\n                  + \"vote(s). %s\",\n              winner,\n              currentRound,\n              tiebreak.nonSelectedCandidateDescription(),\n              maxVotes,\n              tiebreak.getExplanation());\n        }\n      }\n    }\n\n    for (String winner : selectedWinners) {\n      Logger.info(\n          \"Candidate \\\"%s\\\" was elected in round %d with %s votes.\",\n          winner, currentRound, currentRoundTally.getCandidateTally(winner));\n    }\n\n    return selectedWinners;\n  }",
    "project": "BrightSpots-rcv",
    "test_error_message": "    org.opentest4j.AssertionFailedError at TabulatorTests.java:312",
    "test_framework": "gitbugjava",
    "test_line": "",
    "test_name": "unisyn_xml_cdf_city_council_member",
    "test_suite": "network.brightspots.rcv.TabulatorTests",
    "time_buggy": "2023-07-03 12:15:26 -0400",
    "time_fixed": "2023-07-15 13:59:59 -0400"
}