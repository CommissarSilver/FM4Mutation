{
    "bug_id": "jhy-jsoup-29be991198d3",
    "bug_type": "SF",
    "buggy_lines": "\n            Node next = this.nextSibling();\n            if (couldSkip && isBlank()) return;\n\n            if ((siblingIndex == 0 && parent != null && parent.tag().formatAsBlock() && !isBlank()) ||\n                (out.outline() && siblingNodes().size() > 0 && !isBlank()))",
    "code": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n\n        boolean trimLeading = false;\n        boolean trimTrailing = false;\n        if (normaliseWhite) {\n            trimLeading = (siblingIndex == 0 && parent != null && parent.tag().isBlock()) ||\n                parentNode instanceof Document;\n            trimTrailing = nextSibling() == null && parent != null && parent.tag().isBlock();\n\n            // if this text is just whitespace, and the next node will cause an indent, skip this text:\n-            Node next = this.nextSibling();\n            boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out)) // next will indent\n                || (next instanceof TextNode && (((TextNode) next).isBlank())); // next is blank text, from re-parenting\n-            if (couldSkip && isBlank()) return;\n-\n-            if ((siblingIndex == 0 && parent != null && parent.tag().formatAsBlock() && !isBlank()) ||\n-                (out.outline() && siblingNodes().size() > 0 && !isBlank()))\n                indent(accum, depth, out);\n        }\n\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }",
    "fixed_code": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n\n        boolean trimLeading = false;\n        boolean trimTrailing = false;\n        if (normaliseWhite) {\n            trimLeading = (siblingIndex == 0 && parent != null && parent.tag().isBlock()) ||\n                parentNode instanceof Document;\n            trimTrailing = nextSibling() == null && parent != null && parent.tag().isBlock();\n\n            // if this text is just whitespace, and the next node will cause an indent, skip this text:\n+            Node next = nextSibling();\n+            boolean isBlank = isBlank();\n            boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out)) // next will indent\n                || (next instanceof TextNode && (((TextNode) next).isBlank())); // next is blank text, from re-parenting\n+            if (couldSkip && isBlank) return;\n+\n+            Node prev = previousSibling();\n+            if (\n+                (siblingIndex == 0 && parent != null && parent.tag().formatAsBlock() && !isBlank) ||\n+                (out.outline() && siblingNodes().size() > 0 && !isBlank) ||\n+                (siblingIndex > 0 && prev instanceof Element && ((Element) prev).normalName().equals(\"br\")) // special case wrap on inline <br>   doesn't make sense as a block tag\n+            )\n                indent(accum, depth, out);\n        }\n\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }",
    "fixed_lines": "\n            Node next = nextSibling();\n            boolean isBlank = isBlank();\n            if (couldSkip && isBlank) return;\n\n            Node prev = previousSibling();\n            if (\n                (siblingIndex == 0 && parent != null && parent.tag().formatAsBlock() && !isBlank) ||\n                (out.outline() && siblingNodes().size() > 0 && !isBlank) ||\n                (siblingIndex > 0 && prev instanceof Element && ((Element) prev).normalName().equals(\"br\")) // special case wrap on inline <br> - doesn't make sense as a block tag\n            )",
    "masked_code": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n\n        boolean trimLeading = false;\n        boolean trimTrailing = false;\n        if (normaliseWhite) {\n            trimLeading = (siblingIndex == 0 && parent != null && parent.tag().isBlock()) ||\n                parentNode instanceof Document;\n            trimTrailing = nextSibling() == null && parent != null && parent.tag().isBlock();\n\n            // if this text is just whitespace, and the next node will cause an indent, skip this text:\n            boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out)) // next will indent\n                || (next instanceof TextNode && (((TextNode) next).isBlank())); // next is blank text, from re-parenting\n>>> [ INFILL ] <<<\n                indent(accum, depth, out);\n        }\n\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }",
    "project": "jhy-jsoup",
    "test_error_message": "org.opentest4j.AssertionFailedError: ",
    "test_framework": "gitbugjava",
    "test_line": "",
    "test_name": "testDoesNotForceSelfClosingKnownTags",
    "test_suite": "org.jsoup.parser.XmlTreeBuilderTest",
    "time_buggy": "2023-01-05 13:26:20 +1100",
    "time_fixed": "2023-01-05 17:52:37 +1100"
}