{
    "bug_id": "traccar-traccar-230f629c3dce",
    "bug_type": "SH SF",
    "buggy_lines": "\n                position.setValid(true);\n                position.setLongitude(buf.readInt() / 10000000.0);\n                position.setLatitude(buf.readInt() / 10000000.0);\n                position.setAltitude(buf.readUnsignedShort() / 10.0);\n                position.setCourse(buf.readUnsignedShort() / 100.0);\n\n                position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n\n                position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShort()));\n\n                position.set(Position.KEY_HDOP, buf.readUnsignedByte() / 10.0);",
    "code": "    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        ByteBuf buf = (ByteBuf) msg;\n\n        buf.readUnsignedShort(); // data length\n\n        String imei = String.format(\"%015d\", buf.readLong());\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, imei);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        int type = buf.readUnsignedByte();\n\n        if (type == MSG_RECORDS || type == MSG_EXTENDED_RECORDS) {\n\n            List<Position> positions = new LinkedList<>();\n\n            buf.readUnsignedByte(); // records left\n            int count = buf.readUnsignedByte();\n\n            for (int i = 0; i < count; i++) {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n\n                position.setTime(new Date(buf.readUnsignedInt() * 1000));\n                buf.readUnsignedByte(); // timestamp extension\n\n                if (type == MSG_EXTENDED_RECORDS) {\n                    int recordExtension = buf.readUnsignedByte();\n                    int mergeRecordCount = BitUtil.from(recordExtension, 4);\n                    int currentRecord = BitUtil.to(recordExtension, 4);\n\n                    if (currentRecord > 0 && currentRecord <= mergeRecordCount) {\n                        position = positions.remove(positions.size() - 1);\n                    }\n                }\n\n                buf.readUnsignedByte(); // priority (reserved)\n\n-                position.setValid(true);\n-                position.setLongitude(buf.readInt() / 10000000.0);\n-                position.setLatitude(buf.readInt() / 10000000.0);\n-                position.setAltitude(buf.readUnsignedShort() / 10.0);\n-                position.setCourse(buf.readUnsignedShort() / 100.0);\n-\n-                position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n-\n-                position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShort()));\n-\n-                position.set(Position.KEY_HDOP, buf.readUnsignedByte() / 10.0);\n\n                if (type == MSG_EXTENDED_RECORDS) {\n                    position.set(Position.KEY_EVENT, buf.readUnsignedShort());\n                } else {\n                    position.set(Position.KEY_EVENT, buf.readUnsignedByte());\n                }\n\n                // Read 1 byte data\n                int valueCount = buf.readUnsignedByte();\n                for (int j = 0; j < valueCount; j++) {\n                    int id = type == MSG_EXTENDED_RECORDS ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                    decodeParameter(position, id, buf, 1);\n                }\n\n                // Read 2 byte data\n                valueCount = buf.readUnsignedByte();\n                for (int j = 0; j < valueCount; j++) {\n                    int id = type == MSG_EXTENDED_RECORDS ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                    decodeParameter(position, id, buf, 2);\n                }\n\n                // Read 4 byte data\n                valueCount = buf.readUnsignedByte();\n                for (int j = 0; j < valueCount; j++) {\n                    int id = type == MSG_EXTENDED_RECORDS ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                    decodeParameter(position, id, buf, 4);\n                }\n\n                // Read 8 byte data\n                valueCount = buf.readUnsignedByte();\n                for (int j = 0; j < valueCount; j++) {\n                    int id = type == MSG_EXTENDED_RECORDS ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                    decodeParameter(position, id, buf, 8);\n                }\n\n                decodeDriver(position, Position.PREFIX_IO + 126, Position.PREFIX_IO + 127); // can driver\n                decodeDriver(position, Position.PREFIX_IO + 155, Position.PREFIX_IO + 156); // tco driver\n\n                Long tagIdPart1 = (Long) position.getAttributes().remove(Position.PREFIX_IO + 760);\n                Long tagIdPart2 = (Long) position.getAttributes().remove(Position.PREFIX_IO + 761);\n                if (tagIdPart1 != null && tagIdPart2 != null) {\n                    position.set(\"tagId\", Long.toHexString(tagIdPart1) + Long.toHexString(tagIdPart2));\n                }\n\n                positions.add(position);\n            }\n\n            if (channel != null) {\n                channel.writeAndFlush(new NetworkMessage(\n                        Unpooled.wrappedBuffer(DataConverter.parseHex(\"0002640113bc\")), remoteAddress));\n            }\n\n            return positions;\n\n        } else if (type == MSG_DTCS) {\n\n            List<Position> positions = new LinkedList<>();\n\n            int count = buf.readUnsignedByte();\n\n            for (int i = 0; i < count; i++) {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n\n                buf.readUnsignedByte(); // reserved\n\n                position.setTime(new Date(buf.readUnsignedInt() * 1000));\n\n                position.setValid(true);\n                position.setLongitude(buf.readInt() / 10000000.0);\n                position.setLatitude(buf.readInt() / 10000000.0);\n\n                if (buf.readUnsignedByte() == 2) {\n                    position.set(Position.KEY_ARCHIVE, true);\n                }\n\n                position.set(Position.KEY_DTCS, buf.readSlice(5).toString(StandardCharsets.US_ASCII));\n\n                positions.add(position);\n            }\n\n            if (channel != null) {\n                channel.writeAndFlush(new NetworkMessage(\n                        Unpooled.wrappedBuffer(DataConverter.parseHex(\"00026d01c4a4\")), remoteAddress));\n            }\n\n            return positions;\n\n        } else if (type == MSG_FILES) {\n\n            int subtype = buf.readUnsignedByte();\n            int source = buf.readUnsignedByte();\n\n            if (subtype == 2) {\n                ByteBuf filename = buf.readSlice(8);\n                int total = buf.readUnsignedShort();\n                int current = buf.readUnsignedShort();\n                if (photo == null) {\n                    photo = Unpooled.buffer();\n                }\n                photo.writeBytes(buf.readSlice(buf.readableBytes() - 2));\n                if (current < total - 1) {\n                    ByteBuf content = Unpooled.buffer();\n                    content.writeByte(subtype);\n                    content.writeByte(source);\n                    content.writeBytes(filename);\n                    content.writeShort(current + 1);\n                    ByteBuf response = RuptelaProtocolEncoder.encodeContent(type, content);\n                    content.release();\n                    if (channel != null) {\n                        channel.writeAndFlush(new NetworkMessage(response, remoteAddress));\n                    }\n                } else {\n                    Position position = new Position(getProtocolName());\n                    position.setDeviceId(deviceSession.getDeviceId());\n                    getLastLocation(position, null);\n                    position.set(Position.KEY_IMAGE, writeMediaFile(imei, photo, \"jpg\"));\n                    photo.release();\n                    photo = null;\n                    return position;\n                }\n            }\n\n            return null;\n\n        } else if (type == MSG_IDENTIFICATION) {\n\n            ByteBuf content = Unpooled.buffer();\n            content.writeByte(1);\n            ByteBuf response = RuptelaProtocolEncoder.encodeContent(type, content);\n            content.release();\n            if (channel != null) {\n                channel.writeAndFlush(new NetworkMessage(response, remoteAddress));\n            }\n\n            return null;\n\n        } else {\n\n            return decodeCommandResponse(deviceSession, type, buf);\n\n        }\n    }",
    "fixed_code": "    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        ByteBuf buf = (ByteBuf) msg;\n\n        buf.readUnsignedShort(); // data length\n\n        String imei = String.format(\"%015d\", buf.readLong());\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, imei);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        int type = buf.readUnsignedByte();\n\n        if (type == MSG_RECORDS || type == MSG_EXTENDED_RECORDS) {\n\n            List<Position> positions = new LinkedList<>();\n\n            buf.readUnsignedByte(); // records left\n            int count = buf.readUnsignedByte();\n\n            for (int i = 0; i < count; i++) {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n\n                position.setTime(new Date(buf.readUnsignedInt() * 1000));\n                buf.readUnsignedByte(); // timestamp extension\n\n                if (type == MSG_EXTENDED_RECORDS) {\n                    int recordExtension = buf.readUnsignedByte();\n                    int mergeRecordCount = BitUtil.from(recordExtension, 4);\n                    int currentRecord = BitUtil.to(recordExtension, 4);\n\n                    if (currentRecord > 0 && currentRecord <= mergeRecordCount) {\n                        position = positions.remove(positions.size() - 1);\n                    }\n                }\n\n                buf.readUnsignedByte(); // priority (reserved)\n\n+                int longitude = buf.readInt();\n+                int latitude = buf.readInt();\n+                if (longitude > Integer.MIN_VALUE && latitude > Integer.MIN_VALUE) {\n+                    position.setValid(true);\n+                    position.setLongitude(longitude / 10000000.0);\n+                    position.setLatitude(latitude / 10000000.0);\n+                    position.setAltitude(buf.readUnsignedShort() / 10.0);\n+                    position.setCourse(buf.readUnsignedShort() / 100.0);\n+                    position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n+                    position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShort()));\n+                    position.set(Position.KEY_HDOP, buf.readUnsignedByte() / 10.0);\n+                } else {\n+                    buf.skipBytes(8);\n+                    getLastLocation(position, null);\n+                }\n\n                if (type == MSG_EXTENDED_RECORDS) {\n                    position.set(Position.KEY_EVENT, buf.readUnsignedShort());\n                } else {\n                    position.set(Position.KEY_EVENT, buf.readUnsignedByte());\n                }\n\n                // Read 1 byte data\n                int valueCount = buf.readUnsignedByte();\n                for (int j = 0; j < valueCount; j++) {\n                    int id = type == MSG_EXTENDED_RECORDS ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                    decodeParameter(position, id, buf, 1);\n                }\n\n                // Read 2 byte data\n                valueCount = buf.readUnsignedByte();\n                for (int j = 0; j < valueCount; j++) {\n                    int id = type == MSG_EXTENDED_RECORDS ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                    decodeParameter(position, id, buf, 2);\n                }\n\n                // Read 4 byte data\n                valueCount = buf.readUnsignedByte();\n                for (int j = 0; j < valueCount; j++) {\n                    int id = type == MSG_EXTENDED_RECORDS ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                    decodeParameter(position, id, buf, 4);\n                }\n\n                // Read 8 byte data\n                valueCount = buf.readUnsignedByte();\n                for (int j = 0; j < valueCount; j++) {\n                    int id = type == MSG_EXTENDED_RECORDS ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                    decodeParameter(position, id, buf, 8);\n                }\n\n                decodeDriver(position, Position.PREFIX_IO + 126, Position.PREFIX_IO + 127); // can driver\n                decodeDriver(position, Position.PREFIX_IO + 155, Position.PREFIX_IO + 156); // tco driver\n\n                Long tagIdPart1 = (Long) position.getAttributes().remove(Position.PREFIX_IO + 760);\n                Long tagIdPart2 = (Long) position.getAttributes().remove(Position.PREFIX_IO + 761);\n                if (tagIdPart1 != null && tagIdPart2 != null) {\n                    position.set(\"tagId\", Long.toHexString(tagIdPart1) + Long.toHexString(tagIdPart2));\n                }\n\n                positions.add(position);\n            }\n\n            if (channel != null) {\n                channel.writeAndFlush(new NetworkMessage(\n                        Unpooled.wrappedBuffer(DataConverter.parseHex(\"0002640113bc\")), remoteAddress));\n            }\n\n            return positions;\n\n        } else if (type == MSG_DTCS) {\n\n            List<Position> positions = new LinkedList<>();\n\n            int count = buf.readUnsignedByte();\n\n            for (int i = 0; i < count; i++) {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n\n                buf.readUnsignedByte(); // reserved\n\n                position.setTime(new Date(buf.readUnsignedInt() * 1000));\n\n                position.setValid(true);\n                position.setLongitude(buf.readInt() / 10000000.0);\n                position.setLatitude(buf.readInt() / 10000000.0);\n\n                if (buf.readUnsignedByte() == 2) {\n                    position.set(Position.KEY_ARCHIVE, true);\n                }\n\n                position.set(Position.KEY_DTCS, buf.readSlice(5).toString(StandardCharsets.US_ASCII));\n\n                positions.add(position);\n            }\n\n            if (channel != null) {\n                channel.writeAndFlush(new NetworkMessage(\n                        Unpooled.wrappedBuffer(DataConverter.parseHex(\"00026d01c4a4\")), remoteAddress));\n            }\n\n            return positions;\n\n        } else if (type == MSG_FILES) {\n\n            int subtype = buf.readUnsignedByte();\n            int source = buf.readUnsignedByte();\n\n            if (subtype == 2) {\n                ByteBuf filename = buf.readSlice(8);\n                int total = buf.readUnsignedShort();\n                int current = buf.readUnsignedShort();\n                if (photo == null) {\n                    photo = Unpooled.buffer();\n                }\n                photo.writeBytes(buf.readSlice(buf.readableBytes() - 2));\n                if (current < total - 1) {\n                    ByteBuf content = Unpooled.buffer();\n                    content.writeByte(subtype);\n                    content.writeByte(source);\n                    content.writeBytes(filename);\n                    content.writeShort(current + 1);\n                    ByteBuf response = RuptelaProtocolEncoder.encodeContent(type, content);\n                    content.release();\n                    if (channel != null) {\n                        channel.writeAndFlush(new NetworkMessage(response, remoteAddress));\n                    }\n                } else {\n                    Position position = new Position(getProtocolName());\n                    position.setDeviceId(deviceSession.getDeviceId());\n                    getLastLocation(position, null);\n                    position.set(Position.KEY_IMAGE, writeMediaFile(imei, photo, \"jpg\"));\n                    photo.release();\n                    photo = null;\n                    return position;\n                }\n            }\n\n            return null;\n\n        } else if (type == MSG_IDENTIFICATION) {\n\n            ByteBuf content = Unpooled.buffer();\n            content.writeByte(1);\n            ByteBuf response = RuptelaProtocolEncoder.encodeContent(type, content);\n            content.release();\n            if (channel != null) {\n                channel.writeAndFlush(new NetworkMessage(response, remoteAddress));\n            }\n\n            return null;\n\n        } else {\n\n            return decodeCommandResponse(deviceSession, type, buf);\n\n        }\n    }",
    "fixed_lines": "\n                int longitude = buf.readInt();\n                int latitude = buf.readInt();\n                if (longitude > Integer.MIN_VALUE && latitude > Integer.MIN_VALUE) {\n                    position.setValid(true);\n                    position.setLongitude(longitude / 10000000.0);\n                    position.setLatitude(latitude / 10000000.0);\n                    position.setAltitude(buf.readUnsignedShort() / 10.0);\n                    position.setCourse(buf.readUnsignedShort() / 100.0);\n                    position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                    position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShort()));\n                    position.set(Position.KEY_HDOP, buf.readUnsignedByte() / 10.0);\n                } else {\n                    buf.skipBytes(8);\n                    getLastLocation(position, null);\n                }",
    "masked_code": "    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        ByteBuf buf = (ByteBuf) msg;\n\n        buf.readUnsignedShort(); // data length\n\n        String imei = String.format(\"%015d\", buf.readLong());\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, imei);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        int type = buf.readUnsignedByte();\n\n        if (type == MSG_RECORDS || type == MSG_EXTENDED_RECORDS) {\n\n            List<Position> positions = new LinkedList<>();\n\n            buf.readUnsignedByte(); // records left\n            int count = buf.readUnsignedByte();\n\n            for (int i = 0; i < count; i++) {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n\n                position.setTime(new Date(buf.readUnsignedInt() * 1000));\n                buf.readUnsignedByte(); // timestamp extension\n\n                if (type == MSG_EXTENDED_RECORDS) {\n                    int recordExtension = buf.readUnsignedByte();\n                    int mergeRecordCount = BitUtil.from(recordExtension, 4);\n                    int currentRecord = BitUtil.to(recordExtension, 4);\n\n                    if (currentRecord > 0 && currentRecord <= mergeRecordCount) {\n                        position = positions.remove(positions.size() - 1);\n                    }\n                }\n\n                buf.readUnsignedByte(); // priority (reserved)\n\n>>> [ INFILL ] <<<\n\n                if (type == MSG_EXTENDED_RECORDS) {\n                    position.set(Position.KEY_EVENT, buf.readUnsignedShort());\n                } else {\n                    position.set(Position.KEY_EVENT, buf.readUnsignedByte());\n                }\n\n                // Read 1 byte data\n                int valueCount = buf.readUnsignedByte();\n                for (int j = 0; j < valueCount; j++) {\n                    int id = type == MSG_EXTENDED_RECORDS ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                    decodeParameter(position, id, buf, 1);\n                }\n\n                // Read 2 byte data\n                valueCount = buf.readUnsignedByte();\n                for (int j = 0; j < valueCount; j++) {\n                    int id = type == MSG_EXTENDED_RECORDS ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                    decodeParameter(position, id, buf, 2);\n                }\n\n                // Read 4 byte data\n                valueCount = buf.readUnsignedByte();\n                for (int j = 0; j < valueCount; j++) {\n                    int id = type == MSG_EXTENDED_RECORDS ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                    decodeParameter(position, id, buf, 4);\n                }\n\n                // Read 8 byte data\n                valueCount = buf.readUnsignedByte();\n                for (int j = 0; j < valueCount; j++) {\n                    int id = type == MSG_EXTENDED_RECORDS ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                    decodeParameter(position, id, buf, 8);\n                }\n\n                decodeDriver(position, Position.PREFIX_IO + 126, Position.PREFIX_IO + 127); // can driver\n                decodeDriver(position, Position.PREFIX_IO + 155, Position.PREFIX_IO + 156); // tco driver\n\n                Long tagIdPart1 = (Long) position.getAttributes().remove(Position.PREFIX_IO + 760);\n                Long tagIdPart2 = (Long) position.getAttributes().remove(Position.PREFIX_IO + 761);\n                if (tagIdPart1 != null && tagIdPart2 != null) {\n                    position.set(\"tagId\", Long.toHexString(tagIdPart1) + Long.toHexString(tagIdPart2));\n                }\n\n                positions.add(position);\n            }\n\n            if (channel != null) {\n                channel.writeAndFlush(new NetworkMessage(\n                        Unpooled.wrappedBuffer(DataConverter.parseHex(\"0002640113bc\")), remoteAddress));\n            }\n\n            return positions;\n\n        } else if (type == MSG_DTCS) {\n\n            List<Position> positions = new LinkedList<>();\n\n            int count = buf.readUnsignedByte();\n\n            for (int i = 0; i < count; i++) {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n\n                buf.readUnsignedByte(); // reserved\n\n                position.setTime(new Date(buf.readUnsignedInt() * 1000));\n\n                position.setValid(true);\n                position.setLongitude(buf.readInt() / 10000000.0);\n                position.setLatitude(buf.readInt() / 10000000.0);\n\n                if (buf.readUnsignedByte() == 2) {\n                    position.set(Position.KEY_ARCHIVE, true);\n                }\n\n                position.set(Position.KEY_DTCS, buf.readSlice(5).toString(StandardCharsets.US_ASCII));\n\n                positions.add(position);\n            }\n\n            if (channel != null) {\n                channel.writeAndFlush(new NetworkMessage(\n                        Unpooled.wrappedBuffer(DataConverter.parseHex(\"00026d01c4a4\")), remoteAddress));\n            }\n\n            return positions;\n\n        } else if (type == MSG_FILES) {\n\n            int subtype = buf.readUnsignedByte();\n            int source = buf.readUnsignedByte();\n\n            if (subtype == 2) {\n                ByteBuf filename = buf.readSlice(8);\n                int total = buf.readUnsignedShort();\n                int current = buf.readUnsignedShort();\n                if (photo == null) {\n                    photo = Unpooled.buffer();\n                }\n                photo.writeBytes(buf.readSlice(buf.readableBytes() - 2));\n                if (current < total - 1) {\n                    ByteBuf content = Unpooled.buffer();\n                    content.writeByte(subtype);\n                    content.writeByte(source);\n                    content.writeBytes(filename);\n                    content.writeShort(current + 1);\n                    ByteBuf response = RuptelaProtocolEncoder.encodeContent(type, content);\n                    content.release();\n                    if (channel != null) {\n                        channel.writeAndFlush(new NetworkMessage(response, remoteAddress));\n                    }\n                } else {\n                    Position position = new Position(getProtocolName());\n                    position.setDeviceId(deviceSession.getDeviceId());\n                    getLastLocation(position, null);\n                    position.set(Position.KEY_IMAGE, writeMediaFile(imei, photo, \"jpg\"));\n                    photo.release();\n                    photo = null;\n                    return position;\n                }\n            }\n\n            return null;\n\n        } else if (type == MSG_IDENTIFICATION) {\n\n            ByteBuf content = Unpooled.buffer();\n            content.writeByte(1);\n            ByteBuf response = RuptelaProtocolEncoder.encodeContent(type, content);\n            content.release();\n            if (channel != null) {\n                channel.writeAndFlush(new NetworkMessage(response, remoteAddress));\n            }\n\n            return null;\n\n        } else {\n\n            return decodeCommandResponse(deviceSession, type, buf);\n\n        }\n    }",
    "project": "traccar-traccar",
    "test_error_message": "    java.lang.IllegalArgumentException at RuptelaProtocolDecoderTest.java:16",
    "test_framework": "gitbugjava",
    "test_line": "",
    "test_name": "testDecode()",
    "test_suite": "org.traccar.protocol.RuptelaProtocolDecoderTest",
    "time_buggy": "2023-07-28 17:17:41 -0700",
    "time_fixed": "2023-08-03 21:06:52 -0700"
}